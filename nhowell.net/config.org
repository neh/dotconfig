#+property: header-args :mkdirp yes :comments no :results silent
#+startup: showall

#+title: My config files
#+author: Nathan Howell
#+email: nath@nhowell.net

* Little bits
** Sound setups

Some quick commands for setting devices up without clicking around the settings app. Probably don't need to do a lot of fancifying here with pipewire coming along?

For desktop use with speakers:
#+begin_src sh
pactl set-default-source alsa_input.usb-046d_HD_Pro_Webcam_C920_C2D6BAFF-02.analog-stereo
pactl set-default-sink alsa_output.usb-C-Media_Electronics_Inc._USB_Audio_Device-00.analog-stereo
#+end_src

For normal use of sony headphones:
#+begin_src sh
pacmd set-card-profile bluez_card.94_DB_56_63_CE_1E a2dp_sink
pactl set-default-source alsa_input.usb-046d_HD_Pro_Webcam_C920_C2D6BAFF-02.analog-stereo
pactl set-default-sink bluez_sink.94_DB_56_63_CE_1E.a2dp_sink
# pactl set-default-sink bluez_sink.94_DB_56_63_CE_1E.a2dp_sink
#+end_src

For zoom with sony headphones:
#+begin_src sh
pacmd set-card-profile bluez_card.94_DB_56_63_CE_1E headset_head_unit
pactl set-default-sink bluez_sink.94_DB_56_63_CE_1E.headset_head_unit
pactl set-default-source bluez_sink.94_DB_56_63_CE_1E.headset_head_unit.monitor
#+end_src

** Git config
Would like to get this in here. Will need to deal with conditional bits like identity on work/personal boxes. Useful stuff on =include= and =includeIf= in git configuration in [[https://blog.thomasheartman.com/posts/modularizing-your-git-config-with-conditional-includes][this article]].

This looks like a handy alias to include ([[https://carolynvanslyck.com/blog/2020/12/git-wip/][source]]):
#+begin_src conf
[alias]
  wip = for-each-ref --sort='authordate:iso8601' --format=' %(color:green)%(authordate:relative)%09%(color:white)%(refname:short)' refs/heads
#+end_src

** Dconf (Gnome settings)
Gnome desktop and related settings are stored in dconf, which has a binary database format that is not conducive to version control. I tried a few ways to deal with this, none of which were especially good, and then this well-titled article popped up: [[https://anarc.at/blog/2020-03-02-moving-dconf-entries-to-git/][Moving dconf entries to git]]. I'm extremely grateful for this post and the resources it references: [[https://annex.debconf.org/debconf-share/debconf14/slides/josh-triplett-dconf-git-home/dconf.pdf][Josh Triplett's Debconf 14 talk]], and an accompanying [[https://joshtriplett.org/git/home][git repo]] (that's useful as a git clone URL, not a browser one). That post explains things pretty well, but I'm going to do my own version of it here, with the benefit of org mode and src blocks so I can tangle the files right into place. All of the scripts in this section originally came from Josh Triplett's git repo.

A key point is that dconf doesn't /only/ use a binary database as a configuration source. It can also use text files when configured to do so. To point dconf at a specific configuration, you set the =DCONF_PROFILE= environment variable. I set this for both the zsh and fish shells.

#+begin_src fish :noweb-ref fish_env
set -gx DCONF_PROFILE $HOME/.config/dconf/profile
#+end_src

#+begin_src sh :noweb-ref zsh_env
export DCONF_PROFILE=$HOME/.config/dconf/profile
#+end_src

And here's the config file that variable points at. The first line is just the default setting, and tells dconf to use =~/.config/dconf/user= as its binary database file. The second line tells dconf to /also/ use =~/.config/dconf/user.txt= as a configuration source. I'm not including that file here in this org file, but it is versioned in this repository.

#+begin_src conf :tangle ~/.config/dconf/profile
user-db:user
service-db:keyfile/user
#+end_src

This next config file is used when editing settings that need to end up in the text file only. So if you override the original value of =DCONF_PROFILE= to point at this file and run, say, =dconf-editor=, any changed settings will end up in the text file.

#+begin_src conf :tangle ~/.config/dconf/profile-edit
service-db:keyfile/user
#+end_src

Here's a convenient little script to make that easier. Run something like =dconfe dconf-editor= to easily get changed settings into the =user.txt= file.

#+begin_src sh :tangle ~/.local/bin/dconfe :shebang #!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
DCONF_PROFILE="${DCONF_PROFILE}-edit" exec "$@"
#+end_src

Given a path in the dconf database (eg. =/org/gnome/desktop=), =dconfc= will extract any settings that are different from the default into the text file, then reset them in the binary database.

#+begin_src sh :tangle ~/.local/bin/dconfc :shebang #!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
set -e

if [ "$#" -ne 1 ] || [ "${1#/}" = "$1" ]; then
    echo "Usage: dconfc PATH" >&2
    exit 1
fi

if [ "${1%/}" != "$1" ]; then
    dconf dump "$1" | dconfe dconf load "$1"
else
    dconfe dconf write "$1" "$(dconf read "$1")"
fi
dconf reset -f "$1"
#+end_src

=dconfd= will list all the settings (and their values) that are not the same in the binary and text config files. Passing it a dconf path will limit it to subkeys of that path.

#+begin_src python :tangle ~/.local/bin/dconfd :shebang #!/usr/bin/python3
# SPDX-License-Identifier: GPL-3.0-or-later
import fnmatch, os, subprocess, sys

def parse_ignore_patterns(l):
    for p in l:
        if p.startswith("#"):
            continue
        p = p.rstrip()
        if not p:
            continue
        yield p

def main(args):
    if len(args) == 1:
        root = "/"
    elif len(args) == 2:
        root = args[1]
    else:
        print("Usage: dconfd [PATH]", file=sys.stderr)
        return 2

    config_home = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
    try:
        ignore_patterns = list(parse_ignore_patterns
                               (open
                                (os.path.join(config_home, "dconf/dconfd-ignore"))))
    except IOError:
        ignore_patterns = []
    def ignored(name):
        for p in ignore_patterns:
            if fnmatch.fnmatch(name, p):
                return True
        return False

    changed = False

    if root.endswith("/"):
        keys = set()
        for prefix in [], ["dconfe"]:
            keys |= set(key for key in subprocess.check_output(prefix + ["dconf-list-recursively", root]).decode('utf-8').split()
                        if key and (prefix or not ignored(key)))
        keys = sorted(keys)
    else:
        keys = [root]

    for key in keys:
        v1 = subprocess.check_output(["dconfe", "dconf", "read", key]).decode('utf-8').rstrip()
        v2 = subprocess.check_output(["dconf", "read", key]).decode('utf-8').rstrip()
        if v1 == v2:
            continue
        if not changed:
            changed = True
            print("--- service-db")
            print("+++ user-db")
        if v1:
            print("- {} {}".format(key, v1))
        if v2:
            print("+ {} {}".format(key, v2))

    if changed:
        return 1

if __name__ == "__main__":
    sys.exit(main(sys.argv))
#+end_src

#+begin_src sh :tangle ~/.local/bin/dconf-list-recursively :shebang #!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
l() {
    dconf list "$1" | while read key ; do
        if [ "${key%/}" != "$key" ] ; then
            l "$1$key"
        else
            echo "$1$key"
        fi
    done
}
l "$1"
#+end_src

This file lists configuration paths to ignore when running =dconfd=. Not sure it's all that useful since other scripts like =dconfc= don't use it.

#+begin_src text :tangle ~/.config/dconf/dconfd-ignore
/ca/desrt/dconf-editor/*
/org/gnome/Disks/*
/org/gnome/Totem/*
/org/gnome/baobab/*
/org/gnome/calculator/*
/org/gnome/charmap/*
/org/gnome/cheese/*
/org/gnome/control-center/*
/org/gnome/eog/*
/org/gnome/evince/*
/org/gnome/evolution*
/org/gnome/gedit/*
/org/gnome/libgnomekbd/*
/org/gnome/nm-applet/*
/org/gnome/shell/extensions/paperwm/workspaces/*
/org/gtk/settings/file-chooser/*
#+end_src

** Dark mode toggle

#+begin_src bash :tangle ~/.local/bin/dark-toggle :shebang #!/bin/bash
if [[ "$USER" == "nhowell" ]]; then
    # work
    GTK_THEME_LIGHT='Yaru-light'
    GTK_THEME_DARK='Yaru-dark'
else
    # home
    GTK_THEME_LIGHT='Adwaita'
    GTK_THEME_DARK='Adwaita-dark'
fi

ALACRITTY_LIGHT='modus_operandi'
ALACRITTY_DARK='gruvbox_dark'

current_theme=$(gsettings get org.gnome.desktop.interface gtk-theme | tr -d "'")
current_scheme=$(gsettings get org.gnome.desktop.interface color-scheme | tr -d "'")

if [[ "$current_scheme" == "prefer-dark" ]]; then
    # echo "Currently dark, going light"
    gsettings set org.gnome.desktop.interface color-scheme "default"
    gsettings set org.gnome.desktop.interface gtk-theme $GTK_THEME_LIGHT
    if [[ -e ~/.config/alacritty/schemes.yml ]]; then
        sed -i "s/colors: \*${ALACRITTY_DARK}$/colors: *${ALACRITTY_LIGHT}/" ~/.config/alacritty/schemes.yml
    fi
else
    # echo "Currently not dark, going dark"
    gsettings set org.gnome.desktop.interface color-scheme "prefer-dark"
    gsettings set org.gnome.desktop.interface gtk-theme $GTK_THEME_DARK
    if [[ -e ~/.config/alacritty/schemes.yml ]]; then
        sed -i "s/colors: \*${ALACRITTY_LIGHT}$/colors: *${ALACRITTY_DARK}/" ~/.config/alacritty/schemes.yml
    fi
fi
#+end_src

#+name: username
#+begin_src emacs-lisp
user-login-name
#+end_src

#+begin_src conf :tangle ~/.local/share/applications/dark-toggle.desktop :noweb yes
[Desktop Entry]
Name=Toggle Dark Mode
Exec=/home/<<username()>>/.local/bin/dark-toggle
Icon=settings
Type=Application
Terminal=false
Categories=Utility;
#+end_src

** Fade inactive windows

#+begin_src python :tangle ~/bin/focus-opacity.py :shebang #!/usr/bin/env python
import i3ipc
from time import sleep

ipc = i3ipc.Connection()

fade_time = 0.08
fade_steps = 10
opacity = 0.90


def fade_opacity(c, start, end):
    step = round(abs(start - end) / fade_steps, 2)
    for _ in range(fade_steps):
        if start > end:
            c.command('opacity ' + str(end + step))
            end += step
        elif end > start:
            c.command('opacity ' + str(start + step))
            start += step
        sleep(fade_time / fade_steps)


def on_window_focus(ipc, _):
    current = False
    for c in ipc.get_tree():
        if c.focused:
            current = c
        if not c.focused:
            c.command('opacity ' + str(opacity))
    if current:
        fade_opacity(current, opacity, 1)


ipc.on("window::focus", on_window_focus)
ipc.main()
#+end_src

Full opacity for all windows.

#+begin_src python :shebang #!/usr/bin/env python
import i3ipc
from time import sleep

ipc = i3ipc.Connection()

for c in ipc.get_tree():
    c.command('opacity 1')
#+end_src

** Screenshootering (because Wayland)
*** Visual area
Use [[https://github.com/emersion/slurp][slurp]] to get a visual area selector, and [[https://github.com/emersion/grim][grim]] to take the shot. Set all windows to full opacity first, and use zenity to get a gtk file chooser.

#+begin_src bash :tangle ~/bin/wl-screenshot :shebang #!/bin/bash
~/bin/no-opacity.py
grim -g "$(slurp)" $(zenity --file-selection --save --confirm-overwrite)
#+end_src

*** TODO Whole output/window etc.
Multi output handling? Click to select? Use rofi with an output/window list?

*** Support bits

Set all windows to full opacity. Useful to run before taking a screenshot, since I have non-focused windows at slightly less than full opacity.

#+begin_src python :tangle ~/bin/no-opacity.py :shebang #!/usr/bin/env python
import i3ipc
ipc = i3ipc.Connection()

for c in ipc.get_tree():
    c.command('opacity 1')
#+end_src

Get the title of the most recently focused window on each workspace. I want to modify this (translate to C++) to contribute to waybar so I can have the window title on the bar for each workspace show the title of the window that's actually on that screen.

#+begin_src python :shebang #!/usr/bin/env python :results output
import i3ipc
ipc = i3ipc.Connection()

visible_workspaces = []
for workspace in ipc.get_workspaces():
    if workspace.visible:
        visible_workspaces.append(workspace.name)

for node in ipc.get_tree():
    if node.type == 'workspace' and node.name in visible_workspaces:
         print(node.name)
         for subnode in node.nodes + node.floating_nodes:
             if subnode.id == node.focus[0] and subnode.type in ['con', 'floating_con']:
                  print(subnode.name)
#+end_src

#+begin_src python :tangle ~/bin/dock-outputs.py :shebang #!/usr/bin/env python :results output
import i3ipc
ipc = i3ipc.Connection()

for output in ipc.get_outputs():
    if output.active and output.name != 'eDP-1':
        # print(output.name)
        ipc.command('output eDP-1 disable')
        break
#+end_src

** Smart window sizing

#+begin_src python :tangle ~/bin/smart-sizing.py :shebang #!/usr/bin/env python :results output
import inspect
import pprint
import i3ipc
ipc = i3ipc.Connection()

pp = pprint.PrettyPrinter(indent=2)

sizes = {
    "Emacs": 830,
    # "Firefox": 1250,
    # "Chrome": 1250,
    # "Chromium": 1250,
}


def on_window_focus(ipc, e):
    # for output in ipc.get_outputs():
    #     if output.active:
    #         pp.pprint(inspect.getmembers(output))

    # for yo in ipc.get_tree().find_focused().workspace().descendents():
    #     print(yo.type, yo.name)
    #     if not yo.name:
    #         print(yo.rect.width, yo.rect.height)

    # for ws in ipc.get_workspaces():
    #     if ws.visible:
    #         pp.pprint(inspect.getmembers(ws))

    for thing in ipc.get_tree():
        if thing.type == "con":
            # if thing.window_class:
            #     print(thing.window_class)
            # if thing.window_role:
            #     print(thing.window_role)
            if thing.window_class in sizes:
                # while 'parent' in thing:
                # pp.pprint(inspect.getmembers(thing))
                # print(thing.name, thing.rect.width)
                print(thing.name, thing.parent.id)
                if abs(thing.rect.width - sizes[thing.window_class]) > 15:
                    print("Resizing %s from %d to %d" % (thing.name,
                                                         thing.rect.width,
                                                         sizes[thing.window_class]))
                    thing.command("resize set width %d px" % sizes[thing.window_class])


ipc.on("window::focus", on_window_focus)
ipc.main()
#+end_src

** All terminal windows are tmux
Revisiting this tmux setup after a few years of not using it was pretty confusing, so since I've managed to decipher what I was thinking when I first set it up, I'm going to actually explain myself here.

The idea is to have every terminal I launch join a common tmux session. Just doing a simple attach would work, but wouldn't handle terminal windows of different sizes very well. The thing to use here is tmux session groups, which are independent views into one set of windows, so they can each have their own size. [[https://gist.github.com/chakrit/5004006][This github gist]] describes the same idea, and I remember finding it when I was originally getting this figured out. It's the only other place I've seen this described, so I guess it's a bit unusual.

Here's how this configuration behaves: every terminal window runs the =tmux-main-attach= script below when launching, which creates a new tmux session in the =main= session group. It will be named with an incrementing number, so =main-1= will be the first one created (the root =main= session is created before this point in the tmux configuration file). The tmux status bar /only/ shows unattached windows in the =main= session, so it's not even shown if all tmux windows are currently visible in a terminal.

Issues with this version:
- Have to use full path in gnome keyboard shortcut, no variables
- should always go to a background window on window close (should just call the switch script?)

Need another script to hook into window close to kill the terminal window if there are no background windows to move to? Currently it will go to any other window, including active ones. Maybe can just go in the status script. `pane-exited` hook? Detaching from the session seems to kill the terminal window, which is perfect

#+begin_src bash :tangle ~/bin/tmux-main-attach :shebang #!/bin/bash
create_window=''
if $(tmux has-session -t main); then
    # create_window="new-window $@ ; set-hook pane-exited kill-window ; set-hook pane-exited detach ;"
    if [[ ! -z "$@" ]]; then
        create_window="new-window $@ ; set-hook pane-exited detach ;"
    else
        create_window="new-window ;"
    fi
fi
tmux new-session -t main \; \
     ${create_window} \
     attach \; \
     set-option -t main remain-on-exit on \; \
     # set-option -t main destroy-unattached on \; \
     set-hook -t main session-created 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t main session-window-changed 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t main session-closed 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t main pane-exited 'run-shell ~/bin/tmux-kill-terminal' \; \
     set-hook -t main pane-died 'run-shell ~/bin/tmux-kill-terminal'
#+end_src


#+begin_src bash :tangle ~/bin/tmux-bg-status.sh :shebang #!/bin/bash
declare -a windows
declare -a active_windows

current_session=$(tmux display-message -p '#S')
tmux set-option -t $current_session remain-on-exit on \; \
     set-option -t $current_session destroy-unattached on \; \
     set-hook -t $current_session session-created 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t $current_session session-window-changed 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t $current_session session-closed 'run-shell ~/bin/tmux-bg-status.sh' \; \
     set-hook -t $current_session pane-exited 'run-shell ~/bin/tmux-kill-terminal' \; \
     set-hook -t $current_session pane-died 'run-shell ~/bin/tmux-kill-terminal'

windows=($(tmux list-windows -t main -F '#I'))
unique_active_windows=($(tmux list-windows -a -f '#{&&:#{!=:#{session_name},main},#{window_active}}' -F '#I' | sort -u))

tmux set-window-option -g -t main window-status-format "#{?#{m:* #I *, ${unique_active_windows[*]} },, #F#I#[fg=#bdae93]|#[fg=#f9f5d7]#{?#{==:#{window_name},fish},#{s|$HOME|~|:pane_current_path},#W} }"
if [[ ${#unique_active_windows[@]} -lt ${#windows[@]} ]]; then
    tmux set-option -t main -g status on
else
    tmux set-option -t main -g status off
fi
#+end_src


#+begin_src bash :tangle ~/bin/tmux-kill-terminal :shebang #!/bin/bash
declare -a windows
declare -a active_windows
declare -a inactive_windows

test_log_file='/tmp/tmux-test-log'

# echo "tmux-kill-terminal running" >> $test_log_file

windows=($(tmux list-windows -t main -F '#I'))
active_windows=($(tmux list-windows -a -f '#{&&:#{!=:#{session_name},main},#{window_active}}' -F '#I' | sort -u))
# echo $(echo ${windows[@]} ${active_windows[@]})
inactive_windows=($(echo ${windows[@]} ${active_windows[@]} | tr ' ' '\n' | sort | uniq -u))
# echo ${inactive_windows[@]} >> $test_log_file
# echo "${#inactive_windows[@]}" >> $test_log_file
if [[ "${#inactive_windows[@]}" -eq 0 ]]; then
    # echo "tmux-kill-terminal detaching" >> $test_log_file
    tmux kill-pane
    tmux detach-client
else
    # echo "tmux-kill-terminal killing pane" >> $test_log_file
    tmux kill-pane
fi
#+end_src


#+begin_src bash :tangle ~/bin/tmux-switch-to-unattached-window.sh :shebang #!/bin/bash
declare -a windows
declare -a inactive_windows

debug=''

case "$1" in
    "left") direction='left' ;;
    ,*) direction='right' ;;
esac

current_session=$(tmux display-message -p '#S')
current_window=$(tmux list-windows -F '#{?window_active,#I,}')

windows=($(tmux list-windows -t main -F '#I'))
active_windows=($(tmux list-windows -a -f '#{&&:#{!=:#{session_name},main},#{window_active}}' -F '#I' | sort -u))
inactive_windows=($(echo ${windows[@]} ${active_windows[@]} | tr ' ' '\n' | sort | uniq -u))

if [[ $debug ]]; then
    echo ${windows[@]}
    echo ${active_windows[@]}
    echo ${inactive_windows[@]}
fi

if [[ "$direction" = "right" && "$current_window" -ge "${inactive_windows[-1]}" ]]; then
    tmux select-window -t ${inactive_windows[0]}
    if [[ $debug ]]; then
        echo "0: go to ${inactive_windows[0]}"
    fi
elif [[ "$direction" = "left" && "$current_window" -le "${inactive_windows[0]}" ]]; then
    tmux select-window -t ${inactive_windows[-1]}
    if [[ $debug ]]; then
        echo "1: go to ${inactive_windows[-1]}"
    fi
else
    for window in "${inactive_windows[@]}"; do
        if [[ "$window" -lt "$current_window" ]]; then
            left=$window
        elif [[ "$window" -gt "$current_window" ]]; then
            right=$window
            break
        fi
    done
    if [[ "$direction" = "left" ]]; then
        tmux select-window -t $left
        if [[ $debug ]]; then
            echo "3: go to $left"
        fi
    else
        tmux select-window -t $right
        if [[ $debug ]]; then
            echo "4: go to $right"
        fi
    fi
fi
#+end_src


Not sure this one is used anywhere (was =~/bin/tmux-kill-main-attached=).

#+begin_src bash :shebang #!/bin/bash
# tmux kill-window \; kill-session
tmux kill-window \;
#+end_src

** Wrap Azure CLI docker container

Simple wrapper so I can just run =az= from my normal shell and be using the =az= CLI from the official docker container.

#+begin_src bash :tangle ~/bin/az :shebang #!/usr/bin/env bash
docker run --rm -v $HOME:/root azuresdk/azure-cli-python:latest az $@
#+end_src

And a quick command to update the container with =azup=:

#+begin_src bash :tangle ~/bin/azup :shebang #!/usr/bin/env bash
docker pull azuresdk/azure-cli-python:latest
#+end_src

* Sway
:PROPERTIES:
:header-args: :tangle ~/.config/sway/config :mkdirp yes
:END:

I'm using [[https://github.com/swaywm/sway][Sway]]. I used it before for quite some time, before leaving to use [[https://github.com/paperwm/PaperWM][PaperWM]], a Gnome tiling extension. Unfortunately, Gnome extensions are not the most stable, and don't seem to be a priority for Gnome as a project, so I'm back to Sway for a while to see how I like it now, and if I can get workflows I like. I'm using parts and configuration from the [[https://nwg-piotr.github.io/nwg-shell/][nwg-shell]] project, which is building a nice GTK environment for sway that is reminiscent of Gnome (hopefully in good ways).

Set some of the basic options like font, terminal, etc.

#+begin_src conf
font pango:Noto Sans 13
set $terminal alacritty
floating_modifier Mod1 normal

set $Mod Mod4

for_window [title="^.*"] border pixel 4, title_format "<b> %title (%app_id) </b>"
default_border pixel 4
smart_borders on
#+end_src

I'm a crazy dvorak user, and I like my movement keys on the home row right hand keys, so I set some variables to use later.

#+begin_src conf
set $left h
set $down t
set $up n
set $right s
#+end_src

Terminal launching. I use a custom every-terminal-is-in-one-tmux-session setup. More on that elsewhere in this file. I still have a binding to launch a non-tmux terminal though.

#+begin_src conf
bindsym $Mod+period exec $terminal
bindsym $Mod+Shift+c exec $terminal
#+end_src

App launching. Using wofi currently. The =mywofi= wrapper script has some settings, and will launch in dark or light mode according to the system setting (using the GTK scheme).

#+begin_src conf
bindsym $Mod+e exec --no-startup-id mywofi
#+end_src

Import variables, register with dbus, set up polkit, etc. Needed for nice desktop integration.

#+begin_src conf
exec systemctl --user import-environment DISPLAY WAYLAND_DISPLAY SWAYSOCK SSH_AUTH_SOCK
exec hash dbus-update-activation-environment 2>/dev/null && \
dbus-update-activation-environment --systemd DISPLAY WAYLAND_DISPLAY SWAYSOCK
exec /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
#+end_src

Here we have keybindings that deal with windows.

#+begin_src conf
# kill focused window
bindsym $Mod+k kill

# change focus
bindsym $Mod+$left focus left
bindsym $Mod+$down focus down
bindsym $Mod+$up focus up
bindsym $Mod+$right focus right

# move focused window
bindsym $Mod+Shift+$left move left
bindsym $Mod+Shift+$down move down
bindsym $Mod+Shift+$up move up
bindsym $Mod+Shift+$right move right

# toggle tiling / floating
bindsym $Mod+r floating toggle
#+end_src

And layout-related keybindings.

#+begin_src conf
# split in horizontal orientation
bindsym $Mod+z split h

# split in vertical orientation
bindsym $Mod+v split v, layout stacking

# enter fullscreen mode for the focused container
bindsym $Mod+f exec ~/bin/fullscreen

# change container layout (stacked, tabbed, toggle split)
# bindsym $Mod+j layout stacking
# bindsym $Mod+Shift+j layout tabbed
# bindsym $Mod+x layout toggle split

bindsym $Mod+space layout toggle all

# focus the parent container
bindsym $Mod+p focus parent

# focus the child container
bindsym $Mod+Shift+p focus child
#+end_src

Some special window handling rules.

#+begin_src conf
for_window [window_role="task_dialog"] floating enable
for_window [window_role="bubble"] floating enable
for_window [app_id="zenity"] floating enable

for_window [class="Firefox"] inhibit_idle fullscreen
for_window [class="Chromium"] inhibit_idle fullscreen
for_window [app_id="firefox"] inhibit_idle fullscreen
for_window [app_id="chromium"] inhibit_idle fullscreen
#+end_src

Workspace keybindings.

#+begin_src conf
# switch to workspace
bindsym $Mod+1 workspace number 1
bindsym $Mod+2 workspace number 2
bindsym $Mod+3 workspace number 3
bindsym $Mod+4 workspace number 4
bindsym $Mod+5 workspace number 5
bindsym $Mod+6 workspace number 6
bindsym $Mod+7 workspace number 7
bindsym $Mod+8 workspace number 8
bindsym $Mod+9 workspace number 9

bindsym $Mod+Tab workspace back_and_forth
bindsym $Mod+Mod1+$left workspace prev
bindsym $Mod+Mod1+$right workspace next
bindsym $Mod+Mod1+Shift+$left move workspace to output left
bindsym $Mod+Mod1+Shift+$right move workspace to output right
bindsym --no-repeat $Mod+g workspace prev
bindsym --no-repeat $Mod+l workspace next
workspace_auto_back_and_forth no

# move focused container to workspace and go with it
bindsym $Mod+Shift+1 move container to workspace number 1; workspace number 1
bindsym $Mod+Shift+2 move container to workspace number 2; workspace number 2
bindsym $Mod+Shift+3 move container to workspace number 3; workspace number 3
bindsym $Mod+Shift+4 move container to workspace number 4; workspace number 4
bindsym $Mod+Shift+5 move container to workspace number 5; workspace number 5
bindsym $Mod+Shift+6 move container to workspace number 6; workspace number 6
bindsym $Mod+Shift+7 move container to workspace number 7; workspace number 7
bindsym $Mod+Shift+8 move container to workspace number 8; workspace number 8
bindsym $Mod+Shift+9 move container to workspace number 9; workspace number 9

# send focused container to workspace
bindsym $Mod+Control+1 move container to workspace number 1
bindsym $Mod+Control+2 move container to workspace number 2
bindsym $Mod+Control+3 move container to workspace number 3
bindsym $Mod+Control+4 move container to workspace number 4
bindsym $Mod+Control+5 move container to workspace number 5
bindsym $Mod+Control+6 move container to workspace number 6
bindsym $Mod+Control+7 move container to workspace number 7
bindsym $Mod+Control+8 move container to workspace number 8
bindsym $Mod+Control+9 move container to workspace number 9
#+end_src

Window border handling.

#+begin_src conf
bindsym $Mod+b border toggle
# default_border normal
default_floating_border normal
default_border pixel 4
smart_borders on
#+end_src

Output configuration for work laptop.

#+begin_src conf
# set $work_monitor_left "Ancor Communications Inc ASUS PB278 E1LMTF061086"
# set $work_monitor_right "Ancor Communications Inc ASUS PB278 E3LMTF122568"

# set $home_monitor "Goldstar Company Ltd LG Ultra HD 0x0000EFE8"

# workspace 1 output $work_monitor_right
# workspace 2 output $work_monitor_right
# workspace 3 output $work_monitor_right
# workspace 4 output $work_monitor_left
# workspace 5 output $work_monitor_left
# workspace 7 output $work_monitor_left
# workspace 8 output $work_monitor_left

# output eDP-1 {
    # scale 1.0
    # disable
    # pos 4000,1000
# }

# output $work_monitor_left {
    # transform 270
    # pos 0,0
# }

# output $work_monitor_right {
    # pos 1440,220
# }
#+end_src

Set the background colour on all outputs.

#+begin_src conf
output * {
    background #222222 solid_color
}
#+end_src

A bit of laptop display management. I use laptops docked a lot of the time, and usually don't use the internal display when docked. So I want that display disabled when the laptop has external active displays and then is closed, and I want it enabled when opening the laptop.

#+begin_src conf
# bindswitch --locked lid:on exec ~/bin/dock-outputs.py
set $laptop eDP-1
bindswitch lid:on output $laptop disable
bindswitch lid:off output $laptop enable
#+end_src

Global input device settings. I dvorak.

#+begin_src conf
input type:keyboard {
    xkb_layout us
    xkb_variant dvorak

    repeat_delay 275
    repeat_rate 60
}
#+end_src

[[https://shop.keyboard.io/][Keyboard.io]] pointer settings.

#+begin_src conf
input "4617:8961:Keyboardio_Model_01_Mouse" {
    pointer_accel 0.1
    accel_profile adaptive
    natural_scroll enabled
    scroll_factor 1.5
}
#+end_src

Thinkpad pointing device settings, covering older and newer devices.

#+begin_src conf
input "2:10:TPPS/2_IBM_TrackPoint" {
    pointer_accel 0.5
    natural_scroll enabled
    scroll_factor 1.5
    scroll_method on_button_down
    scroll_button button2
}

input "1267:32:Elan_TrackPoint" {
    pointer_accel 0.5
    natural_scroll enabled
    scroll_factor 1.5
    scroll_method on_button_down
    scroll_button button2
}

input "2:7:SynPS/2_Synaptics_TouchPad" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 1.7
    tap enabled
    tap_button_map lrm
    dwt enabled
    drag enabled
    click_method clickfinger
    scroll_method two_finger
}

input "1267:32:Elan_Touchpad" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 1.7
    tap enabled
    tap_button_map lrm
    dwt enabled
    drag enabled
    click_method clickfinger
    scroll_method two_finger
}
#+end_src

Settings for the logitech mice I have.

#+begin_src conf
input "1133:16489:Logitech_MX_Master_2S" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 3.0
}

input "1133:16514:Logitech_MX_Master_3" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 3.0
}

input "1133:16478:Logitech_M720_Triathlon" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 3.0
}

input "1133:4133:Logitech_M510" {
    pointer_accel 0.8
    natural_scroll enabled
    scroll_factor 3.0
}
#+end_src

Audio keybindings. Using [[https://github.com/francma/wob][wob]] for simple visual feedback when changing volume.

#+begin_src conf
bindsym XF86AudioPlay exec playerctl play-pause
bindsym XF86AudioNext exec playerctl next
bindsym XF86AudioPrev exec playerctl previous
bindsym XF86AudioStop exec playerctl stop
bindsym XF86AudioMute exec pamixer -t
bindsym XF86AudioRaiseVolume exec pamixer -i 5 && pamixer --get-volume > $XDG_RUNTIME_DIR/wob.sock
bindsym XF86AudioLowerVolume exec pamixer -d 5 && pamixer --get-volume > $XDG_RUNTIME_DIR/wob.sock
#+end_src

Handle laptop display brightness.

#+begin_src conf
bindsym XF86MonBrightnessUp exec --no-startup-id ~/bin/brightness up
bindsym XF86MonBrightnessDown exec --no-startup-id ~/bin/brightness down
#+end_src

"System" keybindings. Config reloads, exiting, locking, that kind of thing. Most of my WM keybindings are chains of keys, so here I hit one globally bound key (Mod4+w) which opens up the keys that are bound within that [[https://i3wm.org/docs/userguide.html#binding_modes][mode]].

#+begin_src conf
mode "system" {
        # reload the configuration file
        bindsym r reload, mode "default"

        bindsym d exec ~/.local/bin/dark-toggle, mode "default"

        bindsym b exec "waybar", mode "default"
        bindsym Shift+b exec "killall waybar && waybar", mode "default"

        bindsym n exec --no-startup-id makoctl dismiss, mode "default"
        bindsym Shift+n exec --no-startup-id makoctl dismiss --all, mode "default"

        bindsym Shift+q exit, mode "default"

        bindsym M output eDP-1 enable, mode "default"
        bindsym D output eDP-1 disable, mode "default"

        bindsym s exec --no-startup-id ~/bin/wl-screenshot, mode "default"

        # Lock
        bindsym l exec --no-startup-id swaylock -c 000000, mode "default"
        # Suspend
        bindsym Shift+s exec --no-startup-id \
            swaylock -c 000000 && systemctl suspend, mode "default"

        bindsym Escape mode "default"
}
bindsym $Mod+w mode "system"
#+end_src

Window resizing keybindings.

#+begin_src conf
mode "resize" {
        # These bindings trigger as soon as you enter the resize mode

        # Pressing left will shrink the window’s width.
        # Pressing right will grow the window’s width.
        # Pressing up will shrink the window’s height.
        # Pressing down will grow the window’s height.
        bindsym $left       resize shrink width 10 px or 3 ppt
        bindsym $down       resize grow height 10 px or 3 ppt
        bindsym $up         resize shrink height 10 px or 3 ppt
        bindsym $right      resize grow width 10 px or 3 ppt

        # back to normal: Enter or Escape
        bindsym Return mode "default"
        bindsym Escape mode "default"
}
# bindsym $Mod+l mode "resize"
#+end_src

App-related keybindings.

#+begin_src conf
mode "apps" {
        bindsym s [class="Slack"] focus, mode "default"
        bindsym e [class="Thunderbird"] focus, mode "default"
        bindsym m [class=".*Google Play Music.*"] focus, mode "default"
        bindsym t [title="^Signal"] focus, mode "default"
        bindsym j [title=" - JIRA$"] focus, mode "default"
        bindsym c [class="Emacs"] focus, mode "default"
        bindsym f [class="Firefox"] focus, mode "default"

        bindsym u [urgent=latest] focus, mode "default"

        bindsym Escape mode "default"
}
# bindsym $Mod+g mode "apps"
#+end_src

#+begin_src conf
force_display_urgency_hint 1500 ms
#+end_src

Colour settings. [[https://i3wm.org/docs/userguide.html#_changing_colors][Like i3]].

#+begin_src conf
# client.<class> <border> <background> <text> <indicator> <child_border>
client.focused #fe8019 #fe8019 #282828 #fe8019 #fe8019
# client.focused #ebdbb2 #ebdbb2 #282828 #ebdbb2 #ebdbb2
#client.focused_inactive #458588 #458588 #282828
client.focused_inactive #7c6f64 #7c6f64 #282828 #7c6f64 #7c6f64
client.unfocused #383838 #282828 #bdae93 #282828 #383838
client.urgent #fabd2f #fabd2f #282828 #fabd2f #fabd2f
#+end_src

Startup commands. I also start a terminal on login, which is really just a leftover from testing and breaking my setup and finding it handy to have a terminal open when little else works.

#+begin_src conf
exec --no-startup-id redshift -l $(curl -s ipinfo.io | jq -j .loc | tr ',' ':') -m wayland
exec --no-startup-id ~/bin/focus-opacity.py
exec --no-startup-id waybar
exec --no-startup-id mako
exec --no-startup-id \
    swayidle timeout 600 'swaymsg "output * dpms off"' \
    resume 'swaymsg "output * dpms on"' \
    timeout 900 'swaylock -c 000000' \
    before-sleep 'swaylock -c 000000'

exec $terminal
#+end_src

* SSH agent for sway
#+begin_src conf :tangle ~/.config/systemd/user/ssh-agent.service
[Unit]
Description=SSH key agent

[Service]
Type=simple
Environment=SSH_AUTH_SOCK=%t/ssh-agent.socket
# DISPLAY required for ssh-askpass to work
Environment=DISPLAY=:0
ExecStart=/usr/bin/ssh-agent -D -a $SSH_AUTH_SOCK

[Install]
WantedBy=default.target
#+end_src

* Waybar
:PROPERTIES:
:header-args: :tangle "litwaybar.conf" :mkdirp yes
:END:

#+begin_src conf :tangle no :noweb-ref waybar-sway
"sway/workspaces": {
     "disable-scroll": false,
     "all-outputs": false,
     "format": "{icon}{name}",
     "format-icons": {
//         "1": "",
//         "2": "",
//         "3": "",
//         "4": "",
//         "5": "",
        "urgent": " ",
        "focused": "",
//         "default": ""
        "default": ""
    }
},
"sway/mode": {
    "format": " {}"
},
"sway/window": {
    "all-outputs": true,
    "max-length": 120
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-clock
"clock": {
    "format": "{:%a %b %e  %H:%M}",
    "format-alt": "{:%Y-%m-%d}"
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-tray
"tray": {
    // "icon-size": 21,
    "spacing": 10
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-cpumem
"cpu": {
    "states": {
        "warning": 70,
        "critical": 95
    },
    "format": " {}%",
    "format-warning": " {}%",
    "format-critical": " {}%"
},
"memory": {
    "states": {
        //"normal": 30,
        "warning": 40,
        "critical": 85
    },
    "format": " {}%",
    //"format-normal": "normal",
    "format-warning": " w{}%",
    "format-critical": " c{}%"
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-battery
"battery": {
    "states": {
        "full": 100,
        "good": 90,
        "normal": 89,
        "warning": 20,
        "critical": 10
    },
    "format-normal": "{icon} {capacity}%",
    "format-good": "",
    "format-full": "",
    "format-charging-normal": " {capacity}%",
    "format-charging-good": "",
    "format-charging-full": "",
    "format-icons": ["", "", "", "", ""]
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-pulseaudio
"pulseaudio": {
    "format": "{icon} {volume}%",
    "format-bluetooth": "{icon} {volume}%",
    "format-muted": "",
    "format-icons": {
        "headphones": "",
        "handsfree": "",
        "headset": "",
        "phone": "",
        "portable": "",
        "car": "",
        "default": ["", ""]
    },
    "on-click": "pavucontrol"
}
#+end_src

#+begin_src conf :tangle no :noweb-ref waybar-network
"network#wireless": {
    "interface": "wlp*",
    "format-wifi": " {essid} ({signalStrength}%)",
    "format-disconnected": "⚠ Disconnected",
    "on-click": "nm-connection-editor"
},
"network#wired": {
    "interface": "enp*",
    "format-ethernet": " {ipaddr}",
    "format-linked": "",
    "format-disconnected": "",
    "on-click": "nm-connection-editor"
},
    "idle_inhibitor": {
        "format": "{icon}",
        "format-icons": {
            "activated": "",
            "deactivated": ""
        }
    },
    "temperature": {
        // "thermal-zone": 2,
        // "hwmon-path": "/sys/class/hwmon/hwmon2/temp1_input",
        "critical-threshold": 60,
        "format-critical": "{temperatureC}°C {icon}",
        "format": ""
        //"format-icons": ["", "", ""]
    },
    "backlight": {
        // "device": "acpi_video1",
        "format": "{icon} {percent}%",
        "format-icons": ["", ""]
    }
#+end_src

#+begin_src conf :tangle ~/.config/waybar/config :noweb yes
[{
    "layer": "top",
    "height": 30,
    "modules-left": [
        "sway/workspaces",
        "sway/window"
    ],
    "modules-center": [
        "sway/mode"
    ],
    "modules-right": [
        "cpu",
        "memory",
        "battery",
        "temperature",
        "network#wired",
        "network#wireless",
        "idle_inhibitor",
        "pulseaudio",
        "clock",
        "tray"
    ],
    <<waybar-sway>>,
    <<waybar-clock>>,
    <<waybar-tray>>,
    <<waybar-pulseaudio>>,
    <<waybar-cpumem>>,
    <<waybar-battery>>,
    <<waybar-network>>
},
{
    "output": ["eDP-2"],
    "layer": "top",
    "height": 26,
    "modules-left": [
        "sway/workspaces",
        "sway/mode",
        "sway/window"
    ],
    "modules-center": [
        "sway/mode"
    ],
    "modules-right": [
        "cpu",
        "memory",
        "battery",
        "network#wireless",
        "backlight",
        "pulseaudio",
        "clock",
        "tray"
    ],
    <<waybar-sway>>,
    <<waybar-clock>>,
    <<waybar-tray>>,
    <<waybar-pulseaudio>>,
    <<waybar-cpumem>>,
    <<waybar-battery>>,
    <<waybar-network>>
}]
#+end_src

#+begin_src css :tangle ~/.config/waybar/style.css
,* {
    border: none;
    border-radius: 0;
    font-family: Noto Sans, Roboto, Helvetica, Arial, sans-serif;
    font-size: 18px;
    min-height: 0;
    color: #ebdbb2;
}

window#waybar {
    /* background: rgba(43, 48, 59, 0.5); */
    background: #282828;
    /* border-bottom: 3px solid rgba(100, 114, 125, 0.5); */
/*     color: #ebdbb2; */
}

#workspaces button {
    padding: 0 4px;
    /* background: transparent; */
    background-color: #3c3836;
    /* color: white; */
    /* border-bottom: 3px solid transparent; */
}

#workspaces button.visible {
    background-color: #928374;
    color: #282828;
}

#workspaces button.visible label {
    color: #282828;
    font-weight: bold;
}

#workspaces button.focused {
    background-color: #ebdbb2;
    color: #282828;
}

#workspaces button.focused label {
    color: #282828;
    font-weight: bold;
}

#workspaces button.urgent {
    background-color: #fabd2f;
}

#workspaces button.urgent label {
    color: #282828;
}

#window {
    padding: 0 10px;
}

#mode {
    background: #b8bb26;
    color: #282828;
    font-weight: bold;
}

#clock, #battery, #battery.charging, #cpu, #memory, #network, #pulseaudio, #custom-spotify, #tray, #mode, #idle_inhibitor, #backlight, #temperature-critical {
    padding: 0 10px;
    margin: 0 5px;
}

#temperature, #memory.normal, #cpu.normal, #battery.normal, #battery.full:not(.charging), #battery.good:not(.charging) {
    padding: 0;
    margin: 0;
}

#clock {
    background-color: #3c3836;
}

@keyframes blink {
    to {
        background-color: #ffffff;
        color: black;
    }
}

#battery.critical:not(.charging), #battery.warning:not(.charging) {
    background: #f53c3c;
    color: white;
    animation-name: blink;
    animation-duration: 0.5s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}

#battery.warning:not(.charging) {
    background: #f1c40f;
    color: black;
}

#cpu {
    /* background: #2ecc71; */
    /* color: #000000; */
}

#memory {
    /* background: #9b59b6; */
}

#network.linked {
    background: #f1c40f;
}

#network.disconnected {
    background: #f53c3c;
}

#network {
    /* background: #2980b9; */
}

#pulseaudio {
    /* background: #f1c40f; */
    /* color: black; */
}

#pulseaudio.muted {
    /* background: #90b1b1; */
    color: #f1c40f;
    /* color: #2a5c45; */
    border-bottom: 2px solid #f1c40f;
}

#custom-spotify {
    background: #66cc99;
    color: #2a5c45;
}

#tray {
    /* background-color: #2980b9; */
}
#+end_src

* Terminal

** fish
*** Main config
:PROPERTIES:
:header-args: :tangle ~/.config/fish/config.fish :mkdirp yes :noweb yes
:END:

#+begin_src fish
set --universal fish_greeting
#+end_src

#+begin_src fish
set -g __fish_git_prompt_show_status 1
set -g __fish_git_prompt_show_informative_status 1
set -g __fish_git_prompt_hide_untrackedfiles 1

set -g __fish_git_prompt_color_branch green --bold
set -g __fish_git_prompt_showupstream "informative"
set -g __fish_git_prompt_char_upstream_ahead "↑"
set -g __fish_git_prompt_char_upstream_behind "↓"
set -g __fish_git_prompt_char_upstream_prefix ""

set -g __fish_git_prompt_char_stagedstate " ● "
set -g __fish_git_prompt_char_dirtystate " ✚ "
set -g __fish_git_prompt_char_untrackedfiles "…"
set -g __fish_git_prompt_char_conflictedstate " ✖ "
set -g __fish_git_prompt_char_cleanstate " ✔ "

set -g __fish_git_prompt_color_dirtystate yellow
set -g __fish_git_prompt_color_stagedstate blue
set -g __fish_git_prompt_color_invalidstate red
set -g __fish_git_prompt_color_untrackedfiles $fish_color_normal
set -g __fish_git_prompt_color_cleanstate green --bold
#+end_src

#+begin_src fish
if not contains $HOME/bin $fish_user_paths
    set -U fish_user_paths $fish_user_paths $HOME/bin
end
#+end_src

#+begin_src fish
if not contains $HOME/.local/bin $fish_user_paths
    set -U fish_user_paths $fish_user_paths $HOME/.local/bin
end
#+end_src

#+begin_src fish
<<fish_env>>
#+end_src

I use fish in vterm buffers in Emacs a lot, and there's no point to vi bindings there, so don't enable them if running in Emacs. Also, load fish settings included with the vterm package:

#+begin_src fish
if set -q INSIDE_EMACS
    fish_default_key_bindings 2>/dev/null
else
    fish_vi_key_bindings 2>/dev/null
end
if test "$INSIDE_EMACS" = "vterm" -a -n "$EMACS_VTERM_PATH" -a -f {$EMACS_VTERM_PATH}/etc/emacs-vterm.fish
    source {$EMACS_VTERM_PATH}/etc/emacs-vterm.fish
end
#+end_src

#+begin_src fish
eval (direnv hook fish)
#+end_src

*** Aliases
#+begin_src fish :tangle ~/.config/fish/functions/ec.fish
function ec --description 'emacsclient'
    command emacsclient --create-frame --alternate-editor="emacs" $argv
end
#+end_src

=fzf= can be used to do some really handy stuff. Here are aliases from [[https://wiki.archlinux.org/title/Fzf#Arch_specific_fzf_uses][the Arch wiki]] that do useful things with pacman data. More in [[https://www.reddit.com/r/archlinux/comments/ndduvm/recommendation_start_using_pacman_yay_and_paru/][this reddit thread]].

Search packages, with info in a preview window, and install selected packages.

#+begin_src fish :tangle ~/.config/fish/functions/pacman-fuzzy-install.fish
function pacman-fuzzy-install
    command pacman -Slq | fzf --multi --preview 'pacman -Si {1}' | xargs -ro sudo pacman -S
end
#+end_src

Search installed packages with info in a preview window, and remove selected packages.

#+begin_src fish :tangle ~/.config/fish/functions/pacman-fuzzy-remove.fish
function pacman-fuzzy-remove
    command pacman -Qq | fzf --multi --preview 'pacman -Qi {1}' | xargs -ro sudo pacman -Rns
end
#+end_src

This one adds a listing of files in the package to the preview window. =pacman -Fy= has to be run first to create the database it searches.

#+begin_src fish :tangle ~/.config/fish/functions/pacman-fuzzy-files.fish
function pacman-fuzzy-files
    command pacman -Slq | fzf --multi --preview 'cat (pacman -Si {1} | psub) (pacman -Fl {1} | awk "{print \$2}" | psub)' | xargs -ro sudo pacman -S
end
#+end_src


#+begin_src fish :tangle ~/.config/fish/functions/magit.fish
function magit ()
    set -l git_root (git rev-parse --show-toplevel)
    command emacsclient -c -e '(let ((magit-display-buffer-function \'magit-display-buffer-fullframe-status-v1)) (magit-status "'(echo -n $git_root)'"))'
end
#+end_src

#+begin_src fish
function vterm_prompt_end;
    vterm_printf '51;A'(whoami)'@'(hostname)':'(pwd)
end
functions --copy fish_prompt vterm_old_fish_prompt
function fish_prompt --description 'Write out the prompt; do not replace this. Instead, put this at end of your file.'
    # Remove the trailing newline from the original prompt. This is done
    # using the string builtin from fish, but to make sure any escape codes
    # are correctly interpreted, use %b for printf.
    printf "%b" (string join "\n" (vterm_old_fish_prompt))
    vterm_prompt_end
end
#+end_src


#+begin_src fish :tangle ~/.config/fish/functions/k.fish
function k --wraps kubectl --description 'alias k=kubectl' ()
    kubectl $argv
end
#+end_src

#+begin_src fish :tangle ~/.config/fish/functions/bwu.fish
function bwu
    set -gx BW_SESSION (bw unlock --raw $argv[1])
end
#+end_src

*** VI mode
:PROPERTIES:
:header-args: :tangle ~/.config/fish/functions/fish_vi_key_bindings.fish :mkdirp yes
:END:

#+begin_src fish
function fish_vi_key_bindings --description 'vi-like key bindings for fish'
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    # Erase all bindings if not explicitly requested otherwise to
    # allow for hybrid bindings.
    # This needs to be checked here because if we are called again
    # via the variable handler the argument will be gone.
    set -l rebind true
    if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    end

    # Allow just calling this function to correctly set the bindings.
    # Because it's a rather discoverable name, users will execute it
    # and without this would then have subtly broken bindings.
    if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    end

    # The default escape timeout is 300ms. But for users of Vi bindings that can be slightly
    # annoying when trying to switch to Vi "normal" mode. So set a shorter timeout in this case
    # unless the user has explicitly set the delay.
    set -q fish_escape_delay_ms
    or set -g fish_escape_delay_ms 100

    set -l init_mode insert
    # These are only the special vi-style keys
    # not end/home, we share those.
    set -l eol_keys \$ g\$
    set -l bol_keys \^ 0 g\^

    if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    end

    # Inherit shared key bindings.
    # Do this first so vi-bindings win over default.
    for mode in insert default visual
        __fish_shared_key_bindings -M $mode
    end

    bind -s --preset -M insert \r execute
    bind -s --preset -M insert \n execute

    bind -s --preset -M insert "" self-insert

    # Add way to kill current command line while in insert mode.
    bind -s --preset -M insert \cc __fish_cancel_commandline
    # Add a way to switch from insert to normal (command) mode.
    # Note if we are paging, we want to stay in insert mode
    # See #2871
    bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char force-repaint; end"

    # Default (command) mode
    bind -s --preset :q exit
    bind -s --preset -m insert \cc __fish_cancel_commandline
    bind -s --preset -M default h backward-char
    bind -s --preset -M default s forward-char
    bind -s --preset -m insert \n execute
    bind -s --preset -m insert \r execute
    bind -s --preset -m insert i force-repaint
    bind -s --preset -m insert I beginning-of-line force-repaint
    bind -s --preset -m insert a forward-char force-repaint
    bind -s --preset -m insert A end-of-line force-repaint
    bind -s --preset -m visual v begin-selection force-repaint

    #bind -s --preset -m insert o "commandline -a \n" down-line force-repaint
    #bind -s --preset -m insert O beginning-of-line "commandline -i \n" up-line force-repaint # doesn't work

    bind -s --preset gg beginning-of-buffer
    bind -s --preset G end-of-buffer

    for key in $eol_keys
        bind -s --preset $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset $key beginning-of-line
    end

    bind -s --preset u history-search-backward
    bind -s --preset \cr history-search-forward

    bind -s --preset [ history-token-search-backward
    bind -s --preset ] history-token-search-forward

    bind -s --preset n up-or-search
    bind -s --preset t down-or-search
    bind -s --preset b backward-word
    bind -s --preset B backward-bigword
    bind -s --preset ge backward-word
    bind -s --preset gE backward-bigword
    bind -s --preset w forward-word forward-char
    bind -s --preset W forward-bigword forward-char
    bind -s --preset e forward-char forward-word backward-char
    bind -s --preset E forward-bigword backward-char

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    # Vi/Vim doesn't support these keys in insert mode but that seems silly so we do so anyway.
    bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
    bind -s --preset -M default -k home beginning-of-line 2>/dev/null
    bind -s --preset -M insert -k end end-of-line 2>/dev/null
    bind -s --preset -M default -k end end-of-line 2>/dev/null

    # Vi moves the cursor back if, after deleting, it is at EOL.
    # To emulate that, move forward, then backward, which will be a NOP
    # if there is something to move forward to.
    bind -s --preset -M default x delete-char forward-char backward-char
    bind -s --preset -M default X backward-delete-char
    bind -s --preset -M insert -k dc delete-char forward-char backward-char
    bind -s --preset -M default -k dc delete-char forward-char backward-char

    # Backspace deletes a char in insert mode, but not in normal/default mode.
    bind -s --preset -M insert -k backspace backward-delete-char
    bind -s --preset -M default -k backspace backward-char
    bind -s --preset -M insert \ch backward-delete-char
    bind -s --preset -M default \ch backward-char
    bind -s --preset -M insert \x7f backward-delete-char
    bind -s --preset -M default \x7f backward-char
    bind -s --preset -M insert \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete
    bind -s --preset -M default \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind -s --preset dd kill-whole-line
    bind -s --preset D kill-line
    bind -s --preset d\$ kill-line
    bind -s --preset d\^ backward-kill-line
    bind -s --preset dw kill-word
    bind -s --preset dW kill-bigword
    bind -s --preset diw forward-char forward-char backward-word kill-word
    bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset daw forward-char forward-char backward-word kill-word
    bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset de kill-word
    bind -s --preset dE kill-bigword
    bind -s --preset db backward-kill-word
    bind -s --preset dB backward-kill-bigword
    bind -s --preset dge backward-kill-word
    bind -s --preset dgE backward-kill-bigword
    bind -s --preset df begin-selection forward-jump kill-selection end-selection
    bind -s --preset dk begin-selection forward-jump backward-char kill-selection end-selection
    bind -s --preset dF begin-selection backward-jump kill-selection end-selection
    bind -s --preset dK begin-selection backward-jump forward-char kill-selection end-selection

    # bind -s --preset -m insert s delete-char force-repaint
    # bind -s --preset -m insert S kill-whole-line force-repaint
    bind -s --preset -m insert cc kill-whole-line force-repaint
    bind -s --preset -m insert C kill-line force-repaint
    bind -s --preset -m insert c\$ kill-line force-repaint
    bind -s --preset -m insert c\^ backward-kill-line force-repaint
    bind -s --preset -m insert cw kill-word force-repaint
    bind -s --preset -m insert cW kill-bigword force-repaint
    bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word force-repaint
    bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword force-repaint
    bind -s --preset -m insert caw forward-char forward-char backward-word kill-word force-repaint
    bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword force-repaint
    bind -s --preset -m insert ce kill-word force-repaint
    bind -s --preset -m insert cE kill-bigword force-repaint
    bind -s --preset -m insert cb backward-kill-word force-repaint
    bind -s --preset -m insert cB backward-kill-bigword force-repaint
    bind -s --preset -m insert cge backward-kill-word force-repaint
    bind -s --preset -m insert cgE backward-kill-bigword force-repaint

    bind -s --preset '~' capitalize-word
    bind -s --preset gu downcase-word
    bind -s --preset gU upcase-word

    # bind -s --preset J end-of-line delete-char
    # bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'

    bind -s --preset yy kill-whole-line yank
    bind -s --preset Y kill-whole-line yank
    bind -s --preset y\$ kill-line yank
    bind -s --preset y\^ backward-kill-line yank
    bind -s --preset yw kill-word yank
    bind -s --preset yW kill-bigword yank
    bind -s --preset yiw forward-char forward-char backward-word kill-word yank
    bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset yaw forward-char forward-char backward-word kill-word yank
    bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset ye kill-word yank
    bind -s --preset yE kill-bigword yank
    bind -s --preset yb backward-kill-word yank
    bind -s --preset yB backward-kill-bigword yank
    bind -s --preset yge backward-kill-word yank
    bind -s --preset ygE backward-kill-bigword yank

    bind -s --preset f forward-jump
    bind -s --preset F backward-jump
    bind -s --preset k forward-jump-till
    bind -s --preset K backward-jump-till
    bind -s --preset ';' repeat-jump
    bind -s --preset , repeat-jump-reverse

    # in emacs yank means paste
    bind -s --preset p yank
    bind -s --preset P backward-char yank
    bind -s --preset gp yank-pop

    bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
    bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"

    #
    # Lowercase r, enters replace_one mode
    #
    bind -s --preset -m replace_one r force-repaint
    bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char force-repaint
    bind -s --preset -M replace_one -m default \e cancel force-repaint

    #
    # visual mode
    #
    bind -s --preset -M visual h backward-char
    bind -s --preset -M visual s forward-char

    bind -s --preset -M visual n up-line
    bind -s --preset -M visual t down-line

    bind -s --preset -M visual b backward-word
    bind -s --preset -M visual B backward-bigword
    bind -s --preset -M visual ge backward-word
    bind -s --preset -M visual gE backward-bigword
    bind -s --preset -M visual w forward-word
    bind -s --preset -M visual W forward-bigword
    bind -s --preset -M visual e forward-word
    bind -s --preset -M visual E forward-bigword
    bind -s --preset -M visual o swap-selection-start-stop force-repaint

    bind -s --preset -M visual f forward-jump
    bind -s --preset -M visual k forward-jump-till
    bind -s --preset -M visual F backward-jump
    bind -s --preset -M visual K backward-jump-till

    for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    end

    bind -s --preset -M visual -m insert c kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default d kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default x kill-selection end-selection force-repaint
    bind -s --preset -M visual -m default X kill-whole-line end-selection force-repaint
    bind -s --preset -M visual -m default y kill-selection yank end-selection force-repaint
    bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection force-repaint"

    bind -s --preset -M visual -m default \cc end-selection force-repaint
    bind -s --preset -M visual -m default \e end-selection force-repaint

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also, remove
    # the commenting chars so the command can be further edited then executed.
    bind -s --preset -M default \# __fish_toggle_comment_commandline
    bind -s --preset -M visual \# __fish_toggle_comment_commandline

    # Set the cursor shape
    # After executing once, this will have defined functions listening for the variable.
    # Therefore it needs to be before setting fish_bind_mode.
    fish_vi_cursor

    set fish_bind_mode $init_mode

end
#+end_src

*** Prompt
:PROPERTIES:
:header-args: :tangle ~/.config/fish/functions/fish_prompt.fish :mkdirp yes
:END:

#+begin_src fish
function fish_prompt --description 'Write out the prompt'
	set -l last_status $status
    set -l normal (set_color normal)

    # Hack; fish_config only copies the fish_prompt function (see #736)
    if not set -q -g __fish_classic_git_functions_defined
        set -g __fish_classic_git_functions_defined

        function __fish_repaint_user --on-variable fish_color_user --description "Event handler, repaint when fish_color_user changes"
            if status --is-interactive
                commandline -f repaint 2>/dev/null
            end
        end

        function __fish_repaint_host --on-variable fish_color_host --description "Event handler, repaint when fish_color_host changes"
            if status --is-interactive
                commandline -f repaint 2>/dev/null
            end
        end

        function __fish_repaint_status --on-variable fish_color_status --description "Event handler; repaint when fish_color_status changes"
            if status --is-interactive
                commandline -f repaint 2>/dev/null
            end
        end

        function __fish_repaint_bind_mode --on-variable fish_key_bindings --description "Event handler; repaint when fish_key_bindings changes"
            if status --is-interactive
                commandline -f repaint 2>/dev/null
            end
        end

        # initialize our new variables
        if not set -q __fish_classic_git_prompt_initialized
            set -qU fish_color_user
            or set -U fish_color_user -o green
            set -qU fish_color_host
            or set -U fish_color_host -o cyan
            set -qU fish_color_status
            or set -U fish_color_status red
            set -U __fish_classic_git_prompt_initialized
        end
    end

    set -l color_cwd
    set -l prefix
    set -l suffix
    switch "$USER"
        case root toor
            if set -q fish_color_cwd_root
                set color_cwd $fish_color_cwd_root
            else
                set color_cwd $fish_color_cwd
            end
            set suffix '#'
        case '*'
            set color_cwd $fish_color_cwd
            set suffix '  '
    end

    set -l prompt_status
    if test $last_status -ne 0
        set prompt_status ' ' (set_color $fish_color_status) "[$last_status]" "$normal"
    end

    if test -x kubectl
        set k8senv ' ⎈' (kubectl config current-context)
    end

    echo -n -s (set_color $fish_color_user) "$USER" $normal @ (set_color $fish_color_host) (prompt_hostname) $normal ' ' (set_color $color_cwd) (prompt_pwd) $normal (__fish_vcs_prompt) $normal $k8senv $prompt_status $suffix " "
end
#+end_src

#+begin_src fish
function fish_mode_prompt --description "Display my mode indicator for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = fish_vi_key_bindings
        or test "$fish_key_bindings" = fish_hybrid_key_bindings
        switch $fish_bind_mode
            case default
                set_color --bold ffffff -b 228b22
                echo ' N '
            case insert
                set_color --bold 000000 -b ffd700
                echo ' I '
            case replace_one
                set_color --bold ffffff -b 8b0000
                echo ' R '
            case replace
                set_color --bold ffffff -b 8b0000
                echo ' R '
            case visual
                set_color --bold 000000 -b fe8019
                echo ' V '
        end
        set_color normal
        echo -n ' '
    end
end
#+end_src

*** Fisher
:PROPERTIES:
:header-args: :tangle ~/.config/fish/functions/fisher.fish :mkdirp yes
:END:

#+begin_src fish
set -g fisher_version 3.2.10

function fisher -a cmd -d "fish package manager"
    set -q XDG_CACHE_HOME; or set XDG_CACHE_HOME ~/.cache
    set -q XDG_CONFIG_HOME; or set XDG_CONFIG_HOME ~/.config

    set -g fish_config $XDG_CONFIG_HOME/fish
    set -g fisher_cache $XDG_CACHE_HOME/fisher
    set -g fisher_config $XDG_CONFIG_HOME/fisher

    set -q fisher_path; or set -g fisher_path $fish_config
    set -g fishfile $fish_config/fishfile

    for path in {$fish_config,$fisher_path}/{functions,completions,conf.d} $fisher_cache
        if test ! -d $path
            command mkdir -p $path
        end
    end

    if test ! -e $fisher_path/completions/fisher.fish
        echo "fisher complete" >$fisher_path/completions/fisher.fish
        _fisher_complete
    end

    if test -e $fisher_path/conf.d/fisher.fish
        switch "$version"
            case \*-\*
                command rm -f $fisher_path/conf.d/fisher.fish
            case 2\*
            case \*
                command rm -f $fisher_path/conf.d/fisher.fish
        end
    else
        switch "$version"
            case \*-\*
            case 2\*
                echo "fisher copy-user-key-bindings" >$fisher_path/conf.d/fisher.fish
        end
    end

    # 2019-10-22: temp code, migrates fishfile from old path back to $fish_config
    if test -e "$fisher_path/fishfile"; and test ! -e "$fishfile"
        command mv -f "$fisher_path/fishfile" "$fishfile"
    end

    switch "$cmd"
        case {,self-}complete
            _fisher_complete
        case copy-user-key-bindings
            _fisher_copy_user_key_bindings
        case ls
            set -e argv[1]
            if test -s "$fishfile"
                set -l file (_fisher_fmt <$fishfile | _fisher_parse -R | command sed "s|@.*||")
                _fisher_ls | _fisher_fmt | command awk -v FILE="$file" "
                    BEGIN { for (n = split(FILE, f); ++i <= n;) file[f[i]] } \$0 in file && /$argv[1]/
                " | command sed "s|^$HOME|~|"
            end
        case self-update
            _fisher_self_update (status -f)
        case self-uninstall
            _fisher_self_uninstall
        case {,-}-v{ersion,}
            echo "fisher version $fisher_version" (status -f | command sed "s|^$HOME|~|")
        case {,-}-h{elp,}
            _fisher_help
        case ""
            _fisher_commit --
        case add rm
            if not isatty
                while read -l arg
                    set argv $argv $arg
                end
            end

            if test (count $argv) = 1
                echo "fisher: invalid number of arguments" >&2
                _fisher_help >&2
                return 1
            end

            _fisher_commit $argv
        case \*
            echo "fisher: unknown flag or command \"$cmd\"" >&2
            _fisher_help >&2
            return 1
    end
end

function _fisher_complete
    complete -ec fisher
    complete -xc fisher -n __fish_use_subcommand -a add -d "Add packages"
    complete -xc fisher -n __fish_use_subcommand -a rm -d "Remove packages"
    complete -xc fisher -n __fish_use_subcommand -a ls -d "List installed packages matching REGEX"
    complete -xc fisher -n __fish_use_subcommand -a --help -d "Show usage help"
    complete -xc fisher -n __fish_use_subcommand -a --version -d "$fisher_version"
    complete -xc fisher -n __fish_use_subcommand -a self-update -d "Update to the latest version"
    for pkg in (fisher ls)
        complete -xc fisher -n "__fish_seen_subcommand_from rm" -a $pkg
    end
end

function _fisher_copy_user_key_bindings
    if functions -q fish_user_key_bindings
        functions -c fish_user_key_bindings fish_user_key_bindings_copy
    end
    function fish_user_key_bindings
        for file in $fisher_path/conf.d/*_key_bindings.fish
            source $file >/dev/null 2>/dev/null
        end
        if functions -q fish_user_key_bindings_copy
            fish_user_key_bindings_copy
        end
    end
end

function _fisher_ls
    for pkg in $fisher_config/*/*/*
        command readlink $pkg; or echo $pkg
    end
end

function _fisher_fmt
    command sed "s|^[[:space:]]*||;s|^$fisher_config/||;s|^~|$HOME|;s|^\.\/*|$PWD/|;s|^https*:/*||;s|^github\.com/||;s|/*\$||"
end

function _fisher_help
    echo "usage: fisher add <package...>     Add packages"
    echo "       fisher rm  <package...>     Remove packages"
    echo "       fisher                      Update all packages"
    echo "       fisher ls  [<regex>]        List installed packages matching <regex>"
    echo "       fisher --help               Show this help"
    echo "       fisher --version            Show the current version"
    echo "       fisher self-update          Update to the latest version"
    echo "       fisher self-uninstall       Uninstall from your system"
    echo "examples:"
    echo "       fisher add jethrokuan/z rafaelrinaldi/pure"
    echo "       fisher add gitlab.com/foo/bar@v2"
    echo "       fisher add ~/path/to/local/pkg"
    echo "       fisher add <file"
    echo "       fisher rm rafaelrinaldi/pure"
    echo "       fisher ls | fisher rm"
    echo "       fisher ls fish-\*"
end

function _fisher_self_update -a file
    set -l url "https://raw.githubusercontent.com/jorgebucaran/fisher/master/fisher.fish"
    echo "fetching $url" >&2
    command curl -s "$url?nocache" >$file.

    set -l next_version (command awk '{ print $4 } { exit }' <$file.)
    switch "$next_version"
        case "" $fisher_version
            command rm -f $file.
            if test -z "$next_version"
                echo "fisher: cannot update fisher -- are you offline?" >&2
                return 1
            end
            echo "fisher is already up-to-date" >&2
        case \*
            echo "linking $file" | command sed "s|$HOME|~|" >&2
            command mv -f $file. $file
            source $file
            echo "updated to fisher $fisher_version -- hooray!" >&2
            _fisher_complete
    end
end

function _fisher_self_uninstall
    for pkg in (_fisher_ls)
        _fisher_rm $pkg
    end

    for file in $fisher_cache $fisher_config $fisher_path/{functions,completions,conf.d}/fisher.fish $fishfile
        echo "removing $file"
        command rm -Rf $file 2>/dev/null
    end | command sed "s|$HOME|~|" >&2

    for name in (set -n | command awk '/^fisher_/')
        set -e "$name"
    end

    functions -e (functions -a | command awk '/^_fisher/') fisher
    complete -c fisher --erase
end

function _fisher_commit -a cmd
    set -e argv[1]
    set -l elapsed (_fisher_now)

    if test ! -e "$fishfile"
        command touch $fishfile
        echo "created new fishfile in $fishfile" | command sed "s|$HOME|~|" >&2
    end

    set -l old_pkgs (_fisher_ls | _fisher_fmt)
    for pkg in (_fisher_ls)
        _fisher_rm $pkg
    end
    command rm -Rf $fisher_config
    command mkdir -p $fisher_config

    set -l next_pkgs (_fisher_fmt <$fishfile | _fisher_parse -R $cmd (printf "%s\n" $argv | _fisher_fmt))
    set -l actual_pkgs (_fisher_fetch $next_pkgs)
    set -l updated_pkgs
    for pkg in $old_pkgs
        if contains -- $pkg $actual_pkgs
            set updated_pkgs $updated_pkgs $pkg
        end
    end

    if test -z "$actual_pkgs$updated_pkgs$old_pkgs$next_pkgs"
        echo "fisher: nothing to commit -- try adding some packages" >&2
        return 1
    end

    set -l out_pkgs
    if test "$cmd" = "rm"
        set out_pkgs $next_pkgs
    else
        for pkg in $next_pkgs
            if contains -- (echo $pkg | command sed "s|@.*||") $actual_pkgs
                set out_pkgs $out_pkgs $pkg
            end
        end
    end

    printf "%s\n" (_fisher_fmt <$fishfile | _fisher_parse -W $cmd $out_pkgs | command sed "s|^$HOME|~|") >$fishfile

    _fisher_complete

    command awk -v A=(count $actual_pkgs) -v U=(count $updated_pkgs) -v O=(count $old_pkgs) -v E=(_fisher_now $elapsed) '
        BEGIN {
            res = fmt("removed", O - U, fmt("updated", U, fmt("added", A - U)))
            printf((res ? res : "done") " in %.2fs\n", E / 1000)
        }
        function fmt(action, n, s) {
            return n ? (s ? s ", " : s) action " " n " package" (n > 1 ? "s" : "") : s
        }
    ' >&2
end

function _fisher_parse -a mode cmd
    set -e argv[1..2]
    command awk -v FS="[[:space:]]*#+" -v MODE="$mode" -v CMD="$cmd" -v ARGSTR="$argv" '
        BEGIN {
            for (n = split(ARGSTR, a, " "); i++ < n;) pkgs[getkey(a[i])] = a[i]
        }
        !NF { next } { k = getkey($1) }
        MODE == "-R" && !(k in pkgs) && $0 = $1
        MODE == "-W" && (/^#/ || k in pkgs || CMD != "rm") { print pkgs[k] (sub($1, "") ? $0 : "") }
        MODE == "-W" || CMD == "rm" { delete pkgs[k] }
        END {
            for (k in pkgs) {
                if (CMD != "rm" || MODE == "-W") print pkgs[k]
                else print "fisher: cannot remove \""k"\" -- package is not in fishfile" > "/dev/stderr"
            }
        }
        function getkey(s,  a) {
            return (split(s, a, /@+|:/) > 2) ? a[2]"/"a[1]"/"a[3] : a[1]
        }
    '
end

function _fisher_fetch
    set -l pkg_jobs
    set -l out_pkgs
    set -l next_pkgs
    set -l local_pkgs
    set -q fisher_user_api_token; and set -l curl_opts -u $fisher_user_api_token

    for pkg in $argv
        switch $pkg
            case \~\* /\*
                set -l path (echo "$pkg" | command sed "s|^~|$HOME|")
                if test -e "$path"
                    set local_pkgs $local_pkgs $path
                else
                    echo "fisher: cannot add \"$pkg\" -- is this a valid file?" >&2
                end
                continue
        end

        command awk -v PKG="$pkg" -v FS=/ '
            BEGIN {
                if (split(PKG, tmp, /@+|:/) > 2) {
                    if (tmp[4]) sub("@"tmp[4], "", PKG)
                    print PKG "\t" tmp[2]"/"tmp[1]"/"tmp[3] "\t" (tmp[4] ? tmp[4] : "master")
                } else {
                    pkg = split(PKG, _, "/") <= 2 ? "github.com/"tmp[1] : tmp[1]
                    tag = tmp[2] ? tmp[2] : "master"
                    print (\
                        pkg ~ /^github/ ? "https://codeload."pkg"/tar.gz/"tag : \
                        pkg ~ /^gitlab/ ? "https://"pkg"/-/archive/"tag"/"tmp[split(pkg, tmp, "/")]"-"tag".tar.gz" : \
                        pkg ~ /^bitbucket/ ? "https://"pkg"/get/"tag".tar.gz" : pkg \
                    ) "\t" pkg
                }
            }
        ' | read -l url pkg branch

        if test ! -d "$fisher_config/$pkg"
            fish -c "
                echo fetching $url >&2
                command mkdir -p $fisher_config/$pkg $fisher_cache/(command dirname $pkg)
                if test ! -z \"$branch\"
                     command git clone $url $fisher_config/$pkg --branch $branch --depth 1 2>/dev/null
                     or echo fisher: cannot clone \"$url\" -- is this a valid url\? >&2
                else if command curl $curl_opts -Ss -w \"\" $url 2>&1 | command tar -xzf- -C $fisher_config/$pkg 2>/dev/null
                    command rm -Rf $fisher_cache/$pkg
                    command mv -f $fisher_config/$pkg/* $fisher_cache/$pkg
                    command rm -Rf $fisher_config/$pkg
                    command cp -Rf {$fisher_cache,$fisher_config}/$pkg
                else if test -d \"$fisher_cache/$pkg\"
                    echo fisher: cannot connect to server -- looking in \"$fisher_cache/$pkg\" | command sed 's|$HOME|~|' >&2
                    command cp -Rf $fisher_cache/$pkg $fisher_config/$pkg/..
                else
                    command rm -Rf $fisher_config/$pkg
                    echo fisher: cannot add \"$pkg\" -- is this a valid package\? >&2
                end
            " >/dev/null &
            set pkg_jobs $pkg_jobs (_fisher_jobs --last)
            set next_pkgs $next_pkgs "$fisher_config/$pkg"
        end
    end

    if set -q pkg_jobs[1]
        while for job in $pkg_jobs
                contains -- $job (_fisher_jobs); and break
            end
        end
        for pkg in $next_pkgs
            if test -d "$pkg"
                set out_pkgs $out_pkgs $pkg
                _fisher_add $pkg
            end
        end
    end

    set -l local_prefix $fisher_config/local/$USER
    if test ! -d "$local_prefix"
        command mkdir -p $local_prefix
    end
    for pkg in $local_pkgs
        set -l target $local_prefix/(command basename $pkg)
        if test ! -L "$target"
            command ln -sf $pkg $target
            set out_pkgs $out_pkgs $pkg
            _fisher_add $pkg --link
        end
    end

    if set -q out_pkgs[1]
        _fisher_fetch (
            for pkg in $out_pkgs
                if test -s "$pkg/fishfile"
                    _fisher_fmt <$pkg/fishfile | _fisher_parse -R
                end
            end)
        printf "%s\n" $out_pkgs | _fisher_fmt
    end
end

function _fisher_add -a pkg opts
    for src in $pkg/{functions,completions,conf.d}/**.* $pkg/*.fish
        set -l target (command basename $src)
        switch $src
            case $pkg/conf.d\*
                set target $fisher_path/conf.d/$target
            case $pkg/completions\*
                set target $fisher_path/completions/$target
            case $pkg/{functions,}\*
                switch $target
                    case uninstall.fish
                        continue
                    case {init,key_bindings}.fish
                        set target $fisher_path/conf.d/(command basename $pkg)\_$target
                    case \*
                        set target $fisher_path/functions/$target
                end
        end
        echo "linking $target" | command sed "s|$HOME|~|" >&2
        if set -q opts[1]
            command ln -sf $src $target
        else
            command cp -f $src $target
        end
        switch $target
            case \*.fish
                source $target >/dev/null 2>/dev/null
        end
    end
end

function _fisher_rm -a pkg
    for src in $pkg/{conf.d,completions,functions}/**.* $pkg/*.fish
        set -l target (command basename $src)
        set -l filename (command basename $target .fish)
        switch $src
            case $pkg/conf.d\*
                test "$filename.fish" = "$target"; and emit "$filename"_uninstall
                set target conf.d/$target
            case $pkg/completions\*
                test "$filename.fish" = "$target"; and complete -ec $filename
                set target completions/$target
            case $pkg/{,functions}\*
                test "$filename.fish" = "$target"; and functions -e $filename
                switch $target
                    case uninstall.fish
                        source $src
                        continue
                    case {init,key_bindings}.fish
                        set target conf.d/(command basename $pkg)\_$target
                    case \*
                        set target functions/$target
                end
        end
        command rm -f $fisher_path/$target
    end
    if not functions -q fish_prompt
        source "$__fish_datadir$__fish_data_dir/functions/fish_prompt.fish"
    end
end

function _fisher_jobs
    jobs $argv | command awk '/^[0-9]+\t/ { print $1 }'
end

function _fisher_now -a elapsed
    switch (command uname)
        case Darwin \*BSD
            command perl -MTime::HiRes -e 'printf("%.0f\n", (Time::HiRes::time() * 1000) - $ARGV[0])' $elapsed
        case \*
            math (command date "+%s%3N") - "0$elapsed"
    end
end
#+end_src

** Tilix

#+begin_src json :tangle ~/.config/tilix/schemes/gruvbox-light-hard.json :mkdirp yes
{
    "name": "Gruvbox Light Hard",
    "comment": "Gruvbox Light Scheme (hard contrast)",
    "use-theme-colors": false,
    "foreground-color": "#282828",
    "background-color": "#f9f5d7",
    "palette": [
        "#f9f5d7",
        "#cc241d",
        "#98971a",
        "#d79921",
        "#458588",
        "#b16286",
        "#689d6a",
        "#665c54",
        "#a89984",
        "#9d0006",
        "#79740e",
        "#b57614",
        "#076678",
        "#8f3f71",
        "#427b58",
        "#3c3836"
    ]
}
#+end_src

#+begin_src json :tangle ~/.config/tilix/schemes/gruvbox-dark-hard.json :mkdirp yes
{
    "name": "Gruvbox Dark Hard",
    "comment": "Gruvbox Dark Scheme (hard contrast)",
    "use-theme-colors": false,
    "foreground-color": "#ebdbb2",
    "background-color": "#1d2021",
    "palette": [
        "#1d2021",
        "#cc241d",
        "#98971a",
        "#d79921",
        "#458588",
        "#b16286",
        "#689d6a",
        "#bdae93",
        "#7c6f64",
        "#fb4934",
        "#b8bb26",
        "#fabd2f",
        "#83a598",
        "#d3869b",
        "#8ec07c",
        "#ebdbb2"
    ]
}
#+end_src

** tmux
:properties:
:header-args: :tangle ~/.tmux.conf
:end:

#+begin_src conf
set-option -g prefix C-Space
bind-key ^b send-prefix
#+end_src

#+begin_src conf
set-option -g base-index 1
set-option -g renumber-windows on
set-option -g default-terminal 'xterm-256color'
set-option -ga terminal-overrides ",xterm-256color:Tc"
set -g mouse on
set-option -g bell-action current
set-window-option -g aggressive-resize on
set-option -s escape-time 0
set-option -g history-limit 10000
set-option -g focus-events on
set-option -ga update-environment ' AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY'
#+end_src

#+begin_src conf
set-option -g status-keys 'vi'
set-window-option -g mode-keys 'vi'
set-window-option -g xterm-keys on
#+end_src

#+begin_src conf
set-option -g set-titles on
set-option -g set-titles-string "#T"
#+end_src

#+begin_src conf
set-option -g pane-border-format " #T "
set-option -g pane-border-status off
set-option -g pane-border-style fg=#bdae93,bg=#222222
set-option -g pane-active-border-style fg=#fe8019,bg=#222222
#+end_src

#+begin_src conf
set-option -g status-style fg=#f9f5d7,bg=#3c3836
set-option -g status-left ''
set-option -g status-right '[#S] [#(cut -d" " -f1-3 /proc/loadavg)]'

set-window-option -g window-status-format " #F#I#[fg=#bdae93]|#[fg=#f9f5d7]#{?#{==:#{window_name},fish},#{s|$HOME|~|:pane_current_path},#W} "
set-window-option -g window-status-current-format " #F#I#[fg=#bdae93]|#[fg=#3c3836]#{?#{==:#{window_name},fish},#{s|$HOME|~|:pane_current_path},#W} "
set-window-option -g window-status-current-style fg=#3c3836,bg=#f9f5d7

set-option -g -t main status on
set-option -g -t main status-position top
set-option -g -t main status-left ''
set-option -g -t main status-right '#I '
set-option -g -t main status-justify centre
set-option -g -t main destroy-unattached off
# set-window-option -g -t main window-status-current-format " #F#I#[fg=#bdae93]|#[fg=#3c3836]#{?#{==:#{window_name},fish},#{s|$HOME|~|:pane_current_path},#W} "
set-window-option -g -t main window-status-current-format " ▼  "
#+end_src

#+begin_src conf
bind-key b send-prefix
bind-key a last-window
bind-key ^a last-window

#bind-key -n C-h swap-window -t:-
#bind-key -n C-s swap-window -t:+
# bind-key -n C-h previous-window
# bind-key -n C-s next-window

# bind-key -n C-M-h previous-window
# bind-key -n C-S-Tab previous-window
# bind-key -n C-Tab next-window
bind-key -n C-M-h run-shell "~/bin/tmux-switch-to-unattached-window.sh left"
bind-key -n C-S-Tab run-shell "~/bin/tmux-switch-to-unattached-window.sh left"
bind-key -n C-Tab run-shell "~/bin/tmux-switch-to-unattached-window.sh"

bind-key C-b set-option -g status

# bind-key n select-pane -t:.-
# bind-key t select-pane -t:.+
bind-key -n C-h select-pane -L
bind-key -n C-t select-pane -D
bind-key -n C-n select-pane -U
bind-key -n C-s select-pane -R

bind-key c new-window -c "#{pane_current_path}"
bind-key | split-window -h -c "#{pane_current_path}"
bind-key - split-window -c "#{pane_current_path}"
bind-key -n ^_ detach-client

bind-key r source-file ~/.tmux.conf

set-option -s set-clipboard off
bind-key p paste-buffer

bind-key ` copy-mode
bind-key Space copy-mode
bind-key C-Space copy-mode

bind-key -n C-PageUp copy-mode -eu
bind-key -Tcopy-mode-vi C-PageDown send -X page-down

bind-key -Tcopy-mode-vi t send -X cursor-down
bind-key -Tcopy-mode-vi n send -X cursor-up
bind-key -Tcopy-mode-vi h send -X cursor-left
bind-key -Tcopy-mode-vi s send -X cursor-right
bind-key -Tcopy-mode-vi v send -X begin-selection
bind-key -Tcopy-mode-vi y send -X copy-selection

bind-key -Tchoose t send-keys -X cursor-down
bind-key -Tchoose n send-keys -X cursor-up
#+end_src

Use wayland tools on wayland desktop (using emacs pgtk build as a test for wayland desktop usage, which is not perfect, but good enough for me.)

#+begin_src conf :tangle (if (featurep 'pgtk) "~/.tmux.conf" "no")
bind-key P run "tmux set-buffer \"$(wl-paste -pn)\"; tmux paste-buffer"
bind-key y run "tmux show-buffer | wl-copy"
#+end_src

Use good old xclip on xorg desktop sessions.

#+begin_src conf :tangle (if (not (featurep 'pgtk)) "~/.tmux.conf" "no")
bind-key P run "tmux set-buffer \"$(xclip -o -sel clipboard)\"; tmux paste-buffer"
bind-key y run "tmux save-buffer - | xclip -i -sel clipboard"
#+end_src

TPM setup. I think I should remove this and just manually install what I want here.

#+begin_src conf
# set -g @plugin 'tmux-plugins/tpm'
# set -g @plugin 'seebi/tmux-colors-solarized'
# set -g @colors-solarized 'light'

# run -b '~/.tmux/plugins/tpm/tpm'
#+end_src

Startup commands.

#+begin_src conf
new-session -s main
#+end_src

* Old Config
:PROPERTIES:
:VISIBILITY: folded
:END:
Some configuration for tools that I don't really use any more and want out of the way, but want to keep around.
