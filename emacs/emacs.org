#+property: header-args:emacs-lisp :tangle "init.el"
#+property: header-args :mkdirp yes :comments no :results silent
#+startup: showall inlineimages

#+title: My Emacs config file
#+author: Nathan Howell
#+email: nath@nhowell.net

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. This configuration was heavily influenced/started from [[http://zzamboni.org/post/my-emacs-configuration-with-commentary/][Diego Zamboni’s configuration]], as well as [[https://github.com/blaenk/dots/tree/master/emacs/.emacs.d][Jorge Israel Peña's]].

This is a handy command I’ve been using to test as I move to a literate config. =C-c C-c= will launch a new emacs, using the tangled version of this config.
#+begin_src shell :tangle no :results silent
emacs -Q -l profile-dotemacs.el --eval "(setq profile-dotemacs-file (setq load-file-name \"/home/nathan/.emacs.d/init.el\"))" -f profile-dotemacs
#+end_src


* Initialization
:properties:
:header-args:emacs-lisp: :tangle "early-init.el" :dir user-emacs-directory
:end:

Since this is a literate configuration, a small =init.el= file is needed to handle tangling and loading the rest of the configuration when necessary. That file gets created here, and the tangled result needs to be commited to the git repository whenever any changes are made to it here.

Right up front, enable [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][lexical binding]].

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

Next, we wrap the whole init file in a block that sets =file-name-handler-alist= to =nil= to prevent any special-filename parsing of files loaded from the init file (e.g. remote files loaded through tramp, etc.). Rather than having a block that closes this later, let's pull in the rest of the init file bits with noweb references.

#+begin_src emacs-lisp :noweb yes
(let ((file-name-handler-alist nil))
  <<init-gc-init>>
  <<init-straight>>
  <<init-use-package>>
  <<init-org>>
  <<init-tangle>>
  <<init-gc-setup>>)
#+end_src

We set =gc-cons-threshold= to its maximum value, to prevent any garbage collection from happening during load time. We also reset this value in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp :tangle no :noweb-ref init-gc-init
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

I use [[https://github.com/raxod502/straight.el][straight.el]] instead of package.el.

This setting makes the straight bootstrap /much/ faster. See the discussion [[https://github.com/raxod502/straight.el/issues/304][here]].

#+begin_src emacs-lisp :tangle no :noweb-ref init-straight
(setq straight-check-for-modifications '(check-on-save))
#+end_src

And now bootstrap straight, using the snippet from the docs.

#+begin_src emacs-lisp :tangle no :noweb-ref init-straight
;; (setq native-comp-deferred-compilation-deny-list ()
      ;; comp-deferred-compilation-deny-list ())
;; (setq straight-repository-branch "develop")
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

And then make [[https://github.com/jwiegley/use-package][use-package]] use straight, and install use-package using straight:

#+begin_src emacs-lisp :tangle no :noweb-ref init-use-package
(setq straight-use-package-by-default t)
(straight-use-package 'use-package)
(setq use-package-verbose nil
      ;; use-package-always-defer t
      )
#+end_src

Dump any other straight configuration here.

#+begin_src emacs-lisp :tangle no :noweb-ref init-straight
(setq straight-vc-git-auto-fast-forward nil)
#+end_src

Load =org-mode= using straight. This needs to happen early, or emacs will load and use its bundled version of =org-mode=, which is just too old.

#+begin_src emacs-lisp :tangle no :noweb-ref init-org
(use-package org
  :demand t
  :config
  (setq custom-enabled-themes '()))
#+end_src

Here's where the rest of this file gets tangled and loaded, but only if it's newer than the existing tangled file. Tangling is slow (at least it is when you start using no-web references...), so we don't want to do it for no good reason.

#+begin_src emacs-lisp :tangle no :noweb-ref init-tangle
(let ((orgfile (concat user-emacs-directory "emacs.org"))
      (elfile (concat user-emacs-directory "init.el"))
      (earlyfile (concat user-emacs-directory "early-init.el")))
  (when (or (not (file-exists-p elfile))
            (file-newer-than-file-p orgfile elfile)
            (file-newer-than-file-p orgfile earlyfile))
    (org-babel-tangle-file orgfile)))
#+end_src

Then reset the value of =gc-cons-threshold=, not to its original value; we still leave it much larger than default so that GCs don't happen so often and impact performance. We also tweak =gc-cons-percentage= and set an idle timer to run =garbage-collect= whenever emacs is idle for 5 seconds.

#+begin_src emacs-lisp :tangle no :noweb-ref init-gc-setup
(setq gc-cons-threshold (* 3200 1000)
      gc-cons-percentage 0.6)

(defvar neh/gc-idle-timer nil)
(unless (timerp neh/gc-idle-timer)
  (setq neh/gc-idle-timer (run-with-idle-timer 5 t #'garbage-collect)))
#+end_src

Another interesting option here, gc when unfocusing a frame, from https://news.ycombinator.com/item?id=31394001

#+begin_src emacs-lisp :tangle no
(add-function :after
  after-focus-change-function
  (lambda () (unless (frame-focus-state)
               (garbage-collect))))
#+end_src

* Performance optimization

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

Lately I've been playing with optimizing my Emacs load time. I have found a couple of useful resources, including:

- [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][Two easy little known steps to speed up Emacs start up time]]
- [[https://blog.d46.us/advanced-emacs-startup/][Advanced Techniques for Reducing Emacs Startup Time]]

Based on these, I have added the code below.

First, a hook that reports how long and how many garbage collections the startup took. Use a hook so the message doesn't get clobbered by other messages.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

Set up ESUP for startup profiling.

#+begin_src emacs-lisp
(use-package esup
  :commands (esup))
#+end_src

* Package management

This =use-package= extension allows declaring dependencies on system commands.

#+begin_src emacs-lisp
(use-package use-package-ensure-system-package)
#+end_src

* Base settings

Load any host-specific configuration. Anything set here will just get overridden by deferred package loads so the way I’m dealing with that is to set vars here with different (=neh/…=) names, then set the real vars conditionally in package configurations elsewhere.

#+begin_src emacs-lisp
(setq neh/local-conf-file (expand-file-name
                           (concat system-name ".el")
                           user-emacs-directory))
(when (file-readable-p neh/local-conf-file)
  (load-file neh/local-conf-file))
#+end_src

Collect all the global, non-package-specific settings here.

#+begin_src emacs-lisp :noweb yes
(use-package emacs
  :custom
  <<emacs-custom>>

  :hook
  (minibuffer-setup . cursor-intangible-mode)

  :init
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; for org-modern
  (modify-all-frames-parameters
   '((right-divider-width . 3)
     (internal-border-width . 0)
     ))
  (dolist (face '(window-divider
                  window-divider-first-pixel
                  window-divider-last-pixel))
    (face-spec-reset-face face)
    (set-face-foreground face (face-attribute 'default :background)))
  (set-face-background 'fringe (face-attribute 'default :background))

  (defun neh/customize-this (arg)
    "Call customize-set-variable with a specific setting pre-selected."
    (interactive)
    (minibuffer-with-setup-hook
        (lambda ()
          (insert arg)
          (add-hook 'post-command-hook #'exit-minibuffer nil t))
      (call-interactively #'customize-set-variable)))

  (defun neh/update-packages (arg)
    "Set all packages to the versions in the straight.el lockfile."
    (straight-pull-recipe-repositories)
    (straight-fetch-all)
    (straight-thaw-versions)
    (straight-rebuild-all))
  (add-to-list 'command-switch-alist '("--update-packages" . neh/update-packages))

  (defun neh/recenter-after (&rest args)
    "A function to use as :after advice for recentering wherever."
    (recenter 10))

  :config
  (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

Turn off all startup messages, splash screens, menu bars, scrollbars, etc. for a clean start.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(inhibit-splash-screen t)
(inhibit-startup-message t)
(initial-scratch-message nil)
(inhibit-startup-echo-area-message t)

(tab-always-indent 'complete)

(menu-bar-mode nil)
(tool-bar-mode nil)
(scroll-bar-mode nil)
(default-frame-alist '((vertical-scroll-bars . nil)))
(initial-frame-alist '((vertical-scroll-bars . nil)))
#+end_src

Log but don't pop up a buffer for warnings during native compilation of packages. They are just too annoying with deferred package loads.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(native-comp-async-report-warnings-errors nil)
#+end_src

Set scrolling options. These stop the half-page jumps while scrolling, and make things smoother.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(mouse-wheel-scroll-amount '(2 ((shift) . 1)))
(mouse-wheel-progressive-speed nil)
(mouse-wheel-follow-mouse 't)
(scroll-step 1)
(scroll-margin 3)
(hscroll-step 3)
(hscroll-margin 3)
(scroll-preserve-screen-position 'always)
(scroll-up-aggressively 0.01)
(scroll-down-aggressively 0.01)
(scroll-conservatively 101)
#+end_src

And let’s try out the new single-line-horizontal-scroll option in emacs 26.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(auto-hscroll-mode 'current-line)
#+end_src

from https://www.wisdomandwonder.com/programming/13521/automatically-open-read-only-files-in-view-mode
#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(view-read-only t)
#+end_src

Set the window titles. Nothing fancy, just the buffer name.

#+begin_src emacs-lisp
(setq frame-title-format "%b"
      icon-title-format "%b") ;; unfocused window title format
#+end_src

Running shell commands from emacs is handy, being able to use shell aliases makes it even better, so let's have emacs run commands in an interactive shell. "-ic" looks like it works for bash and fish, while zsh/oh-my-zsh needs "-csi".

#+begin_src emacs-lisp :tangle no :noweb-rep emacs-custom
(shell-command-switch "-ic")
#+end_src

Since I force there to be no file to store custom settings in, I get prompted for things like variables in ~.dir-locals.el~ files every time they are read (as emacs can't record my answers for the next time). So I whitelist the variables and values here that I don't want to be prompted for. I'm not sure this is the /right/ way to handle this, maybe I should have a custom file just for things like this and commit it to git so I can keep it controlled. The main reason I ditched the custom file was because it ended up having a bunch of forgotten settings hanging around affecting things, which having it in git would alleviate.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(safe-local-variable-values '((auto-revert-use-notify)
                              (auto-revert-check-vc-info . nil)
                              (epa-file-encrypt-to . "C113BA91EAF8B45B6B84BDCBB600587C4549248A")
                              (org-download-image-dir)))
#+end_src

I use the customization system in Emacs via ~:custom~ blocks in ~use-package~, and I don't want customized settings accumulating in a file where they can be forgotten about and trip me up later. This seems like a sane way to use the customization system to me, so we'll see.

#+begin_src emacs-lisp
(use-package cus-edit
  :straight nil
  :custom
  (custom-file null-device))
#+end_src

All UTF-8, all the time.

#+begin_src emacs-lisp
;; https://goyoambrosio.com/2018/06/Dealing-with-utf-8-in-Emacs/

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(set-selection-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
(set-clipboard-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

Don’t use tabs when indenting.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(indent-tabs-mode nil)
#+end_src

More options. I’m not sure where to put some things in this file yet. Here are some.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(sentence-end-double-space nil)
(ring-bell-function 'ignore)
(enable-recursive-minibuffers t)
(global-subword-mode t)

(minibuffer-prompt-properties
 '(read-only t cursor-intangible t face minibuffer-prompt))

;; hide commands in M-x that don't work in the current mode
(read-extended-command-predicate #'command-completion-default-include-p)
#+end_src

Don’t warn me when I do these potentially confusing narrowing operations.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'list-timers 'disabled nil)
#+end_src

Set some backup file options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(make-backup-files nil)
(delete-old-versions t)
(backup-directory-alist `((".*" . ,temporary-file-directory)))
(auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
#+end_src

I’m testing out [[https://github.com/swaywm/sway][sway]] as my window manager, and apparently ~$SSH_AUTH_SOCK~ doesn’t get set (maybe just for xwayland apps?). So we workaround. I already set a fixed link to the real socket for tmux usage, I can reuse it for this.

#+begin_src emacs-lisp
(when (string= (getenv "SSH_AUTH_SOCK") nil)
  (setenv "SSH_AUTH_SOCK" (format "%s/ssh-agent.socket" (getenv "XDG_RUNTIME_DIR"))))
#+end_src

Some text fill options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(fill-column 100)
(default-frame-alist '((width  . 100)))
(comment-auto-fill-only-comments t)
#+end_src

Set standard emacs completion to ignore case for files and buffers.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(completion-ignore-case t)
(read-buffer-completion-ignore-case t)
(read-file-name-completion-ignore-case t)
#+end_src

I view man pages in emacs sometimes, and want a fixed width for them.

#+begin_src emacs-lisp
(use-package man
  :straight nil
  :custom
  (Man-width fill-column)
  (Man-notify-method 'newframe))

(use-package woman
  :straight nil
  :custom
  (woman-fill-column fill-column))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(line-spacing 0.2)
#+end_src

How to make display buffer names.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(uniquify-buffer-name-style 'forward)
#+end_src

Some git/vc options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(vc-follow-symlinks t)
#+end_src

When pasting (yanking) into emacs, paste at the point, not where I click (I like to paste with the middle mouse button, xorg-style).

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(mouse-yank-at-point t)
#+end_src

#+begin_src emacs-lisp
(use-package xref
  :straight nil
  :custom
  (xref-show-definitions-function #'xref-show-definitions-completing-read)
  (xref-search-program 'ripgrep))
#+end_src

#+begin_src emacs-lisp
(use-package browse-url
  :straight nil
  :custom
  (browse-url-browser-function 'browse-url-firefox))
#+end_src

* Keybindings

[[https://github.com/noctuid/general.el][General.el]] handles keybinding management.

#+begin_src emacs-lisp
(use-package general
  :demand t

  :config
  (general-create-definer
    neh/leader-keys
    :keymaps 'override
    :states '(emacs normal visual motion insert)
    :non-normal-prefix "C-SPC"
    :prefix "SPC")

  (general-create-definer
    neh/leader-nav
    :keymaps 'override
    :states '(emacs normal visual motion insert)
    :non-normal-prefix "C-j"
    :prefix "j")

  (general-override-mode)

  (general-define-key
   :keymaps 'override
   :states '(emacs normal insert)
   "C-M-t" 'scroll-other-window
   "C-M-n" 'scroll-other-window-down

   "<C-mouse-5>" '(lambda () (interactive) (neh/adjust-text-height -5))
   "<C-mouse-4>" '(lambda () (interactive) (neh/adjust-text-height 5)))

  (neh/leader-keys
    "<SPC>" #'save-buffer

    "e" #'execute-extended-command
    "E" #'execute-extended-command-for-buffer
    "Q" #'bury-buffer

    "y" #'clipboard-yank
    )

  ;; ???
  ;; (neh/leader-keys
  ;;   :keymaps 'override
  ;;   :states '(normal)
  ;;   "u" (general-key "C-x"))

  (neh/leader-keys
    :infix "c"
    "c" #'comment-or-uncomment-region-or-line
    "q" #'quick-calc)

  (neh/leader-keys
    :infix "f"
    "a" #'auto-fill-mode
    "i" #'indent-region
    "p" #'fill-paragraph
    "r" #'fill-region
    "t" #'toggle-truncate-lines
    "f" '(lambda () (interactive) (set-frame-width nil fill-column)))

  (neh/leader-keys
    :infix "h"
    "m" #'describe-mode)

  (neh/leader-keys
    :infix "x"
    "b" #'eval-buffer
    "e" #'eval-expression
    "r" #'eval-region
    "s" #'eval-last-sexp)
  )
#+end_src

* Base2

Not sure where to put everything yet, so this section is a grab bag of stuff that needs package management (straight) to be in place.

#+begin_src emacs-lisp
(use-package color
  :demand t
  :config
  (defun neh/dark-p ()
    (let ((bg (face-background 'default)))
      (if (>= (color-distance "black" bg)
              (color-distance "white" bg))
          nil
        t))))

(use-package bookmark
  :demand t
  :straight nil
  :custom
  (bookmark-fontify nil))

(use-package saveplace
  :demand t
  :config
  (save-place-mode t))

(use-package recentf
  :straight nil
  :custom
  (recentf-max-saved-items 100)
  :config
  (recentf-mode t))

(use-package savehist
  :straight nil
  :demand t
  :custom
  (savehist-additional-variables '(evil-jumps-history
                                   projectile-project-command-history
                                   command-history
                                   ))
  (savehist-autosave-interval 90)
  ;; :config
  ;; (savehist-mode 1)
  )

(use-package eldoc
  :straight nil
  :custom
  (eldoc-echo-area-use-multiline-p nil))

(use-package undo-fu
  :after (evil)
  :defer 0.5
  :custom
  (evil-undo-system 'undo-fu))

(use-package undo-fu-session
  :hook (after-init . global-undo-fu-session-mode)
  :custom
  (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))

(use-package paren
  :custom
  (show-paren-delay 0)
  (show-paren-style 'parenthesis)
  :config
  (show-paren-mode 1))

(use-package whitespace
  :commands (whitespace-mode)
  :general
  (neh/leader-keys
    "vw" #'whitespace-mode)
  :custom
  (whitespace-line-column 80)
  (whitespace-style '(face trailing tabs lines-tail)))

(use-package ws-butler
  :hook (prog-mode . ws-butler-mode))

(use-package apropos
  :straight nil)

(use-package helpful
  :after (apropos)
  :custom
  (helpful-max-buffers 5)
  :general
  (neh/leader-keys
    "h." #'helpful-at-point
    "hf" #'helpful-callable
    "hk" #'helpful-key
    "ho" #'helpful-symbol
    "hv" #'helpful-variable)
  (:keymaps 'embark-symbol-map
   "h" #'helpful-symbol)
  :init
  ;; https://github.com/Wilfred/elisp-refs/issues/35
  (when (>= emacs-major-version 29)
    (defvar read-symbol-positions-list nil))
  :config
  ;; from https://github.com/Wilfred/helpful/issues/25
  ;; makes apropos lookups use helpful functions
  (let ((do-function (lambda (button)
                       (helpful-function (button-get button 'apropos-symbol))))
        (do-variable (lambda (button)
                       (helpful-variable (button-get button 'apropos-symbol)))))
    ;; :supertype only takes effect statically, at the time of
    ;; definition, so we can in fact redefine a button with itself
    ;; as its supertype
    (define-button-type 'apropos-function :supertype 'apropos-function 'action do-function)
    (define-button-type 'apropos-macro :supertype 'apropos-macro 'action do-function)
    (define-button-type 'apropos-command :supertype 'apropos-command 'action do-function)
    (define-button-type 'apropos-variable :supertype 'apropos-variable 'action do-variable)
    (define-button-type 'apropos-user-option :supertype 'apropos-user-option 'action do-variable)))

(use-package autorevert
  :demand t
  :straight nil
  ;; :hook
  ;; not sure why I have these hooks when I set it globally below...
  ;; (org-mode . auto-revert-mode)
  ;; (dired-mode . auto-revert-mode)
  :custom
  (global-auto-revert-non-file-buffers t)
  (auto-revert-check-vc-info nil)
  :config
  (global-auto-revert-mode 1))
#+end_src

Make sure my local bin dir is in emacs =$PATH=, and keep it updated.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :hook (after-init . exec-path-from-shell-initialize)
  :custom
  (exec-path-from-shell-arguments '("-l")))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package isearch
  :straight nil
  :custom
  (search-whitespace-regexp ".*?")
  (isearch-lazy-count t))
#+end_src

#+begin_src emacs-lisp
(use-package finder
  :straight nil
  :after general
  :general
  (neh/leader-keys
    "hC" #'finder-commentary))
#+end_src

* Text mode

General settings when in text editing modes.

#+begin_src emacs-lisp
(use-package simple
  :straight nil
  :hook ((text-mode prog-mode) . visual-line-mode)
  :general
  (neh/leader-keys
    "fv" #'visual-line-mode))

(use-package visual-fill-column
  :hook (visual-line-mode . visual-fill-column-mode)
  :general
  (neh/leader-keys
    "fc" #'visual-fill-column-mode)

  :custom
  (split-window-preferred-function #'visual-fill-column-split-window-sensibly)

  :config
  (advice-add 'text-scale-adjust :after
              #'visual-fill-column-adjust))
#+end_src

I’ll put olivetti mode here since I think it’s mainly a text mode thing rather than for programming, but who knows.

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :custom
  (olivetti-body-width fill-column))
#+end_src

And let’s try out writeroom mode.

#+begin_src emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode
             global-writeroom-mode)
  :custom
  (writeroom-width fill-column)
  (writeroom-extra-line-spacing 0)
  (writeroom-border-width 40)
  :config
  (add-to-list 'writeroom-global-effects 'writeroom-set-internal-border-width))
#+end_src

* Pretty it up

Emacs colour themes apparently just load on top of each other, so here’s an advice to disable the current theme before loading a new one, thanks to [[https://www.reddit.com/r/emacs/comments/8v9lgu/emacs_theme_configuration_is_very_confusing/][this thread]].

#+begin_src emacs-lisp
(define-advice load-theme (:before (&rest _args) theme-dont-propagate)
  "Discard all themes before loading new."
  (mapc #'disable-theme custom-enabled-themes))
#+end_src

#+begin_src emacs-lisp
(use-package modus-themes
  :custom
  (modus-themes-org-blocks 'gray-background)
  (modus-themes-mixed-fonts t)
  (modus-themes-bold-constructs t)
  (modus-themes-italic-constructs t)
  (modus-themes-region '(bg-only)))

(use-package ef-themes)

(use-package gruvbox-theme
  :custom-face
  (org-block-begin-line ((t (:inherit fixed-pitch
                             :slant italic))))
  (org-block-end-line ((t (:inherit fixed-pitch
                           :slant italic)))))

(use-package poet-theme)

(defun neh/set-dark-mode ()
  "Load dark theme."
  (interactive)
  (setq neh/dark-mode t)
  (load-theme neh/dark-theme t))

(defun neh/set-light-mode ()
  "Load light theme."
  (interactive)
  (setq neh/dark-mode nil)
  (load-theme neh/light-theme t))

(defun neh/toggle-dark-mode ()
  "Toggle dark/light theme."
  (interactive)
  (if (neh/dark-p)
      (neh/set-light-mode)
    (neh/set-dark-mode)))

(defun neh/setthemeset (sym value)
  (cond ((equal value "gruvbox")
         (setq neh/dark-theme 'gruvbox-dark-hard
               neh/light-theme 'gruvbox-light-hard))
        ((equal value "modus")
         (setq neh/dark-theme 'modus-vivendi
               neh/light-theme 'modus-operandi))
        ((equal value "mix")
         (setq neh/dark-theme 'gruvbox-dark-hard
               neh/light-theme 'modus-operandi)))
  (if (neh/dark-p)
      (neh/set-dark-mode)
    (neh/set-light-mode)))

(defcustom neh/themeset "mix"
  "Indicates which set of themes (dark and light) to use."
  :type '(choice
          (const "gruvbox")
          (const "modus")
          (const "mix"))
  :set 'neh/setthemeset
  :initialize 'custom-initialize-set)

(customize-set-variable 'neh/themeset "modus")
#+end_src

#+begin_src emacs-lisp
;; thanks to https://www.reddit.com/r/emacs/comments/o49v2w/automatically_switch_emacs_theme_when_changing

(defun call-process-string (program &rest args)
  "Call process`PROGRAM' with `ARGS' and return the output as string."
  (with-temp-buffer
    (apply #'call-process program nil t nil args)
    (buffer-string)))

(use-package dbus
  :straight nil
  :config
  (defun set-dark-or-light (dark)
    (cond ((= 1 dark)
           (neh/set-dark-mode))
          ((or (= 2 dark) (= 0 dark))
           (neh/set-light-mode))))

  (defun handler (value)
    (set-dark-or-light (car (car value))))

  (defun signal-handler (namespace key value)
    (if (and
         (string-equal namespace "org.freedesktop.appearance")
         (string-equal key "color-scheme"))
        (set-dark-or-light (car value))))

  (dbus-call-method-asynchronously
   :session
   "org.freedesktop.portal.Desktop"
   "/org/freedesktop/portal/desktop"
   "org.freedesktop.portal.Settings"
   "Read"
   #'handler
   "org.freedesktop.appearance"
   "color-scheme")

  (dbus-register-signal
   :session
   "org.freedesktop.portal.Desktop"
   "/org/freedesktop/portal/desktop"
   "org.freedesktop.portal.Settings"
   "SettingChanged"
   #'signal-handler)

  )
#+end_src

But I like some things to be set no matter the theme. For example, I always like italic code comments. And the brutalist theme has a smaller modeline font size that I don’t like. So I set up a hook/advice method of keeping these things “fixed”. I found the idea in [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/][this helpful reddit thread]] while looking for what I thought /must/ have a /good/ solution.

#+begin_src emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))

(add-hook 'after-load-theme-hook #'neh/theme-tweaks)
(if (daemonp)
    (add-hook 'server-after-make-frame-hook #'neh/theme-tweaks)
  (add-hook 'after-init-hook #'neh/theme-tweaks))
#+end_src

Handy functions to calculate the DPI of the display that current frame is on. Bits and pieces of this came from various places, but especially [[https://www.reddit.com/r/emacs/comments/a01fs1/dispwatch_watch_the_current_display_for_changes/][this reddit thread]], which led me to [[https://emacs.stackexchange.com/questions/28390/quickly-adjusting-text-to-dpi-changes/44930#44930][this useful StackExchange question]].

#+begin_src emacs-lisp
(defun frame-monitor-mm ()
  "Return the size of the current monitor in mm."
  (alist-get 'mm-size (frame-monitor-attributes)))

(defun frame-monitor-pixels ()
  "Return the geometry of the current monitor in pixels."
  (alist-get 'geometry (frame-monitor-attributes)))

(defun monitor-dpi ()
  "Return the DPI of the current monitor."
  (let* ((mm (frame-monitor-mm))
         (mm-width (car mm))
         (pixels (frame-monitor-pixels))
         (pixel-width (nth 2 pixels)))
    (/ pixel-width (/ mm-width 25.4))))
#+end_src

Change global text sizes with this function. This is the function I bind to a key or use in a hydra to change text sizes. It just changes =neh/current-text-size=, then calls my theme-tweak function below to make the changes. It also calls =visual-fill-column-adjust= so that everything ends up the right size.

#+begin_src emacs-lisp
(defun neh/adjust-text-height (adjustment)
  "Adjust text size up or down by ADJUSTMENT."
  (interactive)

  (if (= adjustment 0)
      (setq neh/current-text-size neh/default-text-size)
    (setq neh/current-text-size (+ neh/current-text-size adjustment)))
  (neh/theme-tweaks)
  (visual-fill-column-adjust))
#+end_src

And here’s the function where I collect my tweaks to the theme and set up fonts.

#+begin_src emacs-lisp
(defun neh/theme-tweaks ()
  "Apply my catchall set of mostly appearance tweaks."
  (interactive)

  (unless savehist-loaded
    (savehist-mode 1))

  ;; Workaround so I can use S-SPC as a binding
  ;; https://www.reddit.com/r/emacs/comments/osscfd/pgtk_emacswaylandgnome_no_shiftspace/
  ;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2021-07/msg00071.html
  (when (fboundp 'pgtk-use-im-context)
    (pgtk-use-im-context nil))

  ;; from https://tech.toryanderson.com/2021/09/20/swapping-chords-in-dvorak-or-why-does-emacs-keyboard-translate-fail-with-wrong-type-argument-characterp-134217845/
  ;;https://www.reddit.com/r/emacs/comments/xuc4km/switching_cu_and_cx/
  ;; (keyboard-translate ?\C-u ?\C-x)
  ;; (keyboard-translate ?\C-x ?\C-u)

  ;; Set the default text size based on the monitor DPI
  (let* ((dpi (monitor-dpi))
         (size (cond ((< dpi 110) 125)
                     ((< dpi 160) 150))))
    (setq neh/default-text-size size))

  (when (not (boundp 'neh/current-text-size))
    (setq neh/current-text-size neh/default-text-size))

  (let* ((variable-tuple (cond
                          ;; ((x-list-fonts "Iosevka Etoile")
                          ;;  `(:family "Iosevka Etoile"
                          ;;    :height ,(round (* neh/current-text-size 1.04))))
                          ((x-list-fonts "Roboto")
                           `(:family "Roboto"
                             :height 162))
                          ((x-list-fonts "ETBembo")
                           `(:family "ETBembo" :height ,(round (* neh/current-text-size 1.23))))
                          ((x-list-fonts "Inter")
                           `(:family "Inter"
                             :height ,(round (* neh/current-text-size 1.01))))
                          ((x-list-fonts "Noto Sans")
                           `(:family "Noto Sans"
                             :height ,(round (* neh/current-text-size 1.01))))
                          ((x-list-fonts "DejaVu Sans")
                           `(:family "DejaVu Sans"
                             :height ,(round (* neh/current-text-size 0.945))))
                          ((x-family-fonts "Sans Serif")
                           `(:family "Sans Serif"))
                          (nil (warn "Cannot find a variable width font."))))
         (fixed-tuple (cond
                       ;; ((x-list-fonts "Iosevka Curly Slab")
                       ;;  `(:family "Iosevka Curly Slab"
                       ;;    :height ,(round (* neh/current-text-size 1.04))
                       ;;    ))
                       ;; ((x-list-fonts "Iosevka Slab")
                       ;;  `(:family "Iosevka Slab"
                       ;;    :height ,(round (* neh/current-text-size 1.04))))
                       ((x-list-fonts "Iosevka")
                        `(:family "Iosevka"
                          :height ,(round (* neh/current-text-size 1.04))))
                       ((x-family-fonts "Monospace")
                        '(:family "Monospace"))
                       (nil (warn "Cannot find a fixed width font.")))))

    (custom-theme-set-faces
     'user
     `(default ((t (,@fixed-tuple))))
     `(fixed-pitch ((t (,@fixed-tuple))))
     `(variable-pitch ((t (,@variable-tuple))))))

  (set-face-italic 'font-lock-comment-face t)

  (set-face-foreground 'org-hide (face-background 'default))

  ;; for org-modern
  (set-face-background 'fringe (face-attribute 'default :background))

  ;; (set-face-attribute 'mode-line nil :height 1.0)
  ;; (set-face-attribute 'mode-line-inactive nil :height 1.0)

  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (when (equal major-mode 'org-mode)
              (font-lock-fontify-buffer)))
          (buffer-list)))

  (set-scroll-bar-mode nil)
  )
#+end_src

#+begin_src emacs-lisp
(use-package fontaine
  :commands (fontaine-set-preset)
  :custom
  (fontaine-font-families '((default "Iosevka Curly Slab" "Iosevka")
                            (fixed-pitch)
                            (variable-pitch "ETBembo")))
  (fontaine-presets `(
                      (normal-calc
                       :default-height ,(round (* neh/current-text-size 1.04))
                       :fixed-pitch-height ,(round (* neh/current-text-size 1.04))
                       :variable-pitch-height ,(round (* neh/current-text-size 1.23)))
                      (normal-fixed
                       :default-height 158
                       :fixed-pitch-height 158
                       :variable-pitch-height 162
                       ;; :variable-pitch-height 184
                        )
                      (large
                       :default-height 203
                       :fixed-pitch-height 203
                       :variable-pitch-height 240)
                      (t
                       :default-family "Iosevka Slab"
                       :default-weight normal
                       :variable-pitch-family "Roboto"
                       :line-spacing 0.2)
                      )))
#+end_src

* Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook ((after-init . doom-modeline-mode)
         (after-change-major-mode . doom-modeline-conditional-buffer-encoding))

  :custom-face
  (doom-modeline-evil-emacs-state
   ((t (:background "DarkMagenta" :foreground "#ffd700"))))
  (doom-modeline-evil-insert-state
   ((t (:background "#ffd700" :foreground "#000000"))))
  (doom-modeline-evil-motion-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-normal-state
   ((t (:background "ForestGreen" :foreground "#ffffff"))))
  (doom-modeline-evil-operator-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-visual-state
   ((t (:background "#fe8019" :foreground "#000000"))))
  (doom-modeline-evil-replace-state
   ((t (:background "red4" :foreground "#ffffff"))))

  :custom
  (doom-modeline-height 34)
  (doom-modeline-bar-width 1)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (column-number-mode t)

  :init
  (defun doom-modeline-conditional-buffer-encoding ()
    "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
    (setq-local doom-modeline-buffer-encoding
                (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                            (eq buffer-file-coding-system 'utf-8)))))

  :config
  (setq-default doom-modeline-column-zero-based nil))
#+end_src

* Eeeeevil

I come from vim, so evil is a necessity.

#+begin_src emacs-lisp :noweb yes
(use-package evil
  :demand t
  :after general

  :custom
  (evil-move-cursor-back t)
  (evil-vsplit-window-right t)

  :init
  (setq evil-want-integration t
        evil-want-keybinding nil
        evil-want-minibuffer t
        evil-respect-visual-line-mode nil)

  :general
  <<evil-general>>

  :config
  (evil-mode 1)
  <<evil-config>>

  (use-package evil-surround
    :config
    (global-evil-surround-mode t))

  (use-package evil-embrace
    :after (evil
            evil-surround
            org)
    :hook (org-mode . embrace-org-mode-hook)
    :config
    (evil-embrace-enable-evil-surround-integration))

  (use-package evil-indent-plus
    :config
    (evil-indent-plus-default-bindings))

  (use-package evil-textobj-line)
  (use-package evil-textobj-syntax)
  (use-package evil-ex-fasd))
#+end_src

I'm one of those strange people that not only uses a dvorak keyboard layout and vim-style navigation, but also moves =hjkl= to =htns=, because I like the physical location. In practice, I don't have to adjust /that/ many other keys for this to work. Here I set up the basic navigation keys and make related adjustments.

#+begin_src emacs-lisp :noweb-ref evil-general :tangle no
(general-define-key
 :states '(normal visual motion)
 "j" nil
 "k" nil

 "h" 'evil-backward-char
 "t" 'evil-next-visual-line
 "n" 'evil-previous-visual-line
 "s" 'evil-forward-char

 "<down>" 'evil-next-visual-line
 "<up>" 'evil-previous-visual-line

 "l" 'evil-search-next
 "L" 'evil-search-previous
 "S" 'evil-window-bottom
 )
#+end_src

And here are just general evil-related bindings.

#+begin_src emacs-lisp :noweb-ref evil-general :tangle no
(neh/leader-keys
  "q" #'kill-current-buffer)
#+end_src

Put some whitespace around the evil state modeline labels just so they look better.

#+begin_src emacs-lisp :noweb-ref evil-config :tangle no
(setq evil-normal-state-tag   (propertize " N ")
      evil-emacs-state-tag    (propertize " E ")
      evil-insert-state-tag   (propertize " I ")
      evil-replace-state-tag  (propertize " R ")
      evil-motion-state-tag   (propertize " M ")
      evil-visual-state-tag   (propertize " V ")
      evil-operator-state-tag (propertize " O "))
#+end_src

So many searches leave the cursor at the bottom of the window, and I want to see more context. So this recenters the cursor when jumping to a search result. I've been using swiper a lot more though, so I'm not sure how much I care about this any more (at least in this context).

#+begin_src emacs-lisp :noweb-ref evil-config :tangle no
;; (general-add-advice (list #'evil-search-next
;;                           #'evil-search-previous)
;;                     :after #'recenter)
#+end_src

This defines an evil operator I can use to highlight some text and quickly get an indirect buffer narrowed to that text.

#+begin_src emacs-lisp :noweb-ref evil-config :tangle no
(evil-define-operator evil-narrow-indirect (beg end type)
  "Indirectly narrow the region from BEG to END."
  (interactive "<R>")
  (evil-normal-state)
  (narrow-to-region-indirect beg end))

(general-define-key
 :keymaps 'narrow-map
 "i" #'evil-narrow-indirect)
#+end_src

Evil-collection helps with setting up evil-friendly bindings all over the place, including the handy key translation feature I use here for my crazy =hjkl =-> =htns= ways.

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil

  :custom
  (evil-collection-outline-bind-tab-p nil)
  (evil-collection-setup-minibuffer t)

  :init
  (defun neh/evil-key-translations (_mode mode-keymaps &rest _rest)
    (evil-collection-translate-key 'normal mode-keymaps
      "t" "j"
      "n" "k"
      "s" "l"))

  :config
  (evil-collection-init)
  (add-hook 'evil-collection-setup-hook #'neh/evil-key-translations))
#+end_src

#+begin_src emacs-lisp
(use-package evil-owl
  :commands (evil-owl-mode)
  :custom
  (evil-owl-extra-posframe-args '(:internal-border-width 2
                                  :internal-border-color "grey"))
  (evil-owl-idle-delay 0.5))
#+end_src

* Navigation?

I used ivy and friends for a quite a while here, mostly because helm didn't really make sense to me when I started using emacs, and ivy did. So I quickly got a configuration together that worked for me, and enjoyed using ivy, swiper, counsel etc. but I never really put a lot of effort into understanding what I had. Occasionally I would rework some part of it, but I mostly left it alone.

I was interested when the "new tools" like vertico, and orderless, and then consult, marginalia, and embark started showing up and looked like a nice composable, understandable set of functionality I could assemble the way I wanted to. So that's what I have here now.

** Vertico

Let's start with vertico, as it's the interface to most of the rest here. I tried icomplete-vertical for a few days first, and then tried selectrum, and now vertico.

#+begin_src emacs-lisp
(use-package vertico
  :straight (:files (:defaults "extensions/*"))

  :init
  (vertico-mode t)
  (vertico-mouse-mode t)

  :custom
  (vertico-count 20)

  :general
  (:keymaps 'vertico-map
   :states '(insert normal)
   "C-t" #'vertico-next
   "C-n" #'vertico-previous
   "C-S-t" #'vertico-next-group
   "C-S-n" #'vertico-previous-group
   "C-S-<down>" #'vertico-next-group
   "C-S-<up>" #'vertico-previous-group
   "<backtab>" #'vertico-insert
   )
  )

(use-package vertico-directory
  :after vertico
  :straight nil

  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)

  :general
  (:keymaps 'vertico-map
   "TAB" #'neh/file-or-not
   "RET" #'vertico-directory-enter
   "DEL" #'vertico-directory-delete-char
   "M-DEL" #'vertico-directory-delete-word)

  :init
  (defun neh/file-or-not ()
    (interactive)
    (when (eq 'file (vertico--metadata-get 'category))
      (minibuffer-complete))
    (vertico-insert))
  )

(use-package vertico-multiform
  :after vertico
  :straight nil
  :init
  (vertico-multiform-mode t)
  (setq vertico-multiform-categories
        '((file
           buffer
           (vertico-buffer-display-action . (display-buffer-same-window)))
          ;; (t reverse)
          ))
  (setq vertico-multiform-commands
        '(
          ;; (consult-ripgrep
           ;; buffer
           ;; (vertico-buffer-display-action . (display-buffer-same-window))
           ;; )
          ))
  )

(use-package vertico-repeat
  :after vertico
  :straight nil
  :hook (minibuffer-setup . vertico-repeat-save)
  ;; needs a keybinding
  )

(use-package vertico-reverse
  :after vertico
  :straight nil
  :general
  (:keymaps 'vertico-reverse-map
   :states '(insert normal)
   "C-n" #'vertico-next
   "C-t" #'vertico-previous
   "C-S-n" #'vertico-next-group
   "C-S-t" #'vertico-previous-group
   ))
#+end_src

** Orderless

Faster narrowing of a list of candidates matters, and orderless is a nice straightforward way to get it.

#+begin_src emacs-lisp
(use-package orderless
  :demand t

  :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (pattern index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
     ;; File extensions
     ((and
       ;; Completing filename or eshell
       (or minibuffer-completing-file-name
           (derived-mode-p 'eshell-mode))
       ;; File extension
       (string-match-p "\\`\\.." pattern))
      `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x200000-\x300000]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 1))
        (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  :custom
  (completion-styles '(substring orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles substring partial-completion))
                                   (command (styles +orderless-with-initialism))
                                   (variable (styles +orderless-with-initialism))
                                   (symbol (styles +orderless-with-initialism))))
  (orderless-component-separator #'orderless-escapable-split-on-space)
  (orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** Marginalia

There's plenty of useful extra information that can be attached to each candidate in a list, and marginalia does a great job with it.

#+begin_src emacs-lisp
(use-package marginalia
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init
  (marginalia-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :after (marginalia
          all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))
#+end_src

** Embark

One of the really nice bits here is embark. I haven't really exploited it yet, but it's a great way to launch different actions on candidates in vertico, or pretty much anywhere in emacs.

#+begin_src emacs-lisp
(use-package embark
  :demand t

  :custom
  (prefix-help-command #'embark-prefix-help-command)
  (embark-help-key (kbd "?"))
  (embark-cycle-key (kbd "C-,"))
  (embark-mixed-indicator-delay 0.8)
  (y-or-n-p-use-read-key t)

  :general
  ("C-," #'embark-act)
  (:keymaps 'embark-file-map
   "s" #'neh/consult-ripgrep-from-dir
   "F" #'find-file-other-frame
   "x" #'neh/dired-open)
  (:keymaps 'embark-symbol-map
   "g" #'consult-ripgrep)
  (:keymaps 'embark-url-map
   "." #'hydra-browse/body)
  (:keymaps 'embark-buffer-map
   "F" #'switch-to-buffer-other-frame)

  :init
  ;; stolen from https://github.com/oantolin/embark/issues/252
  ;; and an assist from https://github.com/oantolin/embark/issues/42
  (defun neh/consult-ripgrep-from-dir (file)
    "Jump into consult-ripgrep from embark."
    (interactive "fRipgrep from dir:")
    (consult-ripgrep (file-name-directory file)))

  :config
  ;; from https://github.com/oantolin/embark/issues/250#issuecomment-866244100
  (defvar neh/embark-org-link-type-alist nil
    "An (LINK-TYPE . ACTION-TYPE) alist to determine which link types has its own embark actions.

See `my/embark-target-org-link'.

LINK-TYPE is a string of the part before the colon in an org link.
ACTION-TYPE is a symbol and should be a key in embark-keymap-alist.")

  (defun embark-target-org-link ()
    (when (string= major-mode 'org-mode)
      (when-let ((context (org-element-context)))
        (when (eq (car context) 'link)
          (let ((type (plist-get (cl-second context) :type))
                (path (plist-get (cl-second context) :path))
                (url (plist-get (cl-second context) :raw-link))
                (begin (plist-get (cl-second context) :begin))
                (end (plist-get (cl-second context) :end)))
            (if-let ((matched-type (alist-get type neh/embark-org-link-type-alist
                                              nil
                                              nil
                                              #'string=)))
                (cons matched-type path)
              `(url ,url ,begin . ,end)))))))
  (add-to-list 'embark-target-finders #'embark-target-org-link)

  (defun embark-target-org-timestamp ()
    "Target the org timestamp at point."
    (when (and (string= major-mode 'org-mode)
               (org-at-timestamp-p 'inactive))
      (let ((tsprops (cl-second (org-element-context))))
        `(org-timestamp
          ,(plist-get tsprops :raw-value)
          ,(plist-get tsprops :begin) . ,(plist-get tsprops :end)))))
  (add-to-list 'embark-target-finders #'embark-target-org-timestamp)

  (embark-define-keymap embark-org-timestamp-map
    "Actions for org mode timestamps."
    :parent embark-general-map
    ("T" org-toggle-timestamp-type))
  (add-to-list 'embark-keymap-alist '(org-timestamp . embark-org-timestamp-map))

  (defun embark-target-org-heading ()
    "Target the heading at point."
    (when (org-at-heading-p)
      `(heading
        ,(org-get-heading)
        ,(line-beginning-position) . ,(line-end-position))))
  (add-to-list 'embark-target-finders #'embark-target-org-heading)

  (embark-define-keymap embark-heading-map
    "Actions for org mode headings."
    :parent embark-general-map
    ("I" org-id-get-create)
    ("l" org-store-link))
  (add-to-list 'embark-keymap-alist '(heading . embark-heading-map))
  )

(use-package avy-embark-collect
  :commands (avy-embark-collect-act
             avy-embark-collect-choose))
#+end_src

** Consult

Consult takes over for a lot of what counsel did, as well as swiper.

#+begin_src emacs-lisp
(use-package consult
  :init
  (fset 'multi-occur #'consult-multi-occur)

  (defun neh/roam-rg ()
    "Search org-roam notes with ripgrep."
    (interactive)
    (if (boundp 'org-roam-directory)
        (let ((initial (if (use-region-p)
                           (buffer-substring-no-properties (region-beginning) (region-end))
                         nil)))
          (consult-ripgrep org-roam-directory initial))
      (message "Org-roam notes are not available.")))

  (defun neh/consult-buffer-dwim ()
    "Narrow consult-buffer to current project if there is one."
    (when (eq this-command #'consult-buffer)
      (when (consult--project-root)
        (setq unread-command-events (append unread-command-events (list ?p 32))))))
  (add-hook 'minibuffer-setup-hook #'neh/consult-buffer-dwim)

  (defun consult-line-thing-at-point ()
    "Start consult-line with thing-at-point as initial input."
    (interactive)
    (let ((initial (if (use-region-p)
                       (progn (buffer-substring-no-properties (region-beginning) (region-end))
                              (deactivate-mark))
                     (thing-at-point 'symbol))))
      (consult-line initial)))

  (defun neh/consult-line-again ()
    "Repeat the last consult-line search."
    (interactive)
    (consult-line (car consult--line-history)))

  :general
  ;; ([remap evil-search-forward] #'consult-line)
  (neh/leader-keys
    "l" #'consult-line
    "L" #'neh/consult-line-again
    "oo" #'consult-buffer
    "of" #'find-file
    "ha" #'consult-apropos
    "s*" #'consult-line-thing-at-point
    "sa" #'consult-org-agenda
    "sf" #'consult-ripgrep
    "sg" #'consult-git-grep
    "sn" #'neh/roam-rg
    "so" #'consult-org-heading
    "st" #'consult-imenu)
  (:keymaps 'embark-buffer-map
   "F" #'consult-buffer-other-frame)
  (:keymaps 'embark-file-map
   "X" #'consult-file-externally)
  :custom
  (consult-narrow-key "<")
  :config
  (setq consult-project-root-function #'projectile-project-root))

(use-package embark-consult)
#+end_src

#+begin_src emacs-lisp
(use-package consult-dir
  :commands (consult-dir
             consult-dir-jump-file)
  :general
  (neh/leader-keys
    "d" #'consult-dir)
  (:keymaps 'vertico-map
   "M-d" #'consult-dir
   "M-j" #'consult-dir-jump-file)
  :custom
  (consult-dir-project-list-function #'consult-dir-projectile-dirs))
#+end_src

#+begin_src emacs-lisp
(use-package consult-org-roam
  :after (consult
          org-roam)
  :commands (consult-org-roam-mode
             consult-org-roam-search
             consult-org-roam-backlinks
             consult-org-roam-file-find)
  :custom
  (consult-org-roam-buffer-after-buffers t)
  (consult-org-roam-grep-func #'consult-ripgrep))
#+end_src

#+begin_src emacs-lisp
(use-package consult-jump-project
  :straight (consult-jump-project
             :type git
             :host github
             :repo "jdtsmith/consult-jump-project")
  :commands (consult-jump-project))
#+end_src

#+begin_src emacs-lisp
(use-package consult-notes
  :commands (consult-notes
             consult-notes-search-in-all-notes
             consult-notes-org-roam-find-node
             consult-notes-org-roam-find-node-relation)
  :config
  (setq consult-notes-sources `(("Notes"  ?n  ,org-roam-directory)))
  (consult-notes-org-roam-mode))
#+end_src

** Corfu

#+begin_src emacs-lisp :lexical no
(use-package corfu
  :init
  (global-corfu-mode)
  :general
  (:keymaps 'corfu-map
   :states 'insert
   "<tab>" #'corfu-next
   "C-t" #'corfu-next
   "C-n" #'corfu-previous))
#+end_src

#+begin_src emacs-lisp
(use-package kind-icon
  :after  corfu
  :custom
  (kind-icon-default-face 'corfu-default)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

** Avy

Avy is a really handy way to jump around your visible buffer contents. One aspect that doesn’t seem to really be documented is the avy-actions mechanism. It lets you do things other than just jump to the point you select. So you can hit the key for whichever avy function you like, then, /before/ making your selection, press the key associated with an avy-action function to do that thing instead. This way, you can easily copy a word from elsewhere on your screen and paste it at your cursor with avy, no cursor movement needed at all. Also, =avy-copy-line= is a useful standalone function. I find it useful particularly when working in Terraform files, as lines need to be duplicated fairly often there.

#+begin_src emacs-lisp
(use-package avy
  :general
  (neh/leader-nav
   "j" #'avy-goto-char-2
   ;; "c" #'avy-goto-char-timer
   ;; "h" #'avy-org-goto-heading-timer
   ;; "l" #'avy-goto-line
   )

  (neh/leader-keys
    "cl" 'avy-copy-line)

  :custom
  (avy-dispatch-alist '((?y . avy-action-copy)
                        (?m . avy-action-teleport)
                        (?c . (lambda (pt)
                                (avy-action-copy pt)
                                (if (evil-insert-state-p)
                                    (progn (evil-paste-before 1)
                                           (evil-forward-char))
                                  (evil-paste-after 1))))
                        (?k . avy-action-kill-move)
                        (?K . avy-action-kill-stay)
                        (?M . avy-action-mark)))

  (avy-keys '(?a ?o ?e ?u ?h ?t ?n ?s))
  (avy-line-insert-style 'below))
#+end_src

** Buffers

#+begin_src emacs-lisp
(use-package nswbuff
  :general
  (:keymaps 'override
   :states '(emacs normal insert)
   "C-M-<tab>" 'nswbuff-switch-to-previous-buffer
   "C-M-<iso-lefttab>" 'nswbuff-switch-to-next-buffer
   )

  :custom
  (nswbuff-buffer-list-function #'nswbuff-projectile-buffer-list)
  (nswbuff-status-window-layout 'scroll)
  (nswbuff-display-intermediate-buffers t)
  (nswbuff-recent-buffers-first t)
  (nswbuff-exclude-buffer-regexps '("^ "
                                    "^\*.*\*"
                                    "^magit.*:.+"))
  (nswbuff-include-buffer-regexps '("^*Org Src"))
  )
#+end_src

#+begin_src emacs-lisp
(use-package ibuffer
  :straight nil
  :hook (ibuffer-mode . ibuffer-auto-mode)
  :custom
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-formats
   '((mark modified read-only locked " "
           (name 18 18 :left :elide)
           " "
           (size 9 -1 :right)
           " "
           (mode 16 16 :left :elide)
           " " project-relative-file)
     (mark " "
           (name 16 -1)
           " " filename))))

(use-package ibuffer-projectile
  :commands (ibuffer-projectile-set-filter-groups)
  :hook ((ibuffer . (lambda ()
                      (ibuffer-projectile-set-filter-groups)
                      )))
  :init
  (defun neh/ibuffer-magit ()
    "Open `magit-status' for the current buffer."
    (interactive)
    (let ((buf (ibuffer-current-buffer t)))
      (magit-status (cdr (ibuffer-projectile-root buf))))))
#+end_src

#+begin_src emacs-lisp
(use-package pulse
  :straight nil
  :defer 0.5
  :config
  ;; stolen from https://blog.meain.io/2020/emacs-highlight-yanked/
  (defun meain/evil-yank-advice (orig-fn beg end &rest args)
    (pulse-momentary-highlight-region beg end)
    (apply orig-fn beg end args))
  (advice-add 'evil-yank :around 'meain/evil-yank-advice))
#+end_src

#+begin_src emacs-lisp
(use-package scrollkeeper
  :disabled
  :custom
  (scrollkeeper-scroll-steps 1)
  (scrollkeeper-scroll-distance 0.85)
  (scrollkeeper-guideline-pulse-interval 0.07)
  (scrollkeeper-guideline-fn #'scrollkeeper--highlight)
  :custom-face
  (scrollkeeper-guideline-highlight ((t (:background "Orange" :extend t))))
  :general
  ([remap scroll-up-command] #'scrollkeeper-down)
  ([remap scroll-down-command] #'scrollkeeper-up)
  ([remap evil-scroll-up] #'scrollkeeper-up)
  ([remap evil-scroll-down] #'scrollkeeper-down)
  ([remap evil-scroll-page-up] #'scrollkeeper-up)
  ([remap evil-scroll-page-down] #'scrollkeeper-down))
#+end_src

#+begin_src emacs-lisp
;; from https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/
;;; -*- lexical-binding: t; -*-

;; we will call `blink-matching-open` ourselves...
(remove-hook 'post-self-insert-hook
             #'blink-paren-post-self-insert-function)
;; this still needs to be set for `blink-matching-open` to work
(setq blink-matching-paren 'show)

(let ((ov nil)) ; keep track of the overlay
  (advice-add
   #'show-paren-function
   :after
    (defun show-paren--off-screen+ (&rest _args)
      "Display matching line for off-screen paren."
      (when (overlayp ov)
        (delete-overlay ov))
      ;; check if it's appropriate to show match info,
      ;; see `blink-paren-post-self-insert-function'
      (when (and (overlay-buffer show-paren--overlay)
                 (not (or cursor-in-echo-area
                          executing-kbd-macro
                          noninteractive
                          (minibufferp)
                          this-command))
                 (and (not (bobp))
                      (memq (char-syntax (char-before)) '(?\) ?\$)))
                 (= 1 (logand 1 (- (point)
                                   (save-excursion
                                     (forward-char -1)
                                     (skip-syntax-backward "/\\")
                                     (point))))))
        ;; rebind `minibuffer-message' called by
        ;; `blink-matching-open' to handle the overlay display
        (cl-letf (((symbol-function #'minibuffer-message)
                   (lambda (msg &rest args)
                     (let ((msg (apply #'format-message msg args)))
                       (setq ov (display-line-overlay+
                                 (window-start) msg ))))))
          (blink-matching-open))))))

(defun display-line-overlay+ (pos str &optional face)
  "Display line at POS as STR with FACE.

FACE defaults to inheriting from default and highlight."
  (let ((ol (save-excursion
              (goto-char pos)
              (make-overlay (line-beginning-position)
                            (line-end-position)))))
    (overlay-put ol 'display str)
    (overlay-put ol 'face
                 (or face '(:inherit default :inherit highlight)))
    ol))
#+end_src

#+begin_src emacs-lisp
(use-package highlight-parentheses
  :hook (prog-mode . highlight-parentheses-mode)
  :custom
  (highlight-parentheses-colors '("red2" "DarkOrange1" "goldenrod2" "IndianRed4"))
  (highlight-parentheses-attributes '((:weight ultra-bold)
                                      (:weight ultra-bold)
                                      (:weight ultra-bold)
                                      (:weight ultra-bold))))
#+end_src

#+begin_src emacs-lisp
(use-package bufler
  :commands (bufler
             bufler-mode
             bufler-switch-buffer
             bufler-list
             bufler-workspace-frame-set))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package burly
  :commands (burly-bookmark-frames
             burly-bookmark-windows
             burly-open-bookmark
             burly-open-last-bookmark))
#+end_src

* Snippets

#+begin_src emacs-lisp
(use-package yasnippet
  :hook (org-mode . yas-minor-mode)
  :custom
  (yas-snippet-dirs `(,(concat user-emacs-directory "snippets"))))
#+end_src

* Projects

#+begin_src emacs-lisp
(use-package project
  :straight nil
  :custom
  (project-switch-commands '((project-find-file "Find file" ?f)
                             (project-find-regexp "Find regexp" ?r)
                             (project-find-dir "Find directory" ?d)
                             (project-dired "Root" ?D)
                             (magit-project-status "Git" ?g)
                             (project-vc-dir "VC-Dir")
                             (project-eshell "Eshell"))
                           ))
#+end_src

#+begin_src emacs-lisp
(use-package projectile
  :commands (projectile-project-root
             projectile-mode
             projectile-project-p)
  :custom
  (projectile-completion-system 'auto)

  :general
  (neh/leader-keys
    "op" #'projectile-switch-project
    "oh" #'projectile-find-file-dwim
    "pg" #'projectile-ripgrep)

  :config
  (setq frame-title-format
        '(""
          (:eval
           (if (and (bound-and-true-p org-roam-directory)
                    (bound-and-true-p buffer-file-name)
                    (s-contains-p (expand-file-name org-roam-directory)
                                  (file-name-directory buffer-file-name)))
               (replace-regexp-in-string ".*/[0-9]*-?" "✎ " buffer-file-name)
             "%b"))
          (:eval
           (let ((project-name (projectile-project-name)))
             (unless (string= "-" project-name)
               (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
  (projectile-mode t))
#+end_src

* Git

I find that diff-hl does a better job of showing diff information than git-gutter does. I’d like to use =diff-hl-flydiff-mode=, but it caused issues, which I can’t remember well enough to document now. Will revisit later.

#+begin_src emacs-lisp
(use-package diff-hl
  :hook ((diff-hl-mode . diff-hl-flydiff-mode)
         (dired-mode . diff-hl-dired-mode))
  :commands (diff-hl-mode
             diff-hl-flydiff-mode
             diff-hl-update)
  :general
  (neh/leader-keys
    "vD" #'diff-hl-mode)
  (general-define-key
   :states '(normal visual)
    "gG" #'diff-at-point-open-and-goto-hunk
    ;; find better hunk nav bindings, these conflict/get overridden
    "gp" #'diff-hl-previous-hunk
    "gn" #'diff-hl-next-hunk
    "gs" #'diff-hl-show-hunk
    "gS" #'diff-hl-stage-current-hunk)
  :init
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  (advice-add 'vc-refresh-state :after #'diff-hl-update)
  :custom-face
  (diff-hl-change ((t (:foreground "#222222" :background "#ffd700"))))
  (diff-hl-insert ((t (:foreground "dark green" :background "ForestGreen"))))
  (diff-hl-delete ((t (:foreground "dark red" :background "red4")))))
#+end_src

Diff-hl may be better at /showing/ diff info, but git-gutter is better at doing things with diffs. So I have it active for navigation and staging actions. It’s disabled in org mode because I had issues with it before. Now that my config is in org though, it would be handy to have back. Another TODO.

#+begin_src emacs-lisp
(use-package git-gutter
  :disabled
  :hook (prog-mode . git-gutter-mode)
  :general
  (general-define-key
   :states '(normal visual)
   "gp" 'git-gutter:previous-hunk
   "gn" 'git-gutter:next-hunk
   "gs" 'git-gutter:popup-hunk
   "gS" 'git-gutter:stage-hunk
   "gU" 'git-gutter:revert-hunk)

  :custom-face
  (git-gutter:modified ((t (:foreground "DeepSkyBlue2"))))
  (git-gutter:added ((t (:foreground "ForestGreen"))))
  (git-gutter:deleted ((t (:foreground "red4"))))

  :custom
  (git-gutter:disabled-modes '(org-mode))

  (git-gutter:added-sign "")
  (git-gutter:deleted-sign "")
  (git-gutter:modified-sign "")
  (git-gutter:ask-p nil)

  :init
  (global-git-gutter-mode -1)

  :config
  (advice-add 'git-gutter:previous-hunk :after #'neh/after-jump)
  (advice-add 'git-gutter:next-hunk :after #'neh/after-jump))
#+end_src

#+begin_src emacs-lisp
(use-package transient
  :custom
  (transient-display-buffer-action
   '(display-buffer-below-selected
     (dedicated . t)
     (inhibit-same-window . t)
     (window-parameters
      (no-other-window . t))))
  )
#+end_src

Of course, the great magit.

#+begin_src emacs-lisp
(straight-use-package 'magit)
(use-package magit
  :straight nil
  :hook
  (git-commit-mode . evil-insert-state)

  :custom
  (magit-commit-show-diff t)
  (magit-diff-refine-hunk t)
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)

  :general
  (general-define-key
   :keymaps 'magit-mode-map
   "C-b" 'evil-scroll-page-up
   "C-f" 'evil-scroll-page-down
   "M-h" 'magit-section-up
   "M-s" 'magit-section-goto-successor
   "M-t" 'magit-section-forward-sibling
   "M-n" 'magit-section-backward-sibling
   "M-<down>" 'magit-section-forward-sibling
   "M-<up>" 'magit-section-backward-sibling
   "t" 'evil-next-visual-line
   "n" 'evil-previous-visual-line)

  (general-define-key
   :keymaps 'magit-diff-mode-map
   "/" 'evil-search-forward
   "l" 'evil-search-next
   "L" 'evil-search-previous)

  (neh/leader-keys
    "gf" #'magit-file-dispatch
    "gg" #'magit-dispatch
    "gs" #'magit-status-here))
#+end_src

“Forge” can talk to sites like github and provide tools to work with PRs etc. Installing dependencies manually for now [[https://github.com/raxod502/straight.el/issues/336][because]].

#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

Handy package to browse to git repo web interfaces.
#+begin_src emacs-lisp
(use-package git-link
  :commands (git-link
             git-link-commit
             git-link-homepage)
  :general
  (neh/leader-keys
    "gB" 'git-link
    "gC" 'git-link-commit
    "gH" 'git-link-homepage)
  :custom
  (git-link-open-in-browser t))
#+end_src

#+begin_src emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine
             git-timemachine-toggle))
#+end_src

#+begin_src emacs-lisp
(use-package abridge-diff
  :after magit
  :init
  (abridge-diff-mode 1))
#+end_src

* Org

My org config is pretty long, so I've broken it up for easier reading and explanation. The main structure of it is here, with the details following.

#+begin_src emacs-lisp :noweb yes
(use-package org
  :ensure org-plus-contrib
  :hook (
         <<org-hooks>>)

  :general
  <<org-keys>>
  (:keymaps 'org-mode-map
   "C-c C-l" #'neh/org-insert-link-dwim)

  :custom
  <<org-custom>>

  :init
  <<org-init>>
  (defun neh/org-hide-all-drawers ()
    (org-cycle-hide-drawers 'all))

  (defun neh/config-tangle ()
    (interactive)
    (let ((gc-cons-threshold most-positive-fixnum))
      (org-babel-tangle)))

  ;; stolen from https://xenodium.com/emacs-dwim-do-what-i-mean/
  (defun neh/org-insert-link-dwim ()
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
             (delete-region (region-beginning) (region-end))
             (insert (org-make-link-string clipboard-url region-content)))
            ((and clipboard-url (not point-in-link))
             (insert (org-make-link-string
                      clipboard-url
                      (read-string "title: "
                                   (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                     (dom-text (car
                                                (dom-by-tag (libxml-parse-html-region
                                                             (point-min)
                                                             (point-max))
                                                            'title))))))))
            (t
             (call-interactively 'org-insert-link)))))

  (add-to-list 'org-modules 'org-protocol)
  (add-to-list 'org-modules 'org-habit)
  (add-to-list 'org-modules 'org-id)

  ;; Original version stolen from https://emacs.stackexchange.com/questions/23870/org-babel-result-to-a-separate-buffer
  (defun neh/babel-to-buffer ()
    "A function to efficiently feed babel code block result to a separate buffer"
    (interactive)
    (let ((revert-without-query '(".*"))
          (myframe (selected-frame)))
      (org-babel-open-src-block-result)
      (org-babel-remove-result)
      (sleep-for 0.1)
      (select-frame-set-input-focus myframe)))

  (defun neh/babel-to-buffer-from-narrow ()
    (interactive)
    (org-src-do-at-code-block '(neh/babel-to-buffer))
    )

  (defun neh/toggle-local-emphasis-markers ()
    "Toggle visibility of org emphasis markers."
    (interactive)
    (setq-local org-hide-emphasis-markers (if org-hide-emphasis-markers nil t))
    (font-lock-fontify-buffer))

  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:"
            (org-id-get-with-outline-path-completion org-refile-targets)))

  (let* ((headline      `(:inherit variable-pitch :weight bold))
         )

    (custom-theme-set-faces
     'user
     `(org-ellipsis ((t (:inherit variable-pitch :underline nil))))
     `(org-tag ((t (:inherit default :underline nil :height 0.85))))

     `(org-indent ((t (:inherit (org-hide fixed-pitch)))))
     `(org-code ((t (:inherit fixed-pitch))))
     `(org-table ((t (:inherit fixed-pitch))))
     `(org-verbatim ((t (:inherit fixed-pitch))))
     `(org-block ((t (:inherit fixed-pitch))))

     `(org-level-8 ((t (,@headline :height 1.10))))
     `(org-level-7 ((t (,@headline :height 1.10))))
     `(org-level-6 ((t (,@headline :height 1.10))))
     `(org-level-5 ((t (,@headline :height 1.10))))
     `(org-level-4 ((t (,@headline :height 1.10))))
     `(org-level-3 ((t (,@headline :height 1.10))))
     `(org-level-2 ((t (,@headline :height 1.13))))
     `(org-level-1 ((t (,@headline :height 1.20 :underline t :extend t))))

     `(org-document-title ((t (,@headline :height 1.40 :underline nil))))))

  (defmacro my-org-in-calendar (command)
    (let ((name (intern (format "my-org-in-calendar-%s" command))))
      `(progn
         (defun ,name ()
           (interactive)
           (org-eval-in-calendar '(call-interactively #',command)))
         #',name)))

  (general-def org-read-date-minibuffer-local-map
    "n" (my-org-in-calendar calendar-backward-day)
    "t" (my-org-in-calendar calendar-forward-day)
    "h" (my-org-in-calendar calendar-backward-week)
    "s" (my-org-in-calendar calendar-forward-week)
    "N" (my-org-in-calendar calendar-backward-month)
    "T" (my-org-in-calendar calendar-forward-month)
    "H" (my-org-in-calendar calendar-backward-year)
    "S" (my-org-in-calendar calendar-forward-year))

  :config
  <<org-config>>
  ;; from https://twitter.com/jay_f0xtr0t/status/982353141386461188
  ;; could be better; will currently keep adding to =org-emphasis-regexp-components=
  (setcar (nthcdr 1 org-emphasis-regexp-components)
          (concat (nth 1 org-emphasis-regexp-components) "s"))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)

  (org-link-set-parameters "id"
                           :complete 'org-id-complete-link)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)
     (css . t)
     (sql . t)
     (sqlite . t)
     (python . t)))

  (define-advice org-edit-src-exit (:after (&rest _args))
    "End up in normal state after editing a src block."
    (evil-normal-state)))
#+end_src

Finally found a package that lets org tables horizontally scroll while leaving the rest of the text alone.

#+begin_src emacs-lisp :lexical no
(use-package phscroll
  :straight (phscroll :type git :host github :repo "misohena/phscroll")
  :after org
  :hook (org-mode . org-phscroll-mode)
  :init
  (setq org-startup-truncated nil)
  :config
  (load "org-phscroll.el"))
#+end_src

Org-mouse enables nice mouse interaction with bits of org like headings and checkboxes.

#+begin_src emacs-lisp
(use-package org-mouse
  :straight nil)
#+end_src


#+begin_src emacs-lisp
(use-package org-id
  :straight nil
  :custom
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package org-attach
  :straight nil
  :after org
  :custom
  (org-attach-id-dir (concat org-directory "/data")))
#+end_src

https://github.com/alphapapa/org-sidebar

#+begin_src emacs-lisp :lexical no
(use-package org-sidebar
  :commands (org-sidebar-tree
             org-sidebar-tree-toggle
             org-sidebar-toggle
             org-sidebar))
#+end_src

Add plantuml for nice text-based diagram generation. I’ll mainly use this in org mode files, generating inline diagrams from src blocks.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :commands (plantuml-mode)
  :mode (("\\.plantuml\\'" . plantuml-mode))
  :custom
  (plantuml-default-exec-mode 'jar)
  (plantuml-jar-path "~/bin/plantuml.jar")
  (plantuml-java-args '("-Djava.awt.headless=true" "-jar")))
  ;; (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))

(use-package ob-plantuml
  :straight nil
  :custom
  (org-plantuml-exec-mode 'jar)
  (org-plantuml-jar-path "~/bin/plantuml.jar")
  :commands
  (org-babel-execute:plantuml))
#+end_src

#+begin_src emacs-lisp
(use-package restclient
  :commands (restclient-mode
             restclient-http-send-current
             restclient-http-send-current-stay-in-window))

(use-package ob-restclient
  :after (restclient)
  :commands
  (org-babel-execute:restclient))
#+end_src

#+begin_src emacs-lisp
(use-package evil-org
  :after (evil org)
  :hook ((org-mode . evil-org-mode)
         (evil-org-mode . (lambda ()
                            (evil-org-set-key-theme)))
         (org-agenda-mode . neh/evil-org-agenda-set-keys))

  :custom
  (evil-org-movement-bindings '((up . "n")
                                (down . "t")
                                (left . "h")
                                (right . "s")))
  (evil-org-key-theme '(navigation
                        insert
                        textobjects
                        additional
                        calendar))

  :config
  (require 'evil-org-agenda)

  ;; This is just a copy/paste/modify of the default evil-org-agenda-set-keys function
  (defun neh/evil-org-agenda-set-keys ()
    "Set motion state keys for `org-agenda'."
    (evil-set-initial-state 'org-agenda-mode 'motion)

    ;; Horizontal movements have little use, thus we can override "f" and "t".
    ;; "w", "b", "e", "ge" and their upcase counterparts are preserved.
    (evil-define-key 'motion org-agenda-mode-map
      ;; Unused keys: D, X

      ;; open
      (kbd "<tab>") 'org-agenda-goto
      (kbd "S-<return>") 'org-agenda-goto
      (kbd "g TAB") 'org-agenda-goto
      (kbd "RET") 'org-agenda-switch-to
      (kbd "M-RET") 'org-agenda-recenter

      (kbd "SPC") 'org-agenda-show-and-scroll-up
      (kbd "<delete>") 'org-agenda-show-scroll-down
      (kbd "<backspace>") 'org-agenda-show-scroll-down

      ;; motion
      "t" 'org-agenda-next-line
      "n" 'org-agenda-previous-line
      "gt" 'org-agenda-next-item
      "gn" 'org-agenda-previous-item
      (kbd "C-t") 'org-agenda-next-item
      (kbd "C-n") 'org-agenda-previous-item
      (kbd "C-h") 'org-agenda-earlier
      (kbd "C-s") 'org-agenda-later

      ;; manipulation
      ;; We follow standard org-mode bindings (not org-agenda bindings):
      ;; <HJKL> change todo items and priorities.
      ;; M-<jk> drag lines.
      ;; M-<hl> cannot demote/promote, we use it for "do-date".
      "T" 'org-agenda-priority-down
      "N" 'org-agenda-priority-up
      "H" 'org-agenda-do-date-earlier
      "S" 'org-agenda-do-date-later
      "!" 'org-agenda-todo
      (kbd "M-t") 'org-agenda-drag-line-forward
      (kbd "M-n") 'org-agenda-drag-line-backward
      (kbd "C-S-h") 'org-agenda-todo-previousset ; Original binding "C-S-<left>"
      (kbd "C-S-s") 'org-agenda-todo-nextset ; Original binding "C-S-<right>"

      ;; undo
      "u" 'org-agenda-undo

      ;; actions
      "dd" 'org-agenda-kill
      "dA" 'org-agenda-archive
      "da" 'org-agenda-archive-default-with-confirmation
      "ct" 'org-agenda-set-tags
      "ce" 'org-agenda-set-effort
      "cT" 'org-timer-set-timer
      "i" 'org-agenda-diary-entry
      "a" 'org-agenda-add-note
      "A" 'org-agenda-append-agenda
      "C" 'org-agenda-capture

      ;; mark
      "m" 'org-agenda-bulk-toggle
      "~" 'org-agenda-bulk-toggle-all
      "*" 'org-agenda-bulk-mark-all
      "%" 'org-agenda-bulk-mark-regexp
      "M" 'org-agenda-bulk-remove-all-marks
      "x" 'org-agenda-bulk-action

      ;; refresh
      "gr" 'org-agenda-redo
      "gR" 'org-agenda-redo-all

      ;; quit
      "ZQ" 'org-agenda-exit
      "ZZ" 'org-agenda-quit

      ;; display
      ;; "Dispatch" can prefix the following:
      ;; 'org-agenda-toggle-deadlines
      ;; 'org-agenda-toggle-diary
      ;; 'org-agenda-follow-mode
      ;; 'org-agenda-log-mode
      ;; 'org-agenda-entry-text-mode
      ;; 'org-agenda-toggle-time-grid
      ;; 'org-agenda-day-view
      ;; 'org-agenda-week-view
      ;; 'org-agenda-year-view
      "z" 'org-agenda-view-mode-dispatch
      "ZD" 'org-agenda-dim-blocked-tasks

      ;; filter
      "sc" 'org-agenda-filter-by-category
      "sr" 'org-agenda-filter-by-regexp
      "se" 'org-agenda-filter-by-effort
      "st" 'org-agenda-filter-by-tag
      "s^" 'org-agenda-filter-by-top-headline
      "ss" 'org-agenda-limit-interactively
      "S" 'org-agenda-filter-remove-all

      ;; clock
      "I" 'org-agenda-clock-in ; Original binding
      "O" 'org-agenda-clock-out ; Original binding
      "cg" 'org-agenda-clock-goto
      "cc" 'org-agenda-clock-cancel
      "cr" 'org-agenda-clockreport-mode

      ;; go and show
      "." 'org-agenda-goto-today ; TODO: What about evil-repeat?
      "gc" 'org-agenda-goto-calendar
      "gC" 'org-agenda-convert-date
      "gd" 'org-agenda-goto-date
      "gh" 'org-agenda-holidays
      "gm" 'org-agenda-phases-of-moon
      "gs" 'org-agenda-sunrise-sunset
      "gt" 'org-agenda-show-tags

      "p" 'org-agenda-date-prompt
      "P" 'org-agenda-show-the-flagging-note

      ;; 'org-save-all-org-buffers ; Original binding "C-x C-s"
      "sa" 'org-save-all-org-buffers

      ;; Others
      "+" 'org-agenda-manipulate-query-add
      "-" 'org-agenda-manipulate-query-subtract)))
#+end_src

A basic start at making different kinds of links look usefully different (eg. it's nice to be able to tell internal org/roam links from web links).

#+begin_src emacs-lisp
;; defface won't update an existing face (fixed in 28.1?), it has to be done like this:
;; (face-spec-set
;;  'neh/org-link
;;  '((t :inherit org-link
;;       :weight normal
;;       :slant italic
;;       ))
;;  'face-defface-spec
;;  )

(defface neh/org-link
  '((t (:inherit org-link :slant italic)))
  "A neh-style link.")

(org-link-set-parameters "http" :face 'neh/org-link)
(org-link-set-parameters "https" :face 'neh/org-link)

;; (org-link-set-parameters "http" :face 'org-link)
;; (org-link-set-parameters "https" :face 'org-link)
#+end_src

Org export.

#+begin_src emacs-lisp
(use-package ox-pandoc
  :ensure-system-package (pandoc
                          pdflatex
                          mktexfmt))

(use-package ox-odt
  :straight nil
  :ensure-system-package zip)

(use-package ox-slack
  :commands (org-slack-export-as-slack
             org-slack-export-to-slack
             org-slack-export-to-clipboard-as-slack))
#+end_src

#+begin_src emacs-lisp
(use-package org-tanglesync
  :disabled
  :hook ((org-mode . org-tanglesync-mode)
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :custom
  (org-tanglesync-watch-files '("emacs.org"))
  :general
  (general-define-key
   :keymaps 'org-mode-map
    "C-c M-i" 'org-tanglesync-process-buffer-interactive
    "C-c M-a" 'org-tanglesync-process-buffer-automatic))
#+end_src

** Options

When using =C-c C-t=, allow todo state selection using single letters instead of cycling through choices. Also, don't let the options appear in a new window. Temporary org windows like this tend to be difficult to position sanely.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-use-fast-todo-selection 'expert)
#+end_src

Org file locations.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-directory "~/org")
(org-default-notes-file (if (boundp 'neh/org-default-notes-file)
                            neh/org-default-notes-file
                          "~/org/incoming.org"))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-refile-targets '((org-agenda-files :maxlevel . 3)))
(org-refile-allow-creating-parent-nodes 'confirm)
(org-refile-use-outline-path 'file)
(org-outline-path-complete-in-steps nil)
(org-reverse-note-order t)
(org-tags-column 0)
#+end_src

This setting should make edits around special characters and collapsed outlines better. I haven't tested the various settings out yet, so this is just the first one to try.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-catch-invisible-edits 'show-and-error)
#+end_src

Just always show images; I always want them.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-startup-with-inline-images t)
(org-image-actual-width nil)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-M-RET-may-split-line '((default . nil)))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-todo-keywords '((sequence "SOMEDAY(m!)"
                               "TODO(t!)"
                               "NEXT(n!)"
                               "DOING(i!)"
                               "INTERRUPT(p!)"
                               "WAITING(w@/!)"
                               "TESTING(s@/!)"
                               "|"
                               "DONE(d!)"
                               "CANCELED(c@)")))

(org-log-into-drawer t)
(org-log-repeat nil)

;; (org-startup-indented t)
;; (org-hide-leading-stars t)
(org-ellipsis " …")
(org-fontify-whole-heading-line t)
(org-fontify-done-headline t)
(org-hide-emphasis-markers t)
(org-pretty-entities t)
(org-cycle-separator-lines 2)
(org-M-RET-may-split-line '((default . nil)))
(org-indirect-buffer-display 'current-window)
(org-use-sub-superscripts nil)

(org-confirm-babel-evaluate nil)
(org-src-fontify-natively t)
(org-src-window-setup 'current-window)
(org-src-tab-acts-natively t)
(org-src-preserve-indentation t)

(org-fontify-whole-block-delimiter-line nil)
(org-fontify-quote-and-verse-blocks t)

(org-plantuml-jar-path "~/bin/plantuml.jar")
#+end_src

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode)
  :general
  (neh/leader-keys
    :keymaps 'org-mode-map
    "vE" #'org-appear-mode))
#+end_src

#+begin_src emacs-lisp
(use-package org-modern
  :requires org
  :hook (org-mode . org-modern-mode)

  :custom
  (org-modern-star ["" "‣" "•" "◦" "•" "◦" "•"])
  ;; (org-modern-star ["▭" "‣" "•" "◦" "•" "◦" "•"])
  (org-agenda-block-separator ?─)
  (org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")

  (org-modern-table nil)

  :custom-face
  (org-modern-symbol ((t (:family "Iosevka"))))

  :general
  (neh/leader-keys
    "vm" #'org-modern-mode))
#+end_src

** Hooks

For a bit more org mode prettiness: =variable-pitch-mode=, which sets up different fonts for different parts of the file, specifically, monospace fonts for src blocks, and variable width fonts elsewhere.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . variable-pitch-mode)
#+end_src

I want to go straight into =evil-insert-states= in some modes so I can just start typing.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-log-buffer-setup . evil-insert-state)
(org-src-mode . (lambda ()
                  (when (<= (buffer-size) 1)
                    (evil-insert-state))))
#+end_src

I want all drawers hidden on file load.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . neh/org-hide-all-drawers)
#+end_src

I use plantuml to generate various images, and this makes sure that generated images are redisplayed after re-processing diagram source code in a block.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-babel-after-execute . org-redisplay-inline-images)
#+end_src

Flycheck gives way too many errors when editing src blocks in their own buffer. I should probably look into re-enabling useful parts of it though.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-src-mode . disable-flycheck-in-org-src-block)
#+end_src

** Keybindings

General purpose org keybindings.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keys
(neh/leader-keys
  "oC" '(lambda () (interactive) (find-file org-default-notes-file))
  "o." #'org-open-at-point

  "ve" #'neh/toggle-local-emphasis-markers
  "vi" #'org-toggle-inline-images
  "vl" #'org-toggle-link-display)
#+end_src

Add a binding for =org-open-at-point=. I need to look into whether this is worth it, and the differences between this and =browse-url-at-point=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keys
(general-def
  :keymaps 'org-mode-map
  :states '(normal emacs)
  :prefix  "g"
  "." 'org-open-at-point)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keys
(general-def
  :keymaps 'org-mode-map
  :states '(normal emacs)
  "<RET>" 'neh/org-ret
  "S-<return>" 'neh/org-shift-ret
  "ze" 'outline-show-branches)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keys
(general-def
  :keymaps 'org-src-mode-map
  "C-c C-c" #'org-edit-src-exit)
#+end_src

** Org agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :straight nil
  :custom
  (org-agenda-files '("~/org/"))

  (org-agenda-restore-windows t)
  (org-agenda-window-setup 'other-window)

  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)

  (org-agenda-format-date "%A, %B %-d, %Y")

  (org-stuck-projects '("+LEVEL=2/-DONE"
                        ("NEXT")
                        nil
                        ""))

  :general
  (:keymaps 'org-mode-map
   "C-'" nil
   "C-," nil)
  (neh/leader-keys
    "a" #'org-agenda)

  :init
  (defun neh/agenda-current-window ()
    (interactive)
    (let ((org-agenda-window-setup 'only-window))
      (org-agenda)
      (delete-other-windows))))
#+end_src

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after (org org-agenda)
  :hook (org-agenda-mode . org-super-agenda-mode)
  :general
  (:keymaps 'org-super-agenda-header-map
   "n" nil
   "t" nil)
  :custom-face
  (org-super-agenda-header ((t (:inherit 'org-level-1 :extend t))))
  :custom
  (org-super-agenda-header-properties '(org-agenda-structural-header t))
  (org-super-agenda-date-format "%A, %B %d, %Y")

  (org-agenda-custom-commands
   '(("n" "Agenda and all TODOs"
      ((agenda "-archive")
       (alltodo ""))
      ((org-agenda-tag-filter-preset '("-archive"))))

     ("p" "Personal"
      ((agenda "" ((org-super-agenda-groups
                    '((:name " Schedule"
                       :time-grid t
                       :deadline t
                       :scheduled t
                       )))))
       (search "*" ((org-super-agenda-groups
                     '((:name "Inbox"
                        :file-path "~/org/incoming.org"
                        :discard (:heading-regexp ".*Incoming")
                        :tag "refile")
                       (:discard (:anything t))))))
       (tags-todo "-archive -work" ((org-super-agenda-groups
                                     '((:name " Doing"
                                        :todo "DOING")
                                       (:name " Waiting/Testing"
                                        :todo ("WAITING" "TESTING"))
                                       (:name " Next"
                                        :todo "NEXT")
                                       (:discard (:anything t)))))))
      ((org-agenda-files '("~/org"))
       (org-agenda-span 'day)
       (org-agenda-tag-filter-preset '("-work"))))

     ("w" "Work"
      ((agenda "" ((org-super-agenda-groups
                    `((:name ,(format "%s  Schedule"
                                      (all-the-icons-faicon "clock-o"
                                                            :v-adjust -0.04))
                       :time-grid t
                       :deadline t
                       :scheduled t
                       )))))
       (org-ql-block '(and (outline-path-segment "Notes")
                           (tags "work")
                           (ts-active))
                     ((org-ql-block-header "Notes To Process")))
       (tags-todo "-archive +work" ((org-super-agenda-groups
                                     `((:name ,(format "%s  Interruptions"
                                                       (all-the-icons-faicon "bomb"
                                                                             :v-adjust 0.06))
                                        :todo "INTERRUPT")
                                       (:name ,(format "%s  Doing"
                                                       (all-the-icons-faicon "cogs"
                                                                             :v-adjust 0.00))
                                        :todo "DOING")
                                       (:name ,(format "%s  Waiting/Testing"
                                                       (all-the-icons-faicon "repeat"
                                                                             :v-adjust 0.00))
                                        :todo ("WAITING" "TESTING"))
                                       (:name ,(format "%s  Next"
                                                       (all-the-icons-faicon "list"
                                                                             :v-adjust -0.06))
                                        :todo "NEXT")
                                       (:discard (:anything t)))))))
      ((org-agenda-files '("~/org/work-tveon.org"))
       (org-agenda-span 'day)))

     ;; ("w" "Work"
     ;;  ((agenda "")
     ;;   (tags-todo "-archive&+work&+TODO=\"INTERRUPT\""
     ;;              ((org-agenda-overriding-header "Interruptions")))
     ;;   (tags-todo "-archive&+work&+TODO=\"DOING\""
     ;;              ((org-agenda-overriding-header "Doing")))
     ;;   (tags-todo "-archive&work&(/!WAITING|TESTING)"
     ;;              ((org-agenda-overriding-header "Waiting/Testing")))
     ;;   (tags-todo "-archive&+work&+TODO=\"NEXT\""
     ;;              ((org-agenda-overriding-header "Next")))
     ;;   )
     ;;  ((org-agenda-files '("~/org/work-tveon.org"))
     ;;   (org-agenda-span 'day)))
     ))

   ;; (org-super-agenda-groups '(
   ;;                            (:name "Today"
   ;;                             :time-grid t)
   ;;                            (:name "now"
   ;;                             :deadline today
   ;;                             :scheduled today)
   ;;                            (:name "Doing"
   ;;                             :todo "DOING")
   ;;                            (:name "Next"
   ;;                             ;; :auto-parent t
   ;;                             :and (:todo "TODO" :priority "A"))
   ;;                            (:name "Projects"
   ;;                             :children 'todo)
   ;;                            (:name "Waiting"
   ;;                             ;; :auto-parent t
   ;;                             :todo "WAITING")
   ;;                            ))
                             )
#+end_src

** Org Capture

#+begin_src emacs-lisp
(use-package doct
  :commands (doct))
#+end_src

#+begin_src emacs-lisp
(use-package org-capture
  :straight nil
  :after org
  :custom
  (org-capture-bookmark nil)
  (org-capture-templates
   (doct '(("todo"
            :keys "t"
            :file ""
            :headline "Incoming"
            :template ("* TODO %?" "%U")
            :prepend t)
           ("someday"
            :keys "m"
            :file ""
            :headline "Incoming"
            :template ("* SOMEDAY %?" "%U")
            :prepend t)
           ("interruption"
            :keys "i"
            :file ""
            :headline "Incoming"
            :template "* INTERRUPT %?"
            :prepend t)
           ("note"
            :keys "n"
            :file ""
            :headline "Incoming"
            :template ("* %?" "%T")
            :prepend t)
           ;; ("meeting"
           ;;  :keys "m"
           ;;  :file ""
           ;;  :headline "Current"
           ;;  :template ("* %?" "%^T")
           ;;  :prepend nil)
           ("link"
            :keys "l"
            :file ""
            :headline "Incoming"
            :template "* [[%x][%?]] %^g"
            :prepend t)
           ("web"
            :keys "w"
            :file ""
            :headline "Incoming"
            :template ("* %a" "%U" "%i%?")
            :prepend t)
           ("test"
            :keys "x"
            :file ""
            :headline "Incoming"
            :template ("* %:url" "Source: %u, %c" "%i%?")
            :prepend t)
           )))

  :hook ((org-capture-mode . evil-insert-state)
         (org-capture-mode . neh/full-frame-capture))

  :general
  (neh/leader-keys
    "k" 'org-capture)

  :init
  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (when (and (equal "capture" (frame-parameter nil 'name))
               (not (eq this-command 'org-capture-refile)))
      (delete-frame)))

  (defadvice org-capture-refile
      (after delete-capture-frame activate)
    "Advise org-refile to close the frame"
    (when (and (equal "capture" (frame-parameter nil 'name))
               (not (eq this-command 'org-capture-refile)))
      (delete-frame)))

  (defun neh/capture-full-frame ()
    "Start org-capture in a frame by itself."
    (interactive)
    (org-capture)
    (delete-other-windows))

  (defun neh/full-frame-capture ()
    (if (string= (frame-parameter nil 'name) "capture")
        (delete-other-windows)))

  :config
  ;; from https://stackoverflow.com/questions/54192239/open-org-capture-buffer-in-specific-window/54251825#54251825
  ;; modifies the capture process to not mess up window layouts, even temporarily, and make the capture window more controllable
  (defun my-org-capture-place-template-dont-delete-windows (oldfun &rest args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  (with-eval-after-load "org-capture"
    (advice-add 'org-capture-place-template :around
                'my-org-capture-place-template-dont-delete-windows))
  )
#+end_src

#+begin_src emacs-lisp
(use-package org-protocol
  :straight nil
  :after org)
#+end_src

We need a little desktop integration for =org-protocol=, linux-only, currently. First up is the systemd configuration for the emacs server process. Yes, there's one included with emacs, but this way I can customize it more easily. Needs a ~systemctl --user enable emacs-server~ and ~systemctl --user start emacs-server~ to use.

#+begin_src conf :tangle ~/.config/systemd/user/emacs-server.service :mkdirp yes
[Unit]
Description=Emacs (server)
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=emacs --daemon --chdir %h
# ExecStart=/usr/bin/emacs --fg-daemon
ExecStop=emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=${XDG_RUNTIME_DIR}/ssh-agent.socket
# Environment=SSH_AUTH_SOCK=%t/keyring/ssh XDG_RUNTIME_DIR=/run/user/%U EMACS_SOCKET_NAME=/run/user/%U/emacs/server
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

And an ~emacsclient~ .desktop file to integrate it into the gnome desktop.

#+begin_src conf :tangle ~/.local/share/applications/emacsclient.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs (client)
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
# Exec=/usr/bin/emacsclient -c %F
Exec=emacsclient --create-frame --alternate-editor="emacs" %F
Icon=emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
#+end_src

Then a handler for =org-protocol:= URLs so that browsers can open them with ~emacsclient~.

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop :mkdirp yes
[Desktop Entry]
Name=org-protocol
Exec=emacsclient -c -F '(quote (name . "capture"))' %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

** Org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :commands (org-roam-db-autosync-mode
             org-roam-capture
             org-roam-buffer-toggle
             org-roam-node-find
             org-roam-node-insert)

  :custom
  (org-roam-directory "~/org/roam")
  (org-roam-completion-everywhere t)
  (org-roam-list-files-commands '(rg find))
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("p" "project" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: project\n\n")
      :unnarrowed t)
     ;; ("l" "literature" plain
     ;;  "%?"
     ;;  :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "%^{roam_refs|%x}p#+title: ${title}\n#+filetags: literature\n\n")
     ;;  :unnarrowed t)
     ))
  ;; (org-roam-buffer-window-parameters '((no-other-window . t)))

  :general
  (:keymaps '(normal)
   "S-SPC" #'org-roam-node-find)
  (neh/leader-keys
    "N" #'(lambda () (interactive) (neh/customize-this "neh/org-roam-context"))
    "nc" #'neh/org-roam-node-find
    "no" #'org-roam-node-find
    "w" #'org-roam-node-find
    )

  (neh/leader-keys
    :keymaps 'org-mode-map
    "ni" #'org-roam-node-insert)

  (:keymaps '(org-roam-mode-map
              org-roam-node-map)
   "n" nil
   "SPC" nil
   "S-SPC" nil

   "M-t" #'magit-section-forward
   "M-n" #'magit-section-backward
   "M-<down>" #'magit-section-forward
   "M-<up>" #'magit-section-backward
   )

  :init

  (defun neh/dnd-only (node)
    (neh/by-tag "d&d" node))

  (defun neh/projects-only (node)
    (neh/by-tag "project" node))

  (defun neh/by-tag (tag node)
    (member tag (org-roam-node-tags node)))


  (defun neh/org-roam-node-find ()
    (interactive)
    (org-roam-node-find t nil #'neh/notes-by-context))

  (defun neh/set-org-roam-context (sym value)
    (setq neh/org-roam-context value))

  (defcustom neh/org-roam-context "personal"
    "Set org roam context."
    :type '(choice
            (const "personal")
            (const "work")
            (const "d&d"))
    :set 'neh/set-org-roam-context
    :initialize 'custom-initialize-set)

  (defun neh/notes-by-context (node)
    (let ((tags (org-roam-node-tags node)))
      (cond ((equal neh/org-roam-context "personal")
             ;; '(notes-not-tagged "work"))
             (not (member "work" tags)))
            ((equal neh/org-roam-context "work")
             ;; '(notes-by-tag "work"))
             (member "work" tags))
            ((equal neh/org-roam-context "d&d")
             (member "d&d" tags))
             ;; '(notes-by-tag "d&d"))
            (t '(lambda (node) t))
            )))

  (defmacro notes-by-context ()
    (cond ((equal neh/org-roam-context "personal")
           (notes-not-tagged "work"))
          ((equal neh/org-roam-context "work")
           (notes-by-tag "work"))
          ((equal neh/org-roam-context "d&d")
           (notes-by-tag "d&d"))
          (t '(lambda (node) t))
          ))


  (defmacro notes-tagged (tag)
    (let ((name (intern (format "notes-tagged-%s" tag))))
      `(progn
         (defun ,name (node)
           (member ,tag (org-roam-node-tags node)))
         #',name)))

  (defmacro notes-by-tag (tag)
    `(lambda (node)
       (member ,tag (org-roam-node-tags node))))

  (defmacro notes-not-tagged (tag)
    `(lambda (node)
       (not (member ,tag (org-roam-node-tags node)))))


  (defun neh/check-org-files ()
    (when (> (length (directory-files org-directory nil "\\.org$")) 0)
      (org-roam-db-autosync-mode t)
      (cancel-function-timers #'neh/check-org-files)))

  (run-with-timer 0 5 #'neh/check-org-files)

  :config
  (cl-defmethod org-roam-node-filetitle ((node org-roam-node))
    "Return the file TITLE for the node."
    (if-let ((file (org-roam-node-file node)))
        (with-temp-buffer
          (insert-file-contents file nil 0 1024)
          (cadr (assoc "TITLE"
                       (org-collect-keywords (list "TITLE")))))
      (cadr (assoc "TITLE"
                   (org-collect-keywords (list "TITLE"))))))

  (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
    "Return the hierarchy for the node."
    (let ((title (org-roam-node-title node))
          (olp (org-roam-node-olp node))
          (level (org-roam-node-level node))
          (filetitle (org-roam-node-filetitle node)))
      (concat
       (if (> level 0) (concat filetitle " > "))
       (if (> level 1) (concat (string-join olp " > ") " > "))
       title)))

  (cl-defmethod org-roam-node-type ((node org-roam-node))
    "Return the TYPE of NODE."
    (condition-case nil
        (file-name-nondirectory
         (directory-file-name
          (file-name-directory
           (file-relative-name (org-roam-node-file node) org-roam-directory))))
      (error "")))

  (setq org-roam-node-display-template
        (concat "${type:8} ${hierarchy:*} "
                (propertize "${tags:10}" 'face 'org-tag)))

  (defun neh/org-roam-ref-add-dwim ()
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and clipboard-url (not point-in-link))
             (org-roam-ref-add clipboard-url))
            (t
             (call-interactively #'org-roam-ref-add)))))

  ;; https://org-roam.discourse.group/t/opening-url-in-roam-refs-field/2564/3
  (defun neh/open-node-roam-ref-url ()
    "Open the URL in this node's ROAM_REFS property, if one exists"
    (interactive)
    (when-let ((ref-url (org-entry-get-with-inheritance "ROAM_REFS")))
      (browse-url ref-url)))
  )

(use-package org-roam-dailies
  :after org-roam
  :straight nil
  :custom
  (org-roam-dailies-directory "daily/")
  (org-roam-dailies-capture-templates
   '(("d" "default" entry "* %<%k:%M> %?"
      :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
  :general
  (neh/leader-keys
    "n." #'org-roam-dailies-goto-today)
  )
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode)
  :custom
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-sync-theme t))
#+end_src

#+begin_src emacs-lisp
(use-package org-download
  :after org
  :hook (dired-mode . org-download-enable)
  :general
  (neh/leader-keys
    :keymaps 'org-mode-map
    "nS" #'org-download-screenshot
    "nD" #'org-download-yank)
  :custom
  (org-download-method 'attach))
#+end_src

#+begin_src emacs-lisp
(use-package org-ql
  :commands (org-ql-select
             org-ql-search
             org-ql-view
             org-ql-view-recent-items
             org-ql-sparse-tree))
#+end_src

#+begin_src emacs-lisp
(use-package org-sticky-header
  :after org
  :hook (org-mode . org-sticky-header-mode)
  :commands (org-sticky-header-mode)
  :custom
  (org-sticky-header-prefix "🦜 ")
  (org-sticky-header-full-path 'reversed)
  :general
  (neh/leader-keys
    :keymaps 'org-mode-map
    "vH" #'org-sticky-header-mode))
#+end_src

#+begin_src emacs-lisp
(use-package org-transclusion
  :commands (org-transclusion-add
             org-transclusion-mode)
  :custom
  (org-transclusion-extensions '(org-transclusion-src-lines
                                 org-transclusion-font-lock
                                 org-transclusion-indent-mode)))
#+end_src

* Window management

Let’s try to get some window behaviour under control.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(switch-to-buffer-in-dedicated-window 'pop)
(switch-to-buffer-obey-display-actions t)
#+end_src

 #+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(display-buffer-alist
 '(("\\*Org Select\\*"
    (display-buffer-below-selected))
   ("\\*Agenda Commands\\*"
    (display-buffer-below-selected))
   ("Calendar"
    (display-buffer-below-selected))
   ("CAPTURE-*"
    (display-buffer-below-selected))
   ("\\*helpful *"
    (display-buffer-reuse-mode-window display-buffer-pop-up-window)
    (mode . helpful-mode)
    (inhibit-same-window . t))))
#+end_src

#+begin_src emacs-lisp
;; from https://christiantietze.de/posts/2022/12/updated-org-mode-agenda-display-buffer-alist/
(defun ct/display-buffer-org-agenda-managed-p (buffer-name action)
  "Determine whether BUFFER-NAME is an org-agenda managed buffer."
  (with-current-buffer buffer-name
    (and (derived-mode-p 'org-mode)
         (member (buffer-file-name) (org-agenda-files)))))

(add-to-list 'display-buffer-alist
             `("\\*Org Agenda\\*"
               (display-buffer-in-tab  ;; Make sure to use the "agenda" tab
                display-buffer-reuse-mode-window)
               (ignore-current-tab . t)
               (tab-name . "agenda")
               (window-width . fill-column)
               (dedicated . side)  ;; Make the agenda a dedicated side-window
               (side . left)       ;; to the left so it always stays open.
               (inhibit-same-window . nil)))
(add-to-list 'display-buffer-alist
             '(ct/display-buffer-org-agenda-managed-p
               (display-buffer-reuse-mode-window  ;; Prioritize reuse of current window
                display-buffer-in-tab)            ;; over switching to the Org tab.
               (tab-name . "agenda")))
#+end_src

#+begin_src emacs-lisp
(use-package winner
  :straight nil
  :init
  (winner-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package tab-bar
  :straight nil
  :custom
  (tab-bar-format '(tab-bar-format-history
                    tab-bar-format-tabs-groups
                    tab-bar-separator
                    tab-bar-format-add-tab))
  :general
  (general-define-key
   :keymaps 'tab-bar-map
   "<mouse-4>" #'tab-next
   "<mouse-5>" #'tab-previous
   "<wheel-up>" #'tab-next
   "<wheel-down>" #'tab-previous
   )
  :config
  (tab-bar-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package shackle
  :hook (after-init . shackle-mode)
  :custom
  (shackle-rules
   '(
     ;; (magit-diff-mode :align 'below :size 0.8)
     (compilation-mode :noselect t))))
#+end_src

#+begin_src emacs-lisp
(use-package popper
  :general
  (neh/leader-keys
    "pl" #'popper-toggle-latest
    "pp" #'popper-cycle
    "pt" #'popper-toggle-type)

  :custom
  (popper-display-control nil)
  (popper-reference-buffers
   '("\\*Messages\\*$"
     compilation-mode
     ("\\*Shell Command Output\\*" . hide)
     ))

  :init
  (popper-mode t))
#+end_src

* Window Navigation

#+begin_src emacs-lisp
(use-package repeat
  :straight nil
  :custom
  (repeat-exit-key "ESC")
  :config
  (repeat-mode t))

(use-package repeat-help
  :disabled
  ;; this package seems to break repeat-mode in weird ways
  :hook (repeat-mode . repeat-help-mode)
  :custom
  ;; (repeat-help-key "")
  (repeat-help-auto nil))
#+end_src

#+begin_src emacs-lisp
;; (symbol-plist 'windmove-right)
;; (put 'windmove-left 'repeat-exit-timeout 1)
;; (put 'windmove-right 'repeat-exit-timeout 1)
;; (get 'windmove-right 'repeat-exit-timeout)
#+end_src

#+begin_src emacs-lisp
(use-package windmove
  :straight nil
  :general
  (neh/leader-nav
    "h" #'windmove-left
    "s" #'windmove-right
    "n" #'windmove-up
    "t" #'windmove-down

    "H" #'windmove-swap-states-left
    "S" #'windmove-swap-states-right
    "N" #'windmove-swap-states-up
    "T" #'windmove-swap-states-down

    "g" #'tab-previous
    "l" #'tab-next

    "G" #'tab-bar-move-tab-backward
    "L" #'tab-move
    )
  :config
  ;; add split-in-direction commands to this?
  (defvar windmove-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "h") 'windmove-left)
      (define-key map (kbd "s") 'windmove-right)
      (define-key map (kbd "n") 'windmove-up)
      (define-key map (kbd "t") 'windmove-down)

      (define-key map (kbd "H") 'windmove-swap-states-left)
      (define-key map (kbd "S") 'windmove-swap-states-right)
      (define-key map (kbd "N") 'windmove-swap-states-up)
      (define-key map (kbd "T") 'windmove-swap-states-down)
      map))

  (map-keymap
   (lambda (_key cmd)
     (when (symbolp cmd)
       (put cmd 'repeat-map 'windmove-repeat-map)
       (put cmd 'repeat-exit-timeout 0.6)
       ))
   windmove-repeat-map)

  (defvar tabmove-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "g") 'tab-previous)
      (define-key map (kbd "l") 'tab-next)

      (define-key map (kbd "G") 'tab-bar-move-tab-backward)
      (define-key map (kbd "L") 'tab-move)
      map))

  (map-keymap
   (lambda (_key cmd)
     (when (symbolp cmd)
       (put cmd 'repeat-map 'tabmove-repeat-map)
       (put cmd 'repeat-exit-timeout 0.9)
       ))
   tabmove-repeat-map)
  )
#+end_src

#+begin_src emacs-lisp
(use-package ace-window
  :custom
  (aw-scope 'frame)
  (aw-keys '(?a ?o ?e ?u ?h ?t ?s))
  (aw-reverse-frame-list t)

  :general
  (general-define-key
   :states '(normal visual)
   :prefix "j"
   "w" #'ace-window
   ;; only pops to window switched to with ace
   "W" #'aw-flip-window
   ;; "s" #'ace-swap-window
   )

  :config
  ;; (setq display-buffer-base-action
  ;;       '((display-buffer-reuse-window
  ;;          ace-display-buffer)))
  (ace-window-display-mode t))
#+end_src

* Shells

#+begin_src emacs-lisp :lexical no
(use-package terminal-here
  :commands (terminal-here-launch
             terminal-here-project-launch)
  :custom
  (terminal-here-linux-terminal-command 'alacritty)
  :general
  (neh/leader-keys
    "ot" #'terminal-here-launch
    "oT" #'terminal-here-project-launch))
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :commands (vterm
             vterm-other-window)
  :custom
  (vterm-max-scrollback 10000))
#+end_src

#+begin_src emacs-lisp
(use-package multi-vterm
  :commands (multi-vterm
             multi-vterm-next
             multi-vterm-prev))
#+end_src

#+begin_src emacs-lisp
(use-package eshell
  :straight nil
  :custom
  (eshell-scroll-to-bottom-on-input 'this)
  (eshell-error-if-no-glob t)
  (eshell-hist-ignoredups t)
  (eshell-save-history-on-exit t)
  (eshell-destroy-buffer-when-process-dies t)
  (eshell-banner-message "")

  :hook (eshell-mode . neh/eshell-mode-hook)

  :init
  (defun neh/eshell-mode-hook ()
    (add-to-list 'eshell-visual-commands "htop")
    (add-to-list 'eshell-visual-commands "tail")
    (add-to-list 'eshell-visual-commands "ssh")

    (add-to-list 'eshell-modules-list 'eshell-tramp)

    (general-def
      :keymaps 'eshell-mode-map
      :states '(insert)
      "M-n" #'eshell-previous-input
      "M-t" #'eshell-next-input
      "M-<up>" #'eshell-previous-input
      "M-<down>" #'eshell-next-input)

    (general-def
      :keymaps 'eshell-mode-map
      :states '(normal)
      "M-n" #'eshell-previous-prompt
      "M-t" #'eshell-next-prompt
      "M-<up>" #'eshell-previous-prompt
      "M-<down>" #'eshell-next-prompt)

    (eshell/alias "ll" "ls -l")
    (eshell/alias "la" "ls -al")
    (eshell/alias "ff" "find-file $1"))

  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))
  )
#+end_src

#+begin_src emacs-lisp
(use-package eshell-prompt-extras
  :init
  (defun epe-theme-neh ()
    ""
    (setq eshell-prompt-regexp "^[^#\n]*[#]* ")

    (concat
     "\n"
     (if (epe-remote-p)
         (progn
           (concat
            (epe-colorize-with-face "─ " 'epe-neh-delimiter-face)
            (epe-colorize-with-face (epe-remote-user) 'epe-neh-user-face)
            (epe-colorize-with-face "@" 'epe-neh-delimiter-face)
            (epe-colorize-with-face (epe-remote-host) 'epe-neh-host-face)
            ""))
       (progn
         (when (not (string= user-login-name "nathan"))
           (concat
            (epe-colorize-with-face "─ " 'epe-neh-delimiter-face)
            (epe-colorize-with-face (user-login-name) 'epe-neh-user-face)
            (epe-colorize-with-face (system-name) 'epe-neh-host-face)
            " "))))

     (concat
      (epe-colorize-with-face "─ " 'epe-neh-delimiter-face)
      (epe-colorize-with-face (concat (eshell/pwd)) 'epe-dir-face)
      " "

      (when (epe-git-p)
        (concat
         (epe-colorize-with-face "─ " 'epe-neh-delimiter-face)
         (epe-colorize-with-face " " 'epe-git-face)
         (epe-colorize-with-face
          (concat (epe-git-branch)
                  (epe-git-dirty)
                  (epe-git-untracked)
                  (let ((unpushed (epe-git-unpushed-number)))
                    (unless (= unpushed 0)
                      (concat ":" (number-to-string unpushed)))))
          'epe-git-face)))

      (epe-colorize-with-face  "\n" 'epe-neh-delimiter-face))

     (when (> 0 eshell-last-command-status)
       (epe-colorize-with-face eshell-last-command-status 'epe-symbol-face))

     (when (and epe-show-python-info (bound-and-true-p venv-current-name))
       (epe-colorize-with-face (concat "(" venv-current-name ") ") 'epe-venv-face))

     (epe-colorize-with-face "" 'epe-symbol-face)
     (epe-colorize-with-face (if (= (user-uid) 0) "#" "") 'epe-sudo-symbol-face)

     " "))

  :custom-face
  (epe-neh-delimiter-face ((t (:inherit 'shadow))))
  (epe-neh-user-face ((t (:inherit 'default))))
  (epe-neh-host-face ((t (:inherit 'default))))

  :custom
  (epe-show-python-info t)
  (epe-git-dirty-char "*")
  (epe-git-untracked-char "?")
  (epe-git-detached-HEAD-char "D:")
  (epe-path-style 'fish)
  (eshell-prompt-function 'epe-theme-neh))
#+end_src

#+begin_src emacs-lisp
(use-package sane-term
  :disabled
  :commands (sane-term
             sane-term-create)
  :custom
  (sane-term-shell-command "/usr/bin/zsh"))
#+end_src

#+begin_src emacs-lisp
(use-package fish-mode
  :commands (fish-mode))
#+end_src

* Dired

#+begin_src emacs-lisp
(use-package dired
  :straight nil
  :hook ((dired-mode . dired-hide-details-mode))
  :commands (dired-jump
             dired-mode)

  :custom
  (dired-create-destination-dirs 'ask)
  (dired-listing-switches "-alhv")
  (dired-recursive-copies 'always)
  (dired-dwim-target t)
  (dired-kill-when-opening-new-dired-buffer t)

  :general
  (general-define-key
    :keymaps 'dired-mode-map
    :states '(normal)
    "t" nil)

  (neh/leader-keys
    "cp" #'neh/dired-copy-full-path
    "cP" #'neh/dired-copy-full-path-quoted
    "j" #'dired-jump
    "xx" #'neh/dired-open)

  :init
  (defun neh/dired-copy-full-path ()
    "Copy full path of entries that are marked or at point."
    (interactive)
    (let ((current-prefix-arg 0))
      (call-interactively #'dired-copy-filename-as-kill)))

  (defun neh/dired-copy-full-path-shell-quoted ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (kill-new (shell-quote-argument (neh/dired-copy-full-path))))


  (defun neh/dired-copy-full-path-quoted ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (neh/copy-file-path nil nil t))

  (defun neh/dired-copy-full-path-quoted-list ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (neh/copy-file-path nil "\n" t))

  (defun neh/copy-file-path (&optional @dir-path-only-p separator shell-quote-p)
    "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.

If in dired, copy the file/dir cursor is on, or marked files.

If a buffer is not file and not dired, copy value of `default-directory' (which is usually the “current” dir when that buffer was created)

URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2017-09-01"
    (interactive "P")
    (fset 'quote-or-not (if shell-quote-p
                            'shell-quote-argument
                          'identity))
    (let* ((separator (or separator " "))
           ($fpath
           (if (string-equal major-mode 'dired-mode)
               (progn
                 (let (($result (mapconcat 'quote-or-not (dired-get-marked-files) separator)))
                   (if (equal (length $result) 0)
                       (progn default-directory )
                     (progn $result))))
             (if (buffer-file-name)
                 (buffer-file-name)
               (expand-file-name default-directory)))))
      (kill-new
       (if @dir-path-only-p
           (progn
             (message "Directory path copied: 「%s」" (file-name-directory $fpath))
             (file-name-directory $fpath))
         (progn
           (message "File path copied: 「%s」" $fpath)
           $fpath )))))

  (setq dired-deletion-confirmer 'y-or-n-p
        dired-guess-shell-alist-user '(("\\.rar\\'" "unrar x" "unrar e")
                                       ("" "xdg-open")))

  (defvar my-dired-new-file-first-dirs
    '("Downloads?/$")
    "Dired directory patterns where newest files are on the top.")

  (defun my-dired-mode-hook-setup ()
    "Set up Dired."
    (when (cl-find-if (lambda (regexp)
                        (let ((case-fold-search t))
                          (string-match regexp default-directory)))
                      my-dired-new-file-first-dirs)
      (setq dired-actual-switches "-lahvt")))
  (add-hook 'dired-mode-hook 'my-dired-mode-hook-setup)
  )
#+end_src

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

#+begin_src emacs-lisp
(use-package ls-lisp
  :straight nil
  :custom
  (ls-lisp-ignore-case t)
  (ls-lisp-use-insert-directory-program nil))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-hydras
(major-mode-hydra-define dired-mode
  (:color amaranth :quit-key ("q" "<escape>"))
  ("Show"
   (("d" dired-hide-details-mode "hide details" :toggle t)
    ("g" dired-git-info-mode "git info" :toggle t)
    ("u" dired-du-mode "usage" :toggle t)
    ("c" dired-collapse-mode "collapse" :toggle t)
    )
   "Filter"
   (("p" dired-filter-pop "pop")
    ;;TODO ("a" (lambda () (interactive) (counsel-M-x "dired-filter-by-")) "add")
    ("n" dired-narrow-fuzzy "fuzzy narrow")
    ("r" revert-buffer "revert"))))
#+end_src

#+begin_src emacs-lisp
(use-package dired-git-info
  :commands (dired-git-info-mode))
#+end_src

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :commands (dired-subtree-toggle
             dired-subtree-cycle)
  :hook (after-load-theme . neh/set-dired-subtree-background)

  :general
  (general-define-key
   :states 'normal
   :keymaps 'dired-mode-map
   "<tab>" 'dired-subtree-toggle)

  :init
  (defun neh/set-dired-subtree-background ()
    (if (featurep 'dired-subtree)
        (let* ((bg (face-background 'default))
               (lighten-or-darken (if (neh/dark-p)
                                      #'color-lighten-name
                                    #'color-darken-name))
               (even (funcall lighten-or-darken bg 6))
               (odd (funcall lighten-or-darken bg 3)))
          (set-face-attribute 'dired-subtree-depth-1-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-2-face nil :background even :extend t)
          (set-face-attribute 'dired-subtree-depth-3-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-4-face nil :background even :extend t)
          (set-face-attribute 'dired-subtree-depth-5-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-6-face nil :background even :extend t))))

  :config
  (neh/set-dired-subtree-background))
#+end_src

This seems useful, especially in combination with =dired-subtree=, as then it's active in the buffer as you view subtrees.

#+begin_src emacs-lisp
(use-package dired-collapse
  :hook (dired-mode . dired-collapse-mode))
#+end_src

Handy live filtering of dired buffers.

#+begin_src emacs-lisp
(use-package dired-narrow
  :commands (dired-narrow
             dired-narrow-regexp
             dired-narrow-fuzzy))
#+end_src

Nice dired filtering, plus it replaces =dired-omit-mode=.

#+begin_src emacs-lisp
(use-package dired-filter
  :hook ((dired-mode . dired-filter-mode)
         (dired-filter-mode . dired-filter-by-dot-files))

  :general
  (general-define-key
   :states 'normal
   :keymaps 'dired-mode-map
   ;;TODO "{" '(lambda () (interactive) (counsel-M-x "dired-filter-by-"))
   ")" 'dired-filter-pop))
#+end_src

#+begin_src emacs-lisp
(use-package dired-du
  :commands (dired-du-mode)
  :custom
  (dired-du-size-format t))
#+end_src

* Imenu

#+begin_src emacs-lisp
(use-package imenu-list
  :general
  (neh/leader-keys
    "os" #'imenu-list-smart-toggle)

  :custom
  (imenu-list-focus-after-activation t))

(use-package imenu-anywhere
  :general
  (neh/leader-keys
    "sT" #'imenu-anywhere))
#+end_src

* Hydra

#+begin_src emacs-lisp :noweb yes
(use-package posframe
  :commands (posframe-show)
  :config
  (defun posframe-poshandler-frame-bottom-center (info)
    "Posframe's position handler.

    Get a position which let posframe stay onto its parent-frame's
    bottom center.  The structure of INFO can be found
    in docstring of `posframe-show'."
    (cons (/ (- (plist-get info :parent-frame-width)
                (plist-get info :posframe-width))
             2)
          (- 0
             (plist-get info :mode-line-height)
             (plist-get info :minibuffer-height))))

  (defun posframe-poshandler-window-bottom-center (info)
    "Posframe's position handler.

    Get a position which let posframe stay onto current window's
    center.  The structure of INFO can be found in docstring
    of `posframe-show'."
    (let* ((window-left (plist-get info :parent-window-left))
           (window-top (plist-get info :parent-window-top))
           (window-width (plist-get info :parent-window-width))
           (window-height (plist-get info :parent-window-height))
           (mode-line-height (plist-get info :mode-line-height))
           (posframe-width (plist-get info :posframe-width))
           (posframe-height (plist-get info :posframe-height)))
      (cons (+ window-left (/ (- window-width posframe-width) 2))
            (- (+ window-top window-height) (+ posframe-height mode-line-height 15))))))
#+end_src

#+begin_src emacs-lisp :noweb yes
(use-package hydra
  :general
  (neh/leader-keys
    "rc" #'hydra-codereading/body
    "rg" #'hydra-git-gutter/body
    "ro" #'hydra-org/body
    "rr" #'hydra-reading/body)

  :custom
  (hydra-hint-display-type 'lv)

  :init
  (setq hydra--work-around-dedicated nil)
  (setq hydra-posframe-show-params '(:internal-border-width 10
                                     :internal-border-color "grey21"
                                     ;; :min-height 15
                                     :poshandler posframe-poshandler-point-bottom-left-corner))

  :config
  <<hydra-hydras>>

  (use-package hydra-posframe
    :disabled
    :straight (hydra-posframe
               :type git
               :host github
               :repo "Ladicle/hydra-posframe")

    :commands (hydra-posframe-enable)

    :config
    (setq hydra-posframe-show-params '(:internal-border-width 2
                                       :internal-border-color "green"
                                       ;; :min-height 15
                                       :poshandler posframe-poshandler-point-bottom-left-corner))

    (hydra-posframe-enable))
  )
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
(defhydra hydra-reading (:color red
                         :hint nil)
  "
  _N_ pg up         _gg_ go to top        _zt_ line to top
  _n_ ½ pg up       _G_  go to bottom     _zz_ line to center
  _t_ ½ pg dn       ^ ^                   _zb_ line to bottom
  _T_ pg dn

"
  ("n" (evil-scroll-up 0))
  ("t" (evil-scroll-down 0))
  ("T" (scroll-up))
  ("N" (scroll-down))

  ("gg" evil-goto-first-line)
  ("G" evil-goto-line)

  ("zt" (evil-scroll-line-to-top (line-number-at-pos)))
  ("zz" (evil-scroll-line-to-center (line-number-at-pos)))
  ("zb" (evil-scroll-line-to-bottom (line-number-at-pos)))

  ("+" (neh/adjust-text-height 7) "bigger")
  ("-" (neh/adjust-text-height -7) "smaller")
  ("0" (neh/adjust-text-height 0) "reset")
  ("q" nil "quit"))
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1))
  "Browse/stage/revert git hunks"
  ("n" (progn (git-gutter:previous-hunk 1)
              (evil-scroll-line-to-center (line-number-at-pos))) "previous hunk")
  ("t" (progn (git-gutter:next-hunk 1)
              (evil-scroll-line-to-center (line-number-at-pos))) "next hunk")
  ("H" (progn (goto-char (point-min))
              (git-gutter:next-hunk 1)) "first hunk")
  ("S" (progn (goto-char (point-min))
              (git-gutter:previous-hunk 1)) "last hunk")
  ("c" magit-commit "commit" :exit t)
  ("s" git-gutter:stage-hunk "stage hunk")
  ("k" git-gutter:revert-hunk "revert hunk")
  ("q" nil "quit" :color blue))
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("t" outline-next-visible-heading "next heading")
  ("n" outline-previous-visible-heading "prev heading")
  ("T" org-forward-heading-same-level "next heading at same level")
  ("N" org-backward-heading-same-level "prev heading at same level")
  ("H" outline-up-heading "up heading")
  ("<tab>" org-cycle "cycle")
  ("g" org-goto "goto" :exit t)
  ("q" nil "quit" :color blue))
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
;; from https://github.com/abo-abo/hydra/wiki/straight.el
(defhydra hydra-straight-helper (:hint nil)
  "
  _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
  _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
  ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
  _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
  _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
  ("c" straight-check-all)
  ("C" straight-check-package)
  ("r" straight-rebuild-all)
  ("R" straight-rebuild-package)
  ("f" straight-fetch-all)
  ("F" straight-fetch-package)
  ("p" straight-pull-all)
  ("P" straight-pull-package)
  ("m" straight-merge-all)
  ("M" straight-merge-package)
  ("n" straight-normalize-all)
  ("N" straight-normalize-package)
  ("u" straight-push-all)
  ("U" straight-push-package)
  ("v" straight-freeze-versions)
  ("V" straight-thaw-versions)
  ("w" straight-watcher-start)
  ("W" straight-watcher-quit)
  ("g" straight-get-recipe)
  ("e" straight-prune-build)
  ("q" nil))
#+end_src

=Pretty-hydra= comes from the =major-mode-hydra= package, but I’m using it separately to define various hydras as I begin to use them more. Each hydra is broken out below.

#+begin_src emacs-lisp :noweb yes
(use-package pretty-hydra
  :after hydra
  :commands (pretty-hydra-define)
  :general
  (neh/leader-keys
    "," #'neh/toggles/body
    "'" #'neh/movement/body
    "G" 'hydra-git/body
    "rR" 'neh/reading/body)

  :config
  <<pretty-hydras>>
  )
#+end_src

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-go (:hint nil
                               :quit-key "q")

  ("open" (("p" projectile-switch-project "project" :exit t)
           ("t" org-roam-dailies-goto-today "today's note" :exit t)
           ("o" consult-buffer "buffer" :exit t)
           ("b" ibuffer "ibuffer" :exit t)
           ("e" execute-extended-command "command" :exit t)
           ("n" org-roam-node-find "notes" :exit t)
           ("a" neh/agenda-current-window "agenda" :exit t)
           ("c" neh/capture-full-frame "capture" :exit t)
           ("f" find-file "file" :exit t))

   "search" (("N" neh/roam-rg "notes" :exit t)
             ("F" consult-find "files" :exit t)
             ("A" consult-org-agenda "agenda" :exit t)
             ("5" hydra-5e/body "5e" :exit t))

   ;; "help" (("a" consult-apropos "apropos" :exit t)
   ;;         ("f" helpful-callable "function" :exit t)
   ;;         ("v" helpful-variable "variable" :exit t))
   ))
#+end_src

#+begin_src emacs-lisp :lexical no :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-5e (:hint nil
                               :quit-key "q")

  ("open" (("p" projectile-switch-project "project" :exit t)
           ("o" consult-buffer "buffer" :exit t)
           ("f" find-file "file" :exit t))

   "search" (("N" neh/roam-rg "notes" :exit t)
             ("F" consult-find "files" :exit t)
             ("A" consult-org-agenda "agenda" :exit t))
   ))
#+end_src

Browser/link handling hydra.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-browse (:hint nil
                                   :quit-key "q")

  ("browse" (("f" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (browse-url-at-point))) " firefox" :exit t)
             ("o" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (org-open-at-point))) " org firefox" :exit t)
             ("F" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (browse-url-at-point t))) " firefox (new window)" :exit t)
             ("c" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-chromium))
                      (browse-url-at-point))) " chromium" :exit t)
             ("d" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-default-browser))
                      (browse-url-at-point))) " default" :exit t))
   ))
#+end_src

Working on a =git= hydra to replace all or most of my usual git keybinds. This is an experiment to see whether I want to use a lot more hydras.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-git (:hint nil
                                :quit-key "q"
                                :body-pre (git-gutter-mode 1))

  ("go" (("gg" (progn (goto-char (point-min))
                      (git-gutter:next-hunk 1)) "first hunk")
         ("n" (progn (git-gutter:previous-hunk 1)
                     (evil-scroll-line-to-center (line-number-at-pos))) "previous hunk")
         ("t" (progn (git-gutter:next-hunk 1)
                     (evil-scroll-line-to-center (line-number-at-pos))) "next hunk")
         ("G" (progn (goto-char (point-min))
                     (git-gutter:previous-hunk 1)) "last hunk"))

   "do" (("s" git-gutter:stage-hunk "stage")
         ("k" git-gutter:revert-hunk "revert hunk")
         ("c" magit-commit "commit" :exit t)
         ("P" magit-push "push" :exit t))

   "see" (("S" magit-status "status" :exit t)
          ("l" magit-log-buffer-file "log" :exit t)
          ("L" magit-log "log (menu)" :exit t))
   ))
#+end_src

Another work-in-progress hydra, this one for a general reading/browsing set of commands. Not sure exactly what it will be yet.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define neh/reading (:hint nil
                                  :foreign-keys warn
                                  :quit-key "q")
  ("move up/down" (("N" scroll-down "pg up")
                   ("n" (evil-scroll-up 0) "1/2 pg up")
                   ("t" (evil-scroll-down 0) "1/2 pg dn")
                   ("T" scroll-up "pg down"))

   "current line" (("H" (evil-scroll-line-to-top (line-number-at-pos)) "to top")
                   ("Z" (evil-scroll-line-to-center (line-number-at-pos)) "to center")
                   ("S" (evil-scroll-line-to-bottom (line-number-at-pos)) "to bottom"))

   "text size" (("+" (neh/adjust-text-height 7) "bigger")
                ("-" (neh/adjust-text-height -7) "smaller")
                ("0" (neh/adjust-text-height 0) "reset"))
   ))
#+end_src

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(defun neh/set-frame-width (multiple)
  "Sets frame width to MULTIPLE of FILL-COLUMN."
  (interactive)
  (message "%s %i" "setting frame width to " (+ (* multiple fill-column) 2))
  (set-frame-parameter
   nil
   'width
   (* multiple fill-column))
  ;; (modify-frame-parameters
  ;;  nil
  ;;  '((width . (+ (* multiple fill-column) 2))))
  (message "%s %i" "frame width is " (frame-parameter nil 'width))
  (message "%s %i" "fill-column is " fill-column))

(pretty-hydra-define neh/toggles
  (:color amaranth
   :quit-key ("q" "<escape>")
   :title (format " %s Options"
                  (all-the-icons-faicon "sliders"
                                        :v-adjust 0.02)))

  ("Formatting"
   (("v" global-visual-line-mode "visual lines" :toggle t)
    ("w" whitespace-mode "whitespace" :toggle t)
    ("f" visual-fill-column-mode "visual fill" :toggle t)
    ("c" rainbow-mode "colours" :toggle t)
    ("t" toggle-truncate-lines "truncate lines" :toggle truncate-lines)
    ("d" rainbow-delimiters-mode "delimiters" :toggle t))
   "UI"
   (("l" global-hl-line-mode "highlight line" :toggle t)
    ("k" neh/toggle-dark-mode "dark mode" :toggle neh/dark-mode :exit t)
    ("T" (neh/customize-this "neh/themeset") "themeset" :exit t)
    ("D" auto-dim-other-buffers-mode "dimmer" :toggle t)
    ("O" olivetti-mode "olivetti" :toggle t)
    ("W" writeroom-mode "writeroom" :toggle t)
    ("+" (neh/adjust-text-height 7) "bigger text")
    ("-" (neh/adjust-text-height -7) "smaller text")
    ("0" (neh/adjust-text-height 0) "reset text size"))
   "Window"
   (("1" (neh/set-frame-width 1) "single width")
    ;; ("z" (neh/set-frame-width 2) "double width")
    ("2" (set-frame-width nil (* fill-column 2)) "double width")
    ("3" (neh/set-frame-width 3) "triple width"))))

(pretty-hydra-define neh/movement
  (:color amaranth
   :quit-key ("q" "<escape>")
   :title (format " %s Movement"
                  (all-the-icons-faicon "arrows"
                                        :v-adjust 0.02)))
  ("Move Buffer"
   (("H" buf-move-left "left")
    ("T" buf-move-down "down")
    ("N" buf-move-up "up")
    ("S" buf-move-right "right"))
   "Move to Window"
   (("h" windmove-left "left")
    ("t" windmove-down "down")
    ("n" windmove-up "up")
    ("s" windmove-right "right"))
   "Split Window"
   (("|" evil-window-vsplit "vertical")
    ("-" evil-window-split "horizontal")
    ("=" balance-windows "balance")
    ("o" delete-other-windows "delete others"))
   "Move Window"
   (("M-h" evil-window-move-far-left "far left")
    ("M-t" evil-window-move-very-bottom "bottom")
    ("M-n" evil-window-move-very-top "top")
    ("M-s" evil-window-move-far-right "far right"))
   "Close"
   (("x" bury-buffer "bury buffer")
    ("X" kill-current-buffer "delete buffer")
    ("c" evil-window-delete "close window"))
   ))
#+end_src

Not using this one yet, but will allow associating a hydra to any major mode to provide common commands.

#+begin_src emacs-lisp :noweb yes
(use-package major-mode-hydra
  :general
  (neh/leader-keys
    "." #'major-mode-hydra)

  :custom
  (major-mode-hydra-title-generator
   '(lambda (mode)
      (s-concat (s-repeat 1 " ")
                (all-the-icons-icon-for-mode mode :v-adjust 0.05)
                " "
                (symbol-name mode)
                " commands")))

  :config
  (major-mode-hydra-define emacs-lisp-mode
    (:color amaranth :quit-key ("q" "<escape>"))
    ("Eval"
     (("b" eval-buffer "buffer" :exit t)
      ("e" eval-defun "defun")
      ("r" eval-region "region"))
     "REPL"
     (("I" ielm "ielm"))
     "Doc"
     (("d" describe-foo-at-point "thing-at-pt")
      ("f" describe-function "function")
      ("v" describe-variable "variable"))))
  <<major-mode-hydras>>
  )
#+end_src

* Reading and Note-taking

First, set up =pdf-tools= for nice PDF handling.

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :hook (pdf-view-mode . (lambda () (blink-cursor-mode -1)))
  :custom
  (pdf-view-display-size 'fit-page))
#+end_src

PDF link handling in =org-mode=.

#+begin_src emacs-lisp
(use-package org-pdftools
  :hook (org-load . org-pdftools-setup-link))
#+end_src

Add =nov.el= for =epub=s.

#+begin_src emacs-lisp 
(use-package nov
  :mode (("\\.epub\\'" . nov-mode)))
#+end_src

Try out =org-noter=.

#+begin_src emacs-lisp
(use-package org-noter
  :commands (org-noter)
  :config
  (org-noter-set-auto-save-last-location t))
#+end_src

* Gaming

#+begin_src emacs-lisp :lexical no
(use-package org-d20
  :commands (org-d20-mode)
  :init
  (put 'org-d20-party 'safe-local-variable
       (lambda (x) (listp x))))
#+end_src

* Email

#+begin_src emacs-lisp
(use-package notmuch
  :straight nil
  :commands (notmuch)
  :custom
  (notmuch-show-logo nil)
  )

;; doesn't exist any more maybe?
;; (use-package org-notmuch)
#+end_src

* Chat

#+begin_src emacs-lisp
(use-package plz
  :straight (plz
             :type git
             :host github
             :repo "alphapapa/plz.el"))

(use-package ement
  :straight (ement
             :type git
             :host github
             :repo "alphapapa/ement.el")
  :commands (ement-connect))
#+end_src

#+begin_src emacs-lisp
(use-package mastodon
  :custom
  (mastodon-instance-url "https://hachyderm.io")
  (mastodon-active-user "neh"))
#+end_src

* Misc packages

#+begin_src emacs-lisp
(use-package goto-addr
  :straight nil
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
         ("<RET>" . goto-address-at-point)
         ("M-<RET>" . newline))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+end_src

#+begin_src emacs-lisp
(use-package detached
  :init
  (detached-init)
  :bind (;; Replace `async-shell-command' with `detached-shell-command'
         ([remap async-shell-command] . detached-shell-command)
         ;; Replace `compile' with `detached-compile'
         ([remap compile] . detached-compile)
         ([remap recompile] . detached-compile-recompile)
         ;; Replace built in completion of sessions with `consult'
         ([remap detached-open-session] . detached-consult-session))
  :custom ((detached-show-output-on-attach t)
           ;; don't use fish here
           (detached-shell-program "/usr/bin/env bash")
           (detached-terminal-data-command system-type)))
#+end_src

#+begin_src emacs-lisp
(use-package sqlformat
  :commands (sqlformat
             sqlformat-buffer
             sqlformat-region
             sqlformat-on-save-mode)
  :custom
  (sqlformat-command 'pgformatter)
  (sqlformat-args '("-f1"
                    "-u1"
                    "--spaces=2"))
  )
#+end_src

#+begin_src emacs-lisp
(use-package x509-mode
  :commands (x509-dwim))
#+end_src

#+begin_src emacs-lisp
(use-package websearch
  :commands (websearch
             websearch-mode))
#+end_src

#+begin_src emacs-lisp
(use-package tabspaces
  :hook (after-init . tabspaces-mode)
  :commands (tabspaces-switch-or-create-workspace
             tabspaces-open-or-create-project-and-workspace)

  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "default")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '("*scratch*"))
  ;; sessions
  (tabspaces-session nil)
  (tabspaces-session-auto-restore nil)

  :config
  (with-eval-after-load 'consult
    ;; hide full buffer list (still available with "b" prefix)
    (consult-customize consult--source-buffer :hidden t :default nil)
    ;; set consult-workspace buffer list
    (defvar consult--source-workspace
      (list :name     "Workspace Buffers"
            :narrow   ?w
            :history  'buffer-name-history
            :category 'buffer
            :state    #'consult--buffer-state
            :default  t
            :items    (lambda () (consult--buffer-query
                                  :predicate #'tabspaces--local-buffer-p
                                  :sort 'visibility
                                  :as #'buffer-name)))

      "Set workspace buffer list for consult-buffer.")
    (add-to-list 'consult-buffer-sources 'consult--source-workspace))
  )
#+end_src

#+begin_src emacs-lisp
(use-package iedit
  :commands (iedit-mode
             iedit-rectangle-mode)
  :general
  (general-define-key
   :states '(normal visual)
   "C-;" #'iedit-mode)
  )
#+end_src

#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
#+end_src

#+begin_src emacs-lisp
(use-package diff-at-point
  :commands (diff-at-point-open-and-goto-hunk
             diff-at-point-goto-source-and-close)
  :general
  (general-define-key
   :keymaps 'diff-mode-shared-map
   :states '(normal visual)
   "gG" #'diff-at-point-goto-source-and-close)
  )
#+end_src

#+begin_src emacs-lisp
(use-package rfc-mode
  :commands (rfc-mode-browse
             rfc-mode-read))
#+end_src

#+begin_src emacs-lisp
(use-package dwim-shell-command
  :config
  (require 'dwim-shell-commands))
#+end_src

#+begin_src emacs-lisp
(use-package tree-sitter
  :hook
  (tree-sitter-after-on . tree-sitter-hl-mode)
  :config
  ;; activate tree-sitter on any buffer containing code for which it has a parser available
  (global-tree-sitter-mode t))

(use-package tree-sitter-langs
  :after tree-sitter)
#+end_src

#+begin_src emacs-lisp
(use-package apheleia
  :config
  (apheleia-global-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package org-web-tools
  :commands (org-web-tools-insert-web-page-as-entry
             org-web-tools-read-url-as-org))
#+end_src

New smooth scrolling in emacs 29, would like to see if I can maybe combine it with scrollkeeper-style highlighting.

#+begin_src emacs-lisp
(use-package pixel-scroll
  :straight nil
  :if (>= emacs-major-version 29)
  :commands (pixel-scroll-precision-mode)
  :custom
  (pixel-scroll-precision-interpolate-page t)
  (pixel-scroll-precision-interpolation-factor 2.0)
  (pixel-scroll-precision-large-scroll-height nil)
  :init
  (pixel-scroll-precision-mode t))
#+end_src
#+end_src

#+begin_src emacs-lisp
(use-package treemacs
  :commands (treemacs)
  :general
  (:keymaps 'treemacs-mode-map
   :states 'treemacs
   "t" #'treemacs-next-line
   "n" #'treemacs-previous-line))

(use-package treemacs-evil
  :after (treemacs
          evil))

(use-package treemacs-projectile
  :after (treemacs
          projectile))

(use-package treemacs-magit
  :after (treemacs
          magit))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package evil-string-inflection
  :after evil)
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package literate-calc-mode
  :commands (literate-calc-mode
             literate-calc-minor-mode)
  :general
  (neh/leader-keys
    :keymaps 'org-mode-map
    "vC" #'literate-calc-minor-mode))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package journalctl-mode
  :commands (journalctl
             journalctl-boot
             journalctl-unit
             journalctl-user-unit))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package no-littering)
#+end_src

#+begin_src emacs-lisp
(use-package kubedoc
  :commands (kubedoc))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package kubernetes
  :commands (kubernetes-overview))

(use-package kubernetes-evil
  :after kubernetes)
#+end_src

#+begin_src emacs-lisp
(use-package kubel
  :commands (kubel
             kubel-set-namespace
             kubel-set-context
             kubel-set-resource))
#+end_src

#+begin_src emacs-lisp
(use-package docker
  :commands (docker))
#+end_src

#+begin_src emacs-lisp
(use-package lispy
  :commands (lispy-mode))

(use-package lispyville
  :hook (lispy-mode . lispyville-mode))
#+end_src

#+begin_src emacs-lisp
(use-package compile
  :straight nil
  :custom
  (compilation-scroll-output 'first-error)
  )

(use-package xterm-color
  :custom
  (compilation-environment '("TERM=xterm-256color"))
  :config
  (defun my/advice-compilation-filter (f proc string)
    (funcall f proc (xterm-color-filter string)))
  (advice-add 'compilation-filter :around #'my/advice-compilation-filter))
#+end_src

#+begin_src emacs-lisp
(use-package run-command
  :commands (run-command)
  :custom
  (run-command-recipes '(run-command-recipe-terraform-init
                         run-command-recipe-terraform-init-upgrade
                         run-command-recipe-terraform-plan
                         run-command-recipe-terraform-plan-continuous
                         run-command-recipe-terraform-apply
                         run-command-recipe-packer-build
                         run-command-recipe-packer-validate))
  (run-command-run-method 'compile)

  :init
  (defun run-command-recipe-terraform-init ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Init"
             :command-name "terraform-init"
             :command-line "terraform init"))))

  (defun run-command-recipe-terraform-init-upgrade ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Init + Upgrade"
             :command-name "terraform-init-upgrade"
             :command-line "terraform init -upgrade"))))

  (defun run-command-recipe-terraform-plan ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Plan"
             :command-name "terraform-plan"
             :command-line "terraform plan"))))

  (defun run-command-recipe-terraform-plan-continuous ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Plan Continuously On Change"
             :command-name "terraform-plan-continuous"
             :command-line (format "find . | entr terraform plan")))))

  (defun run-command-recipe-terraform-apply ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Apply"
             :command-name "terraform-apply"
             :command-line "terraform apply"))))

  (defun run-command-recipe-packer-validate ()
    (list
     (when (equal major-mode 'hcl-mode)
       (list :display "Validate"
             :command-name "packer-validate"
             :command-line "packer validate ."))))

  (defun run-command-recipe-packer-build ()
    (list
     (when (equal major-mode 'hcl-mode)
       (list :display "Build"
             :command-name "packer-build"
             :command-line "packer build -on-error=ask ."))))
  )
#+end_src

#+begin_src emacs-lisp
(use-package sudo-edit
  :after embark
  :commands (sudo-edit
             sudo-edit-find-file)
  :general
  (:keymaps 'embark-file-map
   "$" #'sudo-edit-find-file)
  (:keymaps 'embark-become-file+buffer-map
   "$" #'sudo-edit-find-file))
#+end_src

#+begin_src emacs-lisp
(use-package scratch
  :commands (scratch))
#+end_src

#+begin_src emacs-lisp
(use-package link-hint
  :general
  (neh/leader-keys
    :states '(normal)
    :prefix "SPC"
    :non-normal-prefix "C-SPC"
    "F" #'link-hint-open-link))
#+end_src

#+begin_src emacs-lisp
(use-package frames-only-mode
  :disabled t
  :commands (frames-only-mode)
  :custom
  (frames-only-mode-use-window-functions '(calendar
                                           report-emacs-bug
                                           checkdoc-show-diagnostics
                                           checkdoc
                                           org-sidebar
                                           org-sidebar-tree
                                           org-sidebar-toggle
                                           org-compile-file
                                           embark-act
                                           embark-collect-live
                                           embark-collect-snapshot))

  (frames-only-mode-configuration-variables
   '((pop-up-frames graphic-only)
     (mouse-autoselect-window nil)
     (focus-follows-mouse nil)
     (frame-auto-hide-function delete-frame)
     (org-agenda-window-setup other-frame)
     (org-src-window-setup other-frame)
     (ediff-window-setup-function ediff-setup-windows-plain)
     (ido-default-buffer-method selected-window)
     (magit-commit-show-diff t)
     (magit-bury-buffer-function frames-only-mode-magit-bury-buffer-function)
     ;; (magit-bury-buffer-function delete-frame)
     (flycheck-display-errors-function frames-only-mode-flycheck-display-errors)))

  :init
  (frames-only-mode -1))
#+end_src

#+begin_src emacs-lisp
(use-package hl-line-mode
  :straight nil
  :commands (hl-line-mode
             global-hl-line-mode))
#+end_src

#+begin_src emacs-lisp
(use-package buffer-move
  :commands (buf-move-left
             buf-move-down
             buf-move-up
             buf-move-right))
#+end_src

#+begin_src emacs-lisp
(use-package edit-indirect
  :commands (edit-indirect-region))
#+end_src

#+begin_src emacs-lisp
(use-package dumb-jump
  :commands (xref-find-definitions
             xref-find-definitions-other-window)
  :hook (xref-backend-functions #'dumb-jump-xref-activate)
  :general
  (general-def
    :states 'normal
    :prefix "j"
    "d" #'xref-find-definitions)
  :custom
  (dumb-jump-prefer-searcher 'rg))
#+end_src

#+begin_src emacs-lisp
(use-package deadgrep
  :init
  (defun neh/deadgrep-context-adjust (amount)
    (let* ((old-before (or (car deadgrep--context) 0))
           (old-after (or (cdr deadgrep--context) 0))
           (before (+ old-before amount))
           (after (+ old-after amount)))

      (setq-local deadgrep--context (cons (if (< before 0) 0 before)
                                          (if (< after 0) 0 after)))
      (deadgrep-restart)))

  (defun neh/deadgrep-here ()
    (interactive)
      (deadgrep (deadgrep--read-search-term) default-directory))

  :general
  (neh/leader-keys
    "sr" #'deadgrep
    "sR" #'neh/deadgrep-here)

  (general-define-key
   :keymaps 'deadgrep-mode-map
   :states '(emacs normal)
   "M-n" #'deadgrep-backward-match
   "M-t" #'deadgrep-forward-match
   "M-<up>" #'deadgrep-backward-match
   "M-<down>" #'deadgrep-forward-match
   "M-h" #'deadgrep-backward-filename
   "M-s" #'deadgrep-forward-filename
   "D" #'deadgrep-search-directory
   "S" #'deadgrep-search-term
   "+" (lambda ()
         (interactive)
         (neh/deadgrep-context-adjust 2))
   "-" (lambda ()
         (interactive)
         (neh/deadgrep-context-adjust -2)))

  :config
  (general-add-advice (list #'deadgrep-backward-filename
                            #'deadgrep-forward-filename)
                      :after #'neh/recenter-after)

  (defun neh/deadgrep--include-args (rg-args)
    (when (string= (projectile-project-name) ".config")
      ;; (push "--hidden" rg-args) ;; consider hidden folders/files
      ;; (push "--follow" rg-args) ;; follow symlink
      (push "--no-ignore-vcs" rg-args) ;; ignore .gitignore
      ))

  (advice-add 'deadgrep--arguments :filter-return #'neh/deadgrep--include-args)
  )
#+end_src

#+begin_src emacs-lisp
(use-package image-mode
  :straight nil
  :hook (image-mode . (lambda () (blink-cursor-mode -1))))
#+end_src

#+begin_src emacs-lisp
;; The auto-decrypt-encrypt hook complains about the password-file var not being set, even though
;; the manual encrypt/decrypt functions work just fine.
(use-package ansible
  :commands (ansible ansible-auto-decrypt-encrypt)
  :hook ((yaml-mode . ansible)
         (ansible . ansible-auto-decrypt-encrypt))
  :custom
  (ansible-vault-password-file ""))
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :general
  (neh/leader-keys
    "vd" #'rainbow-delimiters-mode)

  :custom-face
  (rainbow-delimiters-unmatched-face ((t (:height 1.0 :inherit 'error))))
  (rainbow-delimiters-depth-1-face ((t (:height 1.0))))
  (rainbow-delimiters-depth-2-face ((t (:height 1.1))))
  (rainbow-delimiters-depth-3-face ((t (:height 1.2))))
  (rainbow-delimiters-depth-4-face ((t (:height 1.3))))
  (rainbow-delimiters-depth-5-face ((t (:height 1.4))))
  (rainbow-delimiters-depth-6-face ((t (:height 1.5))))
  (rainbow-delimiters-depth-7-face ((t (:height 1.6))))
  (rainbow-delimiters-depth-8-face ((t (:height 1.7))))
  (rainbow-delimiters-depth-9-face ((t (:height 1.8)))))
#+end_src

#+begin_src emacs-lisp
(use-package wgrep
  :commands wgrep-change-to-wgrep-mode)
#+end_src

#+begin_src emacs-lisp
(use-package elec-pair
  :ensure nil
  :hook (prog-mode . electric-pair-mode)
  :custom
  (electric-pair-skip-whitespace nil))
#+end_src

#+begin_src emacs-lisp
(use-package executable
  :ensure nil
  :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

#+begin_src emacs-lisp
(use-package quick-peek
  :commands (quick-peek-show
             quick-peek-hide
             quick-peek-overlay-contents
             quick-peek-overlay-ensure-at)
  :custom
  (quick-peek-add-spacer nil))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck
  :disabled
  :hook (prog-mode . flycheck-mode)
  :custom (flycheck-check-syntax-automatically '(save mode-enabled)))

(use-package flycheck-inline
  :disabled
  :hook (flycheck-mode . turn-on-flycheck-inline)

  :init
  (setq flycheck-inline-display-function
        (lambda (msg pos err)
          (let* ((ov (quick-peek-overlay-ensure-at pos))
                 (contents (quick-peek-overlay-contents ov)))
            (setf (quick-peek-overlay-contents ov)
                  (concat contents (when contents "\n") msg))
            (quick-peek-update ov)))
        flycheck-inline-clear-function #'quick-peek-hide)

  :custom-face
  (flycheck-inline-info ((t (:height 1.0
                             :foreground "#000000" :background "#87ceeb"
                             :inherit 'info
                              :extend t
                             :box (:line-width 5 :color "#87ceeb")))))
  (flycheck-inline-warning ((t (:height 1.0
                                :foreground "#000000" :background "#ffd700"
                                :inherit 'warning
                                :extend t
                                :box (:line-width 5 :color "#ffd700")))))
  (flycheck-inline-error ((t (:height 1.0
                              :foreground "#ffffff" :background "#b22222"
                              :inherit 'error
                              :extend t
                              :box (:line-width 5 :color "#b22222"))))))

(use-package flycheck-posframe
  :disabled
  :hook (flycheck-mode . flycheck-posframe-mode)
  :config
  (set-face-attribute 'flycheck-posframe-warning-face nil
                      :height 1.1 :foreground "#111111" :background "#ffd700" :inherit 'warning)
  (set-face-attribute 'flycheck-posframe-error-face nil
                      :height 1.1 :foreground "#eeeeee" :background "#b22222" :inherit 'error))
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-mode
  :general
  (neh/leader-keys
    "vc" #'rainbow-mode))
#+end_src

#+begin_src emacs-lisp
(use-package pulsar
  :hook (focus-in . pulsar-pulse-line)
  :custom
  (pulsar-delay 0.08)
  :init
  (pulsar-global-mode t)

  :config
  (dolist (item '(evil-window-left
                  evil-window-right
                  evil-window-up
                  evil-window-down))
    (add-to-list 'pulsar-pulse-functions item))
  )
#+end_src

#+begin_src emacs-lisp
(use-package hi-lock
  :straight nil
  :general
  (neh/leader-keys
    :infix "h"
    "l" #'highlight-lines-matching-regexp
    "r" #'highlight-regexp
    "u" #'unhighlight-regexp)
  )
#+end_src

#+begin_src emacs-lisp
(use-package symbol-overlay
  :general
  (general-def
    :keymaps 'symbol-overlay-map
    "i" nil
    "n" nil
    "p" nil
    "t" nil
    "s" nil
    "h" nil

    "?" 'symbol-overlay-map-help

    "S" 'symbol-overlay-toggle-in-scope

    "M-n" '(lambda () (interactive) (symbol-overlay-jump-prev) (recenter))
    "M-t" '(lambda () (interactive) (symbol-overlay-jump-next) (recenter))
    "M-<up>" '(lambda () (interactive) (symbol-overlay-jump-prev) (recenter))
    "M-<down>" '(lambda () (interactive) (symbol-overlay-jump-next) (recenter))
    "M-N" '(lambda () (interactive) (symbol-overlay-switch-backward) (recenter))
    "M-T" '(lambda () (interactive) (symbol-overlay-switch-forward) (recenter))

    "c" 'symbol-overlay-put
    "C" 'symbol-overlay-remove-all)

  (neh/leader-keys
    "hs" #'symbol-overlay-put
    "hn" #'symbol-overlay-switch-backward
    "ht" #'symbol-overlay-switch-forward
    "hc" #'symbol-overlay-remove-all
    "hM" #'symbol-overlay-mode))
#+end_src

#+begin_src emacs-lisp
(use-package aggressive-indent
  :disabled
  :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package envrc
  :hook (after-init . envrc-global-mode)
  :ensure-system-package (direnv))
#+end_src

#+begin_src emacs-lisp
(use-package jinja2-mode
  :mode (("\\.j2\\'" . jinja2-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode (("\\.clj\\'" . clojure-mode)))

(use-package cider
  :commands (cider
             cider-mode
             cider-jack-in)
  )

(use-package ob-clojure
  :straight nil
  :after org
  :custom
  (org-babel-clojure-backend 'cider)
  :commands
  (org-babel-execute:clojure))
#+end_src

#+begin_src emacs-lisp
(defun my-evil-indent-setup ()
  "Set evil-shift-width to the relevant language indent level (but yaml only, so far)."
  (setq evil-shift-width yaml-indent-offset))

(use-package yaml-mode
  :disabled
  :gfhook #'my-evil-indent-setup
  :commands yaml-mode
  :mode (("\\(host\\|group\\)_vars.*" . yaml-mode)
         ("\\.*cloud-\\(init\\|config\\).*" . yaml-mode)
         ("\\.yml|yaml\\'" . yaml-mode))
  :init
  (add-to-list 'magic-mode-alist '("#cloud-config" . yaml-mode)))

(use-package yaml-pro
  :mode (("\\(host\\|group\\)_vars.*" . yaml-pro-ts-mode)
         ("\\.*cloud-\\(init\\|config\\).*" . yaml-pro-ts-mode)
         ("\\.yml|yaml\\'" . yaml-pro-ts-mode))
  :commands (yaml-pro-ts-mode)
  :init
  (add-to-list 'magic-mode-alist '("#cloud-config" . yaml-pro-ts-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package json-mode
  :mode (("\\.json\\'" . json-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package counsel-jq
  :commands (counsel-jq))
#+end_src

#+begin_src emacs-lisp
(use-package scad-mode
  :mode (("\\.scad__'" . scad-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package gcode-mode
  :mode (("\\.gcode__'" . gcode-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package expand-region
  :general
  (general-define-key
   :states 'visual
   "v" 'er/expand-region
   "V" 'er/contract-region))
#+end_src

#+begin_src emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode)
  :mode ("\\.md'" . markdown-mode))
#+end_src

#+begin_src emacs-lisp
(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode))
#+end_src

#+begin_src emacs-lisp
(defun neh/python-mode-hook ()
  "My python mode settings."
  (setq-local fill-column 80)
  (auto-virtualenv-set-virtualenv)
  ;; (lsp-deferred)
  )

(use-package python-mode
  :straight nil
  :hook (python-mode . neh/python-mode-hook)
  :custom
  (python-shell-interpreter "python3")
  (org-babel-python-command "python3"))

(use-package pyvenv
  :commands (pyvenv-activate))

(use-package auto-virtualenv
  :commands (auto-virtualenv-set-virtualenv))

(use-package lsp-mode
  :disabled
  :init
  ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  (setq lsp-keymap-prefix "C-c l")
  :commands (lsp
             lsp-deferred))

(use-package lsp-ui
  :disabled
  :after lsp-mode)

(use-package lsp-pyright
  :disabled
  )
#+end_src

#+begin_src emacs-lisp
(use-package eglot
  :straight nil
  :config
  (add-to-list 'eglot-server-programs
               '(terraform-mode . ("terraform-ls" "serve"))))
#+end_src

#+begin_src emacs-lisp
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
#+end_src

#+begin_src emacs-lisp
(use-package hcl-mode
  :commands hcl-mode)

(use-package terraform-mode
  :mode ("\\.tf|tfvars\\'" . terraform-mode)
  :hook ((terraform-mode . yas-minor-mode-on))
  :custom-face
  (terraform--resource-type-face
   ((t (:inherit 'font-lock-constant-face))))
  (terraform--resource-name-face
   ((t (:inherit 'font-lock-variable-name-face))))
  :config
  (delete 'gnu compilation-error-regexp-alist)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(terraform-error
                 "^Error: [[:print:]]+[[:space:]]+[[:blank:]]+on \\([^[:blank:]]+\\) line \\([[:digit:]]+\\)[,:]"
                 1 2))
  (add-to-list 'compilation-error-regexp-alist
               'terraform-error))
#+end_src

#+begin_src emacs-lisp
(use-package groovy-mode
  :mode ("Jenkinsfile\\'" . groovy-mode))
#+end_src

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile\\'" . dockerfile-mode))
#+end_src

#+begin_src emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")

(use-package go-eldoc
  :commands go-eldoc-setup
  :hook (go-mode . go-eldoc-setup))
#+end_src

#+begin_src emacs-lisp
(use-package csv-mode
  :mode "\\.csv\\'")
#+end_src

#+begin_src emacs-lisp
(use-package elf-mode
  :commands elf-mode
  :magic ("ELF" . elf-mode))
#+end_src

* Misc functions

#+begin_src emacs-lisp
;; from https://www.reddit.com/r/emacs/comments/l51ocx/what_is_the_most_useful_part_of_your_emacs_config/gkrz1di
(defun insert-date ()
  "Insert today's date at point"
  (interactive "*")
  (insert (format-time-string "%F")))

(general-define-key
 :states '(normal insert)
  "C-c C-." #'insert-date)
#+end_src

#+begin_src emacs-lisp :lexical no
(defun neh/indent-buffer ()
  "Indent the current buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

(defun neh/indent-region-or-block-or-buffer ()
  "Indent the active region, org src block, or the current buffer."
  (interactive)
  (save-excursion
    (cond ((region-active-p)
           (indent-region (region-beginning) (region-end)))
          ((and (string= major-mode 'org-mode)
                (org-in-src-block-p))
           (let ((context (org-element-context)))
             (indent-region (plist-get (cl-second context) :begin)
                            (plist-get (cl-second context) :end))))
          (t (neh/indent-buffer)))))

(defun neh/indent-region-or-buffer ()
  "Indent the active region or the current buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (indent-region (region-beginning) (region-end))
      (neh/indent-buffer))))

(general-define-key
 :states 'normal
 "=" #'neh/indent-region-or-block-or-buffer)
#+end_src

A nice couple of functions for opening files from dired asynchronously. Handy use of =nohup= so external programs keep running when the launching emacs exits. This is a combination of bits from [[https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/][this thread on reddit]].

#+begin_src emacs-lisp :lexical no
(defun open-file-external (file)
  "Open a file externally with xdg-open."
  (interactive "f")
  (let ((process-connection-type nil))
    (start-process
     "" nil shell-file-name
     shell-command-switch
     (format "nohup 1>/dev/null 2>/dev/null xdg-open %s"
             (expand-file-name file)))))

(defun neh/dired-open()
  (interactive)
  (cond
   ;; use dired-find-file if it is a directory
   ((file-directory-p (dired-get-file-for-visit))
    (dired-find-file))
   ;; use dired-find-file if the mime type of the file is emacs.desktop
   ((string= "emacs.desktop" (string-trim-right (shell-command-to-string
                                                 (format "xdg-mime query filetype %s | xargs xdg-mime query default"
                                                         (shell-quote-argument (dired-get-file-for-visit))))))
    (dired-find-file))
   (t
    ;; use xdg-open for everything else
    (open-file-external (shell-quote-argument (dired-get-file-for-visit))))))
#+end_src

This function gives me a quicker way to edit src blocks in org mode, as well as making indirect buffer cloning a bit /less/ accessible (only on headings), since I do it relatively infrequently and have actually been ending up in indirect buffers a bit /too/ easily. I just bind this to =enter= in org mode.

#+begin_src emacs-lisp
(defun neh/org-ret ()
  "Make RET either narrow to the heading at point or edit the src block at point."
  (interactive)
  (cond ((org-at-heading-p) (org-tree-to-indirect-buffer))
        ((org-in-src-block-p) (org-edit-src-code))))

(defun neh/org-shift-ret ()
  "Make S-RET either narrow to the heading at point or edit the src block at point."
  (interactive)
  (cond ((org-at-heading-p) (org-tree-to-indirect-buffer-other-frame))
        ((org-in-src-block-p) (org-edit-src-code))
        ))
#+end_src

I wanted a way to move org items to the top of their own level, and found one [[https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent][on stackoverflow]]. I inverted its behaviour to move to the top by default, and to the bottom with a prefix arg.

#+begin_src emacs-lisp
(defun JK-org-move-to-extreme (down)
  "Move current org subtree to the start of its parent.
With prefix arg move subtree to the end of its parent."
  (interactive "P")
  (condition-case err
      (while t
        (funcall (if down
                     'org-move-subtree-down
                   'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg)))))))
#+end_src

Ending up at the bottom of the window and not being able see enough context when jumping around is annoying, so I have this to help deal with that by recentering after jumps.

#+begin_src emacs-lisp
(defun neh/after-jump (&optional arg)
  "Center text at point after jumping."
  (evil-scroll-line-to-center (line-number-at-pos)))
#+end_src

Attaching this next one to =org-src-mode= will disable the annoying flycheck warnings that are really only relevant to complete files.

#+begin_src emacs-lisp
(defun disable-flycheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src

#+begin_src emacs-lisp
(defun narrow-to-region-indirect (start end)
  "Restrict editing in this buffer to the current region (from START to END), indirectly."
  (interactive "r")
  (deactivate-mark)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-region start end))
    (switch-to-buffer buf)))
#+end_src

#+begin_src emacs-lisp
(defun shorten-directory (dir max-length)
  "Show up to MAX-LENGTH characters of a directory name DIR."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
        (output ""))
    (when (and path (equal "" (car path)))
      (setq path (cdr path)))
    (while (and path (< (length output) (- max-length 4)))
      (setq output (concat (car path) "/" output))
      (setq path (cdr path)))
    (when path
      (setq output (concat "…/" output)))
    output))
#+end_src

#+begin_src emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
        (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))
#+end_src

#+begin_src emacs-lisp
;; https://github.com/noctuid/general.el#use-package-keyword
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
(defun Fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.

  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:

  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);

  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;

  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.

  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))

(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'Fuco1/lisp-indent-function)))
#+end_src

#+begin_src emacs-lisp
;; from https://stackoverflow.com/questions/47327066/how-to-open-an-indirect-buffer-in-a-new-frame-in-a-single-call-in-emacs
(defun clone-indirect-buffer-other-frame (newname display-flag &optional norecord)
  "Like `clone-indirect-buffer' but display in another frame."
  (interactive
   (progn
     (if (get major-mode 'no-clone-indirect)
         (error "Cannot indirectly clone a buffer in %s mode" mode-name))
     (list (if current-prefix-arg
               (read-buffer "Name of indirect buffer: " (current-buffer)))
           t)))
  ;; (let ((pop-up-windows t))
  (let ((pop-up-frames t)) ; <==========
    (clone-indirect-buffer newname display-flag norecord)))
#+end_src

#+begin_src emacs-lisp
(defun org-tree-to-indirect-buffer-other-frame ()
  (interactive)
   (let ((org-indirect-buffer-display 'new-frame))
     (org-tree-to-indirect-buffer)))
#+end_src
