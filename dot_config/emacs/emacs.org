#+property: header-args:emacs-lisp :tangle (concat user-emacs-directory "init.el")
#+property: header-args :mkdirp yes :comments no :results silent
#+startup: showall inlineimages

#+title: My Emacs config file
#+author: Nathan Howell
#+email: nath@nhowell.net

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. This configuration was heavily influenced/started from [[http://zzamboni.org/post/my-emacs-configuration-with-commentary/][Diego Zamboni’s configuration]], as well as [[https://github.com/blaenk/dots/tree/master/emacs/.emacs.d][Jorge Israel Peña's]].

This is a handy command I’ve been using to test as I move to a literate config. =C-c C-c= will launch a new emacs, using the tangled version of this config.
#+begin_src shell :tangle no :results silent
emacs -Q -l profile-dotemacs.el --eval "(setq profile-dotemacs-file (setq load-file-name \"/home/nathan/.emacs.d/init.el\"))" -f profile-dotemacs
#+end_src


* Initialization
:properties:
:header-args:emacs-lisp: :tangle (concat user-emacs-directory "early-init.el")
:end:

Since this is a literate configuration, a small =init.el= file is needed to handle tangling and loading the rest of the configuration when necessary. That file gets created here, and the tangled result needs to be committed to the git repository whenever any changes are made to it here.

Right up front, enable [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][lexical binding]].

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

Next, we wrap the whole init file in a block that sets =file-name-handler-alist= to =nil= to prevent any special-filename parsing of files loaded from the init file (e.g. remote files loaded through tramp, etc.). Rather than having a block that closes this later, let's pull in the rest of the init file bits with noweb references.

#+begin_src emacs-lisp :noweb yes
(let ((file-name-handler-alist nil))
  <<init-gc-init>>
  <<early-init-elpaca>>
  <<init-use-package>>
  <<init-gc-setup>>)
#+end_src

We set =gc-cons-threshold= to its maximum value, to prevent any garbage collection from happening during load time. We also reset this value in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp :tangle no :noweb-ref init-gc-init
(setq gc-cons-threshold most-positive-fixnum)
#+end_src


#+begin_src emacs-lisp :tangle no :noweb-ref init-elpaca
(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

(setq elpaca-lock-file (expand-file-name "versions.lock" elpaca-directory))

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode))
(elpaca-wait)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref early-init-elpaca
(setq package-enable-at-startup nil)
#+end_src

I'm using emacs 29 everywhere, which has =use-package= built in, so just assume it's there and do a little configuration. Also, require =org-mode= as early as possible to (hopefully) avoid version mismatch issues.

#+begin_src emacs-lisp :tangle no :noweb-ref init-use-package
(setq use-package-verbose nil
      use-package-always-ensure t)
#+end_src

Load =org-mode=. This needs to happen early, or emacs will load and use its bundled version of =org-mode=, which is just too old.
Here's also where the rest of this file gets tangled and loaded, but only if it's newer than the existing tangled file. Tangling is slow (at least it is when you start using no-web references...), so we don't want to do it for no good reason.


#+begin_src emacs-lisp :tangle no :noweb-ref init-org
(use-package org
  :config
  (message "%s" (org-version))
  (setq custom-enabled-themes '())

  (let ((orgfile (concat user-emacs-directory "emacs.org"))
        (elfile (concat user-emacs-directory "init.el"))
        (earlyfile (concat user-emacs-directory "early-init.el")))
    (when (or (not (file-exists-p elfile))
              (file-newer-than-file-p orgfile elfile)
              (file-newer-than-file-p orgfile earlyfile))
      (org-babel-tangle-file orgfile))))
#+end_src

Then reset the value of =gc-cons-threshold=, not to its original value; we still leave it much larger than default so that GCs don't happen so often and impact performance. We also tweak =gc-cons-percentage= and set an idle timer to run =garbage-collect= whenever emacs is idle for 5 seconds.

#+begin_src emacs-lisp :tangle no :noweb-ref init-gc-setup
(setq gc-cons-threshold (* 3200 1000)
      gc-cons-percentage 0.6)

(defvar my/gc-idle-timer nil)
(unless (timerp my/gc-idle-timer)
  (setq my/gc-idle-timer (run-with-idle-timer 5 t #'garbage-collect)))
#+end_src

Another interesting option here, gc when unfocusing a frame, from https://news.ycombinator.com/item?id=31394001

#+begin_src emacs-lisp :tangle no
(add-function :after
  after-focus-change-function
  (lambda () (unless (frame-focus-state)
               (garbage-collect))))
#+end_src

* Performance optimization

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :noweb yes
<<init-elpaca>>
#+end_src

#+begin_src emacs-lisp :noweb yes
<<org>>
(elpaca-wait)
#+end_src

Lately I've been playing with optimizing my Emacs load time. I have found a couple of useful resources, including:

- [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][Two easy little known steps to speed up Emacs start up time]]
- [[https://blog.d46.us/advanced-emacs-startup/][Advanced Techniques for Reducing Emacs Startup Time]]

Based on these, I have added the code below.

First, a hook that reports how long and how many garbage collections the startup took. Use a hook so the message doesn't get clobbered by other messages.

#+begin_src emacs-lisp
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

Set up ESUP for startup profiling.

#+begin_src emacs-lisp
(use-package esup
  :commands (esup))
#+end_src

* Base settings

Load any host-specific configuration. Anything set here will just get overridden by deferred package loads so the way I’m dealing with that is to set vars here with different (=my/…=) names, then set the real vars conditionally in package configurations elsewhere.

#+begin_src emacs-lisp
(setq my/local-conf-file (expand-file-name
                           (concat system-name ".el")
                           user-emacs-directory))
(when (file-readable-p my/local-conf-file)
  (load-file my/local-conf-file))
#+end_src

For some keymaps, I want to have multiple packages contribute key bindings, while being able to set a name for the map etc., which as far as I can tell can't be done using the =:bind= convenience of =use-package=. So I'm defining those keymaps here, then the packages can add their bindings later.

#+begin_src emacs-lisp
(defvar-keymap my/window-map
  :doc "My general window/navigation keys."
  :name "Windows")

(defvar-keymap my/notes-map
  :doc "My note-related keys.")

(defvar-keymap my/search-map
  :doc "My search-related keys.")

(defvar-keymap my/git-map
  :doc "My git-related keys.")

(defun my/set-override-keybindings ()
  (keymap-set ctl-x-map "/" my/search-map)
  (keymap-set ctl-x-map "g" my/git-map)
  (keymap-set ctl-x-map "k" #'kill-current-buffer)
  (keymap-set ctl-x-map "n" my/notes-map)
  ;; this clobbers built-in bindings, want them to merge instead
  (keymap-set ctl-x-map "w" my/window-map))
(add-hook 'elpaca-after-init-hook #'my/set-override-keybindings)
#+end_src

Collect all the global, non-package-specific settings here.

#+begin_src emacs-lisp :noweb yes
(use-package emacs
  :ensure nil
  :custom
  <<emacs-custom>>

  :hook
  (minibuffer-setup . cursor-intangible-mode)

  :bind
  ("M-p" . mode-line-other-buffer)
  (:repeat-map buffer-switch-repeat-map
   ("." . mode-line-other-buffer))
  (<<misc-keybinds>>)

  :init
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  (defun partially-apply-interactively (cmd arg)
    (interactive)
    (minibuffer-with-setup-hook
        (lambda ()
          (insert arg)
          (add-hook 'post-command-hook #'exit-minibuffer nil t))
      (call-interactively cmd)))

  (defun my/customize-this (arg)
    "Call customize-set-variable with a specific setting pre-selected."
    (interactive)
    (partially-apply-interactively #'customize-set-variable arg))

  <<misc-functions>>

  :config
  (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

Turn off all startup messages, splash screens, menu bars, scroll bars, etc. for a clean start.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(inhibit-splash-screen t)
(inhibit-startup-message t)
(initial-scratch-message nil)
(inhibit-startup-echo-area-message t)

(tab-always-indent 'complete)

(menu-bar-mode nil)
(tool-bar-mode nil)
(scroll-bar-mode nil)
(default-frame-alist '((vertical-scroll-bars . nil)))
(initial-frame-alist '((vertical-scroll-bars . nil)))
#+end_src

Log but don't pop up a buffer for warnings during native compilation of packages. They are just too annoying with deferred package loads.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(native-comp-async-report-warnings-errors nil)
#+end_src

from https://www.wisdomandwonder.com/programming/13521/automatically-open-read-only-files-in-view-mode
#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(view-read-only t)
#+end_src

Set the window titles. Nothing fancy, just the buffer name.

#+begin_src emacs-lisp
(setq frame-title-format "%b"
      icon-title-format "%b") ;; unfocused window title format
#+end_src

Running shell commands from emacs is handy, being able to use shell aliases makes it even better, so let's have emacs run commands in an interactive shell. "-ic" looks like it works for bash and fish, while zsh/oh-my-zsh needs "-csi".

#+begin_src emacs-lisp :tangle no :noweb-rep emacs-custom
(shell-command-switch "-ic")
#+end_src

Since I force there to be no file to store custom settings in, I get prompted for things like variables in ~.dir-locals.el~ files every time they are read (as emacs can't record my answers for the next time). So I whitelist the variables and values here that I don't want to be prompted for. I'm not sure this is the /right/ way to handle this, maybe I should have a custom file just for things like this and commit it to git so I can keep it controlled. The main reason I ditched the custom file was because it ended up having a bunch of forgotten settings hanging around affecting things, which having it in git would alleviate.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(safe-local-variable-values '((auto-revert-use-notify)
                              (auto-revert-check-vc-info . nil)
                              (epa-file-encrypt-to . "C113BA91EAF8B45B6B84BDCBB600587C4549248A")
                              (org-download-image-dir)))
#+end_src

Thanks to the the discussion in [[https://github.com/doomemacs/doomemacs/issues/5219][this github issue for Doom emacs]], this seems to resolve issues with pasting into emacs from non-wayland apps.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING text/plain\;charset=utf-8))
#+end_src

I use the customization system in Emacs via ~:custom~ blocks in ~use-package~, and I don't want customized settings accumulating in a file where they can be forgotten about and trip me up later. This seems like a sane way to use the customization system to me, so we'll see.

#+begin_src emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom
  (custom-file null-device))
#+end_src

All UTF-8, all the time.

#+begin_src emacs-lisp
;; https://goyoambrosio.com/2018/06/Dealing-with-utf-8-in-Emacs/

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(set-selection-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
(set-clipboard-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

Don’t use tabs when indenting.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(indent-tabs-mode nil)
#+end_src

More options. I’m not sure where to put some things in this file yet. Here are some.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(sentence-end-double-space nil)
(ring-bell-function 'ignore)
(enable-recursive-minibuffers t)
(global-subword-mode t)

(minibuffer-prompt-properties
 '(read-only t cursor-intangible t face minibuffer-prompt))

;; hide commands in M-x that don't work in the current mode
(read-extended-command-predicate #'command-completion-default-include-p)

(completions-header-format nil)
(completion-show-help nil)
(completion-auto-select 'second-tab)
(completion-auto-help 'always)
#+end_src

Don’t warn me when I do these potentially confusing narrowing operations.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'list-timers 'disabled nil)
#+end_src

Set some backup file options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(make-backup-files nil)
(delete-old-versions t)
(backup-directory-alist `((".*" . ,temporary-file-directory)))
(auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
#+end_src

I’m testing out [[https://github.com/swaywm/sway][sway]] as my window manager, and apparently ~$SSH_AUTH_SOCK~ doesn’t get set (maybe just for xwayland apps?). So we workaround. I already set a fixed link to the real socket for tmux usage, I can reuse it for this.

#+begin_src emacs-lisp :tangle no
(when (string= (getenv "SSH_AUTH_SOCK") nil)
  (setenv "SSH_AUTH_SOCK" (format "%s/ssh-agent.socket" (getenv "XDG_RUNTIME_DIR"))))
#+end_src

Some text fill options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(fill-column 100)
(default-frame-alist '((width  . 100)))
(frame-resize-pixelwise t)
(comment-auto-fill-only-comments t)
#+end_src

Set standard emacs completion to ignore case for files and buffers.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(completion-ignore-case t)
(read-buffer-completion-ignore-case t)
(read-file-name-completion-ignore-case t)
#+end_src

Show position in the buffer as the percentage of both the top and bottom positions of the window.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(mode-line-percent-position '(6 "%q"))
#+end_src

I view man pages in emacs sometimes, and want a fixed width for them.

#+begin_src emacs-lisp
(use-package man
  :ensure nil
  :custom
  (Man-width fill-column)
  (Man-width-max fill-column)
  (Man-columns fill-column)
  (Man-notify-method 'aggressive))

(use-package woman
  :ensure nil
  :custom
  (woman-fill-column fill-column))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(line-spacing 0.2)
#+end_src

How to make display buffer names.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(uniquify-buffer-name-style 'forward)
#+end_src

Some git/vc options.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(vc-follow-symlinks t)
#+end_src

When pasting (yanking) into emacs, paste at the point, not where I click (I like to paste with the middle mouse button, xorg-style).

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(mouse-yank-at-point t)
#+end_src

#+begin_src emacs-lisp
(use-package xref
  :ensure nil
  :custom
  (xref-show-definitions-function #'xref-show-definitions-completing-read)
  (xref-search-program 'ripgrep))
#+end_src

#+begin_src emacs-lisp
(use-package browse-url
  :ensure nil
  :custom
  (browse-url-browser-function 'browse-url-firefox))
#+end_src

#+begin_src emacs-lisp
(use-package delsel
  :ensure nil
  :config
  (delete-selection-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package calc
  :ensure nil
  :bind
  (:map mode-specific-map
   ("C" . quick-calc)))
#+end_src

* Keybindings

#+begin_src emacs-lisp
(defun my/insert-mode ()
  "Switch to insert editing mode regardless of modal system."
  (cond ((bound-and-true-p meow-mode) (meow-insert))
        ((bound-and-true-p boon-mode) (boon-insert))
        ((bound-and-true-p evil-mode) (evil-insert))))
#+end_src

** Boon
#+begin_src emacs-lisp :noweb yes
(use-package boon
  :config
  (add-to-list 'boon-special-mode-list 'elfeed-show-mode)
  (add-to-list 'boon-special-mode-list 'elfeed-search-mode)

  <<boon-hdpm>>
  (boon-mode t))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref boon-hdpm
(define-key boon-select-map "q"  'boon-select-outside-quotes)
(define-key boon-select-map "w"  'boon-select-word)
(define-key boon-select-map "p"  'boon-select-paragraph)

(define-key boon-select-map "a"  '("around" . boon-select-borders))
(define-key boon-select-map "i"  'boon-select-wim)
(define-key boon-select-map "e"  'boon-select-with-spaces)
(define-key boon-select-map "E"  '("everything" . boon-select-document))

(define-key boon-select-map ";"  'boon-select-comment)
(define-key boon-select-map "y"  'boon-select-outside-pairs)
(define-key boon-select-map "o"  'boon-select-inside-pairs)
(define-key boon-select-map "c"  'boon-select-content)
(define-key boon-select-map "<"  'boon-select-blanks)


;; free command keys: l b f = { } u H S

;; (define-key boon-moves-map "j" 'boon-switch-mark)
;; (define-key boon-moves-map "J" 'xref-pop-marker-stack)
;; (define-key boon-moves-map "f"  '("find" . xref-find-definitions))
;; (define-key boon-moves-map "F"  'xref-find-references)
(define-key boon-moves-map "g"  'previous-line)
(define-key boon-moves-map "w"  'next-line)
(define-key boon-moves-map "G"  'backward-paragraph)
(define-key boon-moves-map "W"  'forward-paragraph)
(define-key boon-moves-map "m"  'boon-beginning-of-line)
(define-key boon-moves-map "v"  'boon-end-of-line)
(define-key boon-moves-map "h"  'boon-smarter-backward)
(define-key boon-moves-map "s"  'boon-smarter-forward)
(define-key boon-moves-map "T"  'boon-smarter-upward)
(define-key boon-moves-map "N"  'boon-smarter-downward)
(define-key boon-moves-map "d"  'boon-beginning-of-expression)
(define-key boon-moves-map "p"  'boon-end-of-expression)
(define-key boon-moves-map "t"  'backward-char)
(define-key boon-moves-map "n"  '("next" . forward-char))
(define-key boon-moves-map "D"  'beginning-of-buffer)
(define-key boon-moves-map "P"  'end-of-buffer)
(define-key boon-moves-map "k"  'avy-goto-word-1)
(define-key boon-moves-map "K"  'avy-goto-char)

;; inserts one char and stays in command mode
(define-key boon-command-map "q" 'boon-quote-character)
(define-key boon-moves-map "," 'boon-backward-search-map)
(define-key boon-moves-map "." 'boon-forward-search-map)

(define-key boon-moves-map ";"  'boon-qsearch-previous)
(define-key boon-moves-map ":"  'boon-qsearch-next)

;; (define-key boon-command-map "p" '("print" . occur)) ; print?
;; (define-key boon-command-map "P" 'kmacro-start-macro)
;; (define-key boon-command-map "L" '("pLay" . kmacro-end-or-call-macro))
;; (define-key boon-command-map "Q" 'boon-highlight-regexp)

(define-key boon-command-map "z" 'boon-replace-by-character)
(define-key boon-command-map "'" '("around" . boon-enclose))
(define-key boon-command-map "a" '("alter" . boon-substitute-region))
(define-key boon-command-map "e" '("erase" . boon-take-region))
(define-key boon-command-map "E" 'boon-treasure-region)
(define-key boon-command-map "y" 'boon-splice)
(define-key boon-command-map "Y" 'consult-yank-pop)
(define-key boon-command-map "j" 'boon-goto-map)

(define-key boon-command-map "r" 'boon-repeat-command)
(define-key boon-command-map "x" 'boon-x-map)
(define-key boon-command-map "c" 'boon-c-god)
(define-key boon-command-map "O" 'boon-open-line-and-insert)
(define-key boon-command-map "o" 'boon-open-next-line-and-insert)
(define-key boon-command-map "i" 'boon-set-insert-like-state)
(define-key boon-command-map ">" 'boon-copy-to-register)
(define-key boon-command-map "<" 'insert-register)

;; Most of these are actually in the boon-moves-map; however some don't quite work there; so they end up here.
(define-key boon-command-map (kbd "C-t") 'scroll-down-line)
(define-key boon-command-map (kbd "C-n") 'scroll-up-line)

(define-key indent-rigidly-map "n" 'indent-rigidly-right)
(define-key indent-rigidly-map "t" 'indent-rigidly-left)
#+end_src

* Base2

Not sure where to put everything yet, so this section is a grab bag of stuff that needs package management (elpaca) to be in place.

#+begin_src emacs-lisp
(use-package color
  :demand t
    :ensure nil
  :config
  (defun my/dark-p ()
    (let ((bg (face-background 'default)))
      (if (>= (color-distance "black" bg)
              (color-distance "white" bg))
          nil
        t))))

(use-package bookmark
  :demand t
  :ensure nil
  :custom
  (bookmark-fontify nil))

(use-package saveplace
  :demand t
    :ensure nil
  :config
  (save-place-mode t))

(use-package recentf
  :ensure nil
  :custom
  (recentf-max-saved-items 100)
  :config
  (recentf-mode t))

(use-package savehist
  :ensure nil
  :demand t
  :custom
  (savehist-additional-variables '(project-regexp-history-variable
                                   command-history))
  (savehist-autosave-interval 90))

(use-package eldoc
  :ensure nil
  :custom
  (eldoc-echo-area-use-multiline-p nil))

(use-package paren
    :ensure nil
  :custom
  (show-paren-delay 0)
  (show-paren-style 'parenthesis)
  :config
  (show-paren-mode 1))

(use-package autorevert
  :demand t
  :ensure nil
  :custom
  (global-auto-revert-non-file-buffers t)
  (auto-revert-check-vc-info nil)
  :config
  (global-auto-revert-mode 1))
#+end_src

#+begin_src emacs-lisp
(use-package apropos
  :ensure nil)

(use-package helpful
  :after (apropos)
  :custom
  (helpful-max-buffers 5)

  :bind
  (("C-h C-h" . nil)
   ("C-h ?" . nil)
   ("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)
   ("C-h x" . helpful-command)
   ("C-h ." . helpful-at-point)
   ("C-h o" . helpful-symbol)
   :map embark-symbol-map
   ("h" . helpful-symbol))

  :init
  ;; https://github.com/Wilfred/elisp-refs/issues/35
  (when (>= emacs-major-version 29)
    (defvar read-symbol-positions-list nil))
  :config
  ;; from https://github.com/Wilfred/helpful/issues/25
  ;; makes apropos lookups use helpful functions
  (let ((do-function (lambda (button)
                       (helpful-function (button-get button 'apropos-symbol))))
        (do-variable (lambda (button)
                       (helpful-variable (button-get button 'apropos-symbol)))))
    ;; :supertype only takes effect statically, at the time of
    ;; definition, so we can in fact redefine a button with itself
    ;; as its supertype
    (define-button-type 'apropos-function :supertype 'apropos-function 'action do-function)
    (define-button-type 'apropos-macro :supertype 'apropos-macro 'action do-function)
    (define-button-type 'apropos-command :supertype 'apropos-command 'action do-function)
    (define-button-type 'apropos-variable :supertype 'apropos-variable 'action do-variable)
    (define-button-type 'apropos-user-option :supertype 'apropos-user-option 'action do-variable)))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-demos
  :init
  (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1)
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

#+begin_src emacs-lisp
(use-package undo-fu
  :commands (undo-fu-only-undo
             undo-fu-only-redo))

(use-package undo-fu-session
  :hook (elpaca-after-init . global-undo-fu-session-mode)
  :custom
  (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))
#+end_src

Make sure my local bin dir is in emacs =$PATH=, and keep it updated.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :hook (elpaca-after-init . exec-path-from-shell-initialize)
  :custom
  (exec-path-from-shell-arguments '("-l")))
#+end_src

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :custom
  (search-whitespace-regexp ".*?")
  (isearch-lazy-count t)
  :config
  (advice-add 'isearch-update :after #'recenter))
#+end_src

#+begin_src emacs-lisp
(use-package finder
  :ensure nil
   ;; ("h C" . finder-commentary))
  )
#+end_src

* Text mode

General settings when in text editing modes.

#+begin_src emacs-lisp
(use-package simple
  :ensure nil)

(use-package visual-fill-column
  :hook ((text-mode prog-mode) . visual-line-fill-column-mode)

  :custom
  (visual-fill-column-enable-sensible-window-split t)
  (visual-fill-column-center-text t)

  :config
  (advice-add 'text-scale-adjust :after
              #'visual-fill-column-adjust))
#+end_src

I’ll put olivetti mode here since I think it’s mainly a text mode thing rather than for programming, but who knows.

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :custom
  (olivetti-body-width fill-column))
#+end_src

And let’s try out writeroom mode.

#+begin_src emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode
             global-writeroom-mode)
  :custom
  (writeroom-width fill-column)
  (writeroom-extra-line-spacing 0)
  (writeroom-border-width 40)
  :config
  (add-to-list 'writeroom-global-effects 'writeroom-set-internal-border-width))
#+end_src

* Pretty it up

Emacs colour themes apparently just load on top of each other, so here’s an advice to disable the current theme before loading a new one, thanks to [[https://www.reddit.com/r/emacs/comments/8v9lgu/emacs_theme_configuration_is_very_confusing/][this thread]].

#+begin_src emacs-lisp
(define-advice load-theme (:before (&rest _args) theme-dont-propagate)
  "Discard all themes before loading new."
  (mapc #'disable-theme custom-enabled-themes))
#+end_src

#+begin_src emacs-lisp
(use-package modus-themes
  :custom
  (modus-themes-org-blocks 'gray-background)
  (modus-themes-mixed-fonts t)
  (modus-themes-bold-constructs t)
  (modus-themes-italic-constructs t)
  (modus-themes-region '(bg-only)))

(use-package ef-themes)

(use-package doric-themes)

(use-package stimmung-themes
  :commands (stimmung-themes-load-light
             stimmung-themes-load-dark
             stimmung-themes-toggle)
  :config
  (defun my/stimmung-themes-dark-tweaks ()
    (set-face-background 'avy-lead-face "forest green")
    (set-face-foreground 'avy-lead-face "white"))
  (defun my/stimmung-themes-light-tweaks ()
    (set-face-background 'avy-lead-face "red")
    (set-face-foreground 'avy-lead-face "white")
    (set-face-foreground 'terraform--resource-name-face "dark orchid")
    (set-face-foreground 'terraform--resource-type-face "dark green")))

(use-package gruvbox-theme
  :custom-face
  (org-block-begin-line ((t (:inherit fixed-pitch
                             :slant italic))))
  (org-block-end-line ((t (:inherit fixed-pitch
                           :slant italic))))
  :config
  (defun my/match-border-to-background ()
    (custom-theme-set-faces
     'user
     `(internal-border ((t (:background ,(face-background 'default)))))))
  (defun my/gruvbox-dark-hard-tweaks ()
    (my/match-border-to-background))
  (defun my/gruvbox-light-hard-tweaks ()
    (my/match-border-to-background)))

(use-package poet-theme)
#+end_src

#+begin_src emacs-lisp
(defun my/set-dark-mode ()
  "Load dark theme."
  (interactive)
  (setq my/dark-mode t)
  (load-theme my/dark-theme t))

(defun my/set-light-mode ()
  "Load light theme."
  (interactive)
  (setq my/dark-mode nil)
  (load-theme my/light-theme t))

(defun my/toggle-dark-mode ()
  "Toggle dark/light theme."
  (interactive)
  (if (my/dark-p)
      (my/set-light-mode)
    (my/set-dark-mode)))

(defun my/setthemeset (sym value)
  (cond ((equal value "gruvbox")
         (setq my/dark-theme 'gruvbox-dark-hard
               my/light-theme 'gruvbox-light-hard))
        ((equal value "modus")
         (setq my/dark-theme 'modus-vivendi
               my/light-theme 'modus-operandi))
        ((equal value "modus-tinted")
         (setq my/dark-theme 'modus-vivendi-tinted
               my/light-theme 'modus-operandi-tinted))
        ((equal value "bio-operandi")
         (setq my/dark-theme 'ef-bio
               my/light-theme 'modus-operandi-tinted))
        ((equal value "duo")
         (setq my/dark-theme 'ef-night
               my/light-theme 'ef-duo-light))
        ((equal value "maris")
         (setq my/dark-theme 'ef-maris-dark
               my/light-theme 'ef-maris-light))
        ((equal value "stimmung")
         (setq my/dark-theme 'stimmung-themes-dark
               my/light-theme 'stimmung-themes-light))
        ((equal value "mix")
         (setq my/dark-theme 'gruvbox-dark-hard
               my/light-theme 'modus-operandi)))
  (if (my/dark-p)
      (my/set-dark-mode)
    (my/set-light-mode)))

(defun my/theme-option-setup ()
  (defcustom my/themeset "duo"
    "Indicates which set of themes (dark and light) to use."
    :type '(choice
            (const "gruvbox")
            (const "modus")
            (const "modus-tinted")
            (const "bio-operandi")
            (const "duo")
            (const "maris")
            (const "stimmung")
            (const "mix")
            )
    :set 'my/setthemeset
    :initialize 'custom-initialize-set)

  (customize-set-variable 'my/themeset "duo")
  (my/dbus-colour-setup))

(if (daemonp)
    (add-hook 'server-after-make-frame-hook #'my/theme-option-setup)
  (add-hook 'elpaca-after-init-hook #'my/theme-option-setup))
#+end_src

#+begin_src emacs-lisp
;; thanks to https://www.reddit.com/r/emacs/comments/o49v2w/automatically_switch_emacs_theme_when_changing

(use-package dbus
  :ensure nil
  :config
  (defun set-dark-or-light (value)
    (if (equal value '1)
        (progn (message "Switching to dark theme")
               (my/set-dark-mode))
      (progn (message "Switching to light theme")
             (my/set-light-mode))))

  (defun handler (value)
    (set-dark-or-light (car (car value))))

  (defun signal-handler (namespace key value)
    (if (and (string-equal namespace "org.freedesktop.appearance")
             (string-equal key "color-scheme"))
        (set-dark-or-light (car value))))

  (defun my/dbus-colour-setup ()
    (dbus-call-method-asynchronously
     :session
     "org.freedesktop.portal.Desktop"
     "/org/freedesktop/portal/desktop"
     "org.freedesktop.portal.Settings"
     "Read"
     #'handler
     "org.freedesktop.appearance"
     "color-scheme")

    (dbus-register-signal
     :session
     "org.freedesktop.portal.Desktop"
     "/org/freedesktop/portal/desktop"
     "org.freedesktop.portal.Settings"
     "SettingChanged"
     #'signal-handler)))
#+end_src

But I like some things to be set no matter the theme. For example, I always like italic code comments. And the brutalist theme has a smaller mode-line font size that I don’t like. So I set up a hook/advice method of keeping these things “fixed”. I found the idea in [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/][this helpful reddit thread]] while looking for what I thought /must/ have a /good/ solution.

#+begin_src emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))

(add-hook 'after-load-theme-hook #'my/theme-tweaks)
(setq my/first-frame-created nil)
(if (daemonp)
    (add-hook 'server-after-make-frame-hook #'my/theme-tweaks)
  (add-hook 'elpaca-after-init-hook #'my/theme-tweaks))
#+end_src

Handy functions to calculate the DPI of the display that current frame is on. Bits and pieces of this came from various places, but especially [[https://www.reddit.com/r/emacs/comments/a01fs1/dispwatch_watch_the_current_display_for_changes/][this reddit thread]], which led me to [[https://emacs.stackexchange.com/questions/28390/quickly-adjusting-text-to-dpi-changes/44930#44930][this useful StackExchange question]].

#+begin_src emacs-lisp
(defun frame-monitor-mm ()
  "Return the size of the current monitor in mm."
  (alist-get 'mm-size (frame-monitor-attributes)))

(defun frame-monitor-pixels ()
  "Return the geometry of the current monitor in pixels."
  (alist-get 'geometry (frame-monitor-attributes)))

(defun monitor-dpi ()
  "Return the DPI of the current monitor."
  (let* ((mm (frame-monitor-mm))
         (mm-width (car mm))
         (pixels (frame-monitor-pixels))
         (pixel-width (nth 2 pixels)))
    (/ pixel-width (/ mm-width 25.4))))
#+end_src

Change global text sizes with this function. This is the function I bind to a key or use in a hydra to change text sizes. It just changes =my/current-text-size=, then calls my theme-tweak function below to make the changes. It also calls =visual-fill-column-adjust= so that everything ends up the right size.

#+begin_src emacs-lisp
(defun my/adjust-text-height (adjustment)
  "Adjust text size up or down by ADJUSTMENT."
  (interactive)

  (if (= adjustment 0)
      (setq my/current-text-size my/default-text-size)
    (setq my/current-text-size (+ my/current-text-size adjustment)))
  (my/theme-tweaks)
  (visual-fill-column-adjust))
#+end_src

And here’s the function where I collect my tweaks to the theme and set up fonts.

#+begin_src emacs-lisp :noweb yes
(defun my/theme-tweaks ()
  "Apply my catchall set of mostly appearance tweaks."
  (interactive)

  (unless savehist-loaded
    (savehist-mode 1))

  ;; Workaround so I can use S-SPC as a binding
  ;; https://www.reddit.com/r/emacs/comments/osscfd/pgtk_emacswaylandgnome_no_shiftspace/
  ;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2021-07/msg00071.html
  (when (fboundp 'pgtk-use-im-context)
    (pgtk-use-im-context nil))

  ;; Set the default text size based on the monitor DPI
  (when (display-graphic-p)
    (let* ((dpi (monitor-dpi))
           (size (cond ((< dpi 110) 125)
                       ((< dpi 160) 150)
                       ;; need to find a signal other than dpi here, as the framework with 200%
                       ;; scaling reads as 250+ dpi, but has the same desired text size as 110 dpi
                       ((< dpi 255) 125))))
      (setq my/default-text-size size)))

  (when (not (boundp 'my/current-text-size))
    (setq my/current-text-size my/default-text-size))

  (fontaine-set-preset (or (fontaine-restore-latest-preset) 'normal))

  ;; this doesn't seem to apply on startup, only after changing themes
  (set-face-attribute 'mode-line-active nil
                      :background (face-background 'mode-line))

  (set-face-italic 'font-lock-comment-face t)

  (set-face-foreground 'org-hide (face-background 'default))

  ;; Trying out styling src blocks with a line at the top/bottom
  (let* ((bg (face-background 'default))
         (block (face-background 'org-block nil 'default))
         (lc (if (my/dark-p)
                 (color-lighten-name block 70)
               (color-darken-name block 20))))
    (set-face-attribute 'org-block-begin-line nil
                        :background bg
                        :underline `(:color ,lc :position t)
                        :extend t)
    (set-face-attribute 'org-block-end-line nil
                        :background bg
                        :foreground lc
                        :overline lc
                        :extend t))

  (let* ((color (face-foreground 'default))
         (ucolor (if (my/dark-p)
                     (color-darken-name color 60)
                   (color-lighten-name color 400))))
    (set-face-attribute 'org-level-1 nil :underline ucolor))

  ;; for org-modern
  (dolist (face '(window-divider
                  window-divider-first-pixel
                  window-divider-last-pixel))
    (face-spec-reset-face face)
    (set-face-foreground face (face-attribute 'default :background)))
  (set-face-background 'fringe (face-attribute 'default :background))


  (set-face-attribute 'shr-text nil :height (face-attribute 'default :height))

  ;; Apply custom theme tweaks if there are any
  ;; Add a global dark/light tweaks mechanism too?
  (dolist (theme custom-enabled-themes)
    (let ((tweaks-fun (intern (concat "my/" (symbol-name theme) "-tweaks"))))
      (when (fboundp tweaks-fun)
        (funcall tweaks-fun))))

  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (when (equal major-mode 'org-mode)
              (font-lock-fontify-buffer)))
          (buffer-list)))

  (set-scroll-bar-mode nil)

  ;; look for pdf buffers and sync dark/light in them
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (cond ((eq major-mode 'pdf-view-mode)
             (pdf-view-themed-minor-mode (if (my/dark-p) +1 -1))))))

  <<graphical-tweaks>>

  (unless my/first-frame-created
    (setq my/first-frame-created t)
    (message "Applying first frame tweaks")
    <<first-frame-tweaks>>))
#+end_src

#+begin_src emacs-lisp
(use-package fontaine
  :commands (fontaine-set-preset
             fontaine-restore-latest-preset)
  :hook (kill-emacs . fontaine-store-latest-preset)
  :custom
  (fontaine-presets `((normal
                       :default-height ,(round (* my/current-text-size 1.04))
                       :fixed-pitch-height ,(round (* my/current-text-size 1.04))
                       :variable-pitch-height ,(round (* my/current-text-size 1.04)))
                      (large
                       :default-height ,(round (* my/current-text-size 1.3))
                       :fixed-pitch-height ,(round (* my/current-text-size 1.3))
                       :variable-pitch-height ,(round (* my/current-text-size 1.3)))
                      (larger
                       :default-height ,(round (* my/current-text-size 1.5))
                       :fixed-pitch-height ,(round (* my/current-text-size 1.5))
                       :variable-pitch-height ,(round (* my/current-text-size 1.5)))
                      (double
                       :default-height ,(round (* my/current-text-size 2))
                       :fixed-pitch-height ,(round (* my/current-text-size 2))
                       :variable-pitch-height ,(round (* my/current-text-size 2)))
                      (t
                       :default-family "Iosevka"
                       :default-weight normal
                       :fixed-pitch-family "Iosevka"
                       :variable-pitch-family "Noto Sans"
                       :line-spacing 0.2))))
#+end_src

#+begin_src emacs-lisp
(use-package spacious-padding
  :commands (spacious-padding-mode)
  :config
  (setq spacious-padding-widths
        '(:internal-border-width 20
          :header-line-width 4
          :mode-line-width 3
          :tab-width 4
          :right-divider-width 20
          :scroll-bar-width 8)))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref first-frame-tweaks
(spacious-padding-mode t)
#+end_src

* Mode-line

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook ((elpaca-after-init . doom-modeline-mode)
         (after-change-major-mode . doom-modeline-conditional-buffer-encoding))

  :custom-face
  (mode-line ((nil (:inherit fixed-pitch))))
  (mode-line-active ((nil (:inherit fixed-pitch))))
  (mode-line-inactive ((nil (:inherit fixed-pitch))))

  (doom-modeline-evil-emacs-state
   ((t (:background "DarkMagenta" :foreground "#ffd700"))))
  (doom-modeline-evil-insert-state
   ((t (:background "#ffd700" :foreground "#000000"))))
  (doom-modeline-evil-motion-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-normal-state
   ((t (:background "ForestGreen" :foreground "#ffffff"))))
  (doom-modeline-evil-operator-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-visual-state
   ((t (:background "#fe8019" :foreground "#000000"))))
  (doom-modeline-evil-replace-state
   ((t (:background "red4" :foreground "#ffffff"))))

  :custom
  (doom-modeline-bar-width 0)
  (doom-modeline-hud t)
  (doom-modeline-modal-icon nil)
  (doom-modeline-buffer-file-name-style 'auto)
  (column-number-mode t)
  (doom-modeline-percent-position mode-line-percent-position)

  :init
  (defun doom-modeline-conditional-buffer-encoding ()
    "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
    (setq-local doom-modeline-buffer-encoding
                (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                            (eq buffer-file-coding-system 'utf-8)))))

  :config
  (doom-modeline-def-segment my/buffer-info-simple
    "Display only the current buffer's name, but with fontification."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-mode-icon)
     (doom-modeline--buffer-simple-name)))

  (doom-modeline-def-modeline 'vterm
    '(eldoc bar workspace-name window-number modals matches follow my/buffer-info-simple remote-host word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding process vcs check time))
  (add-to-list 'doom-modeline-mode-alist
               '(vterm-mode . vterm))

  (setq-default doom-modeline-column-zero-based nil))
#+end_src

* Navigation?

I used ivy and friends for a quite a while here, mostly because helm didn't really make sense to me when I started using emacs, and ivy did. So I quickly got a configuration together that worked for me, and enjoyed using ivy, swiper, counsel etc. but I never really put a lot of effort into understanding what I had. Occasionally I would rework some part of it, but I mostly left it alone.

I was interested when the "new tools" like vertico, and orderless, and then consult, marginalia, and embark started showing up and looked like a nice composable, understandable set of functionality I could assemble the way I wanted to. So that's what I have here now.

** Vertico

Let's start with vertico, as it's the interface to most of the rest here. I tried icomplete-vertical for a few days first, and then tried selectrum, and now vertico.

#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode t)

  :custom
  (vertico-count 20)

  :bind
  (:map vertico-map
   ("C-t" . vertico-next)
   ("C-n" . vertico-previous)
   ("C-S-t" . vertico-next-group)
   ("C-S-n" . vertico-previous-group)
   ("C-S-<down>" . vertico-next-group)
   ("C-S-<up>" . vertico-previous-group)
   ("<backtab>" . vertico-insert)))

(use-package vertico-mouse
  :after vertico
  :ensure nil

  :init
  (vertico-mouse-mode t))

(use-package vertico-directory
  :after vertico
  :ensure nil

  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)

  :bind
  (:map vertico-map
   ("TAB" . my/file-or-not)
   ("RET" . vertico-directory-enter)
   ("DEL" . vertico-directory-delete-char)
   ("M-DEL" . vertico-directory-delete-word))

  :init
  (defun my/file-or-not ()
    (interactive)
    (when (eq 'file (vertico--metadata-get 'category))
      (minibuffer-complete))
    (vertico-insert)))

(use-package vertico-multiform
  :after vertico
  :ensure nil
  :init
  (vertico-multiform-mode t)
  (setq vertico-multiform-categories
        '((file
           buffer
           (vertico-buffer-display-action . (display-buffer-same-window)))
          (embark-keybinding grid)
          ;; (t reverse)

          (jinx grid (vertico-grid-annotate . 20))))
  (setq vertico-multiform-commands nil
        ;; '((consult-buffer posframe)
        ;;   (find-file posframe)
        ;;   (execute-extended-command posframe)
        ;;   (t
        ;;    posframe
        ;;    (vertico-posframe-poshandler . posframe-poshandler-frame-bottom-center)
        ;;    (vertico-posframe-border-width . 10)
        ;;    ;; NOTE: This is useful when emacs is used in both in X and
        ;;    ;; terminal, for posframe do not work well in terminal, so
        ;;    ;; vertico-buffer-mode will be used as fallback at the
        ;;    ;; moment.
        ;;    (vertico-posframe-fallback-mode . vertico-buffer-mode))
        ;;   )
        ;; (consult-ripgrep
        ;; buffer
        ;; (vertico-buffer-display-action . (display-buffer-same-window))
        ;; )
        )
  )

(use-package vertico-repeat
  :after vertico
  :ensure nil
  :hook (minibuffer-setup . vertico-repeat-save)
  :bind
  (:map mode-specific-map
   ("r". vertico-repeat)))

(use-package vertico-reverse
  :after vertico
  :ensure nil
  :bind
  (:map vertico-reverse-map
   ("C-n" . vertico-next)
   ("C-t" . vertico-previous)
   ("C-S-n" . vertico-next-group)
   ("C-S-t" . vertico-previous-group)))
#+end_src

#+begin_src emacs-lisp
(use-package vertico-posframe
  :after (vertico)
  :custom
  (vertico-posframe-parameters '((left-fringe . 20)
                                 (right-fringe . 20)))
  :bind
  (:map vertico-multiform-map
   ("M-p" . nil))
  ;; :config
  ;; (vertico-posframe-mode t)
  )
#+end_src

** Orderless

Faster narrowing of a list of candidates matters, and orderless is a nice straightforward way to get it.

#+begin_src emacs-lisp
(use-package orderless
  :demand t

  :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (pattern index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
     ;; File extensions
     ((and
       ;; Completing filename or eshell
       (or minibuffer-completing-file-name
           (derived-mode-p 'eshell-mode))
       ;; File extension
       (string-match-p "\\`\\.." pattern))
      `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x200000-\x300000]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 1))
        (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  :custom
  (completion-styles '(substring orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles substring partial-completion))
                                   (command (styles +orderless-with-initialism))
                                   (variable (styles +orderless-with-initialism))
                                   (symbol (styles +orderless-with-initialism))))
  (orderless-component-separator #'orderless-escapable-split-on-space)
  (orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** Marginalia

There's plenty of useful extra information that can be attached to each candidate in a list, and marginalia does a great job with it.

#+begin_src emacs-lisp
(use-package marginalia
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init
  (marginalia-mode t))
#+end_src

** Embark

One of the really nice bits here is embark. I haven't really exploited it yet, but it's a great way to launch different actions on candidates in vertico, or pretty much anywhere in emacs.

#+begin_src emacs-lisp
(use-package embark
  :demand t

  :custom
  (embark-help-key "C-h")
  (embark-cycle-key ",")
  (embark-mixed-indicator-delay 0.8)
  (embark-verbose-indicator-display-action
   '(display-buffer-below-selected
     (window-height . fit-window-to-buffer)))
  (y-or-n-p-use-read-key t)

  :bind
  (("C-," . embark-act)
   ("M-." . embark-dwim)
   ("C-h B" . embark-bindings)
   :map embark-file-map
   ("s" . my/consult-ripgrep-from-dir)
   ("F" . find-file-other-frame)
   ;; ("x" . my/dired-open)
   :map embark-symbol-map
   ("g" . consult-ripgrep)
   :map embark-url-map
   ("." . hydra-browse/body)
   :map embark-buffer-map
   ("F" . switch-to-buffer-other-frame)
   ;; ("R" . tabspaces-remove-selected-buffer)
   :map embark-org-src-block-map
   ("e" . org-babel-expand-src-block)
   :map embark-heading-map
   ("I" . org-id-get-create)
   ("l" . org-store-link))

  :init
  ;; stolen from https://github.com/oantolin/embark/issues/252
  ;; and an assist from https://github.com/oantolin/embark/issues/42
  (defun my/consult-ripgrep-from-dir (file)
    "Jump into consult-ripgrep from embark."
    (interactive "fRipgrep from dir:")
    (consult-ripgrep (file-name-directory file)))

  (setq prefix-help-command #'embark-prefix-help-command)

  :config
  (require 'embark-org)

  (defvar-keymap embark-org-timestamp-map
    :doc "Actions for org timestamps"
    :parent embark-general-map
    "T" #'org-toggle-timestamp-type)

  (add-to-list 'embark-keymap-alist '(org-timestamp . embark-org-timestamp-map))

  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)

  ;; show target types in modeline
  (defvar embark--target-mode-timer nil)
  (defvar embark--target-mode-string "")

  (defun embark--target-mode-update ()
    (setq embark--target-mode-string
          (if-let (targets (embark--targets))
              (format "[%s%s] "
                      (propertize (symbol-name (plist-get (car targets) :type)) 'face 'bold)
                      (mapconcat (lambda (x) (format ", %s" (plist-get x :type)))
                                 (cdr targets)
                                 ""))
            "")))

  (define-minor-mode embark-target-mode
    "Shows the current targets in the modeline."
    :global t
    (setq mode-line-misc-info (assq-delete-all 'embark-target-mode mode-line-misc-info))
    (when embark--target-mode-timer
      (cancel-timer embark--target-mode-timer)
      (setq embark--target-mode-timer nil))
    (when embark-target-mode
      (push '(embark-target-mode (:eval embark--target-mode-string)) mode-line-misc-info)
      (setq embark--target-mode-timer
            (run-with-idle-timer 0.1 t #'embark--target-mode-update))))
  )

(use-package avy-embark-collect
  :commands (avy-embark-collect-act
             avy-embark-collect-choose))

(use-package embark-consult
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+begin_src emacs-lisp
(use-package embark-vc
  :disabled t
  :after embark)
#+end_src

** Consult

Consult takes over for a lot of what counsel did, as well as swiper.

#+begin_src emacs-lisp
(use-package consult
  :bind
  (([remap goto-line] . consult-goto-line)
   ("C-h i" . consult-info)
   ("C-h C-m" . consult-man)

   :map ctl-x-map
   ("b" . consult-buffer)

   :map boon-goto-map
   ("l" . consult-line)
   ("L" . consult-goto-line)
   ("i" . consult-imenu)

   :map mode-specific-map
   ("iy" . consult-yank-pop)
   ("jo" . consult-org-heading)

   :map my/search-map
   ("f" . consult-find)
   ("g" . consult-ripgrep)
   ("v" . consult-git-grep)

   :repeat-map buffer-switch-repeat-map
   :exit
   ("o" . consult-buffer)
   ("W" . consult-buffer-other-window)

   :map embark-buffer-map
   ("F" . consult-buffer-other-frame)

   :map minibuffer-mode-map
   ("C-c r" . consult-history))

  :custom
  (consult-narrow-key "<")
  :config
  (consult-customize consult-line
                     consult-ripgrep
                     :initial (when (use-region-p)
                                (buffer-substring-no-properties
                                 (region-beginning) (region-end)))))
#+end_src

#+begin_src emacs-lisp
(use-package consult-dir
  :commands (consult-dir
             consult-dir-jump-file)
  :bind
  (:map vertico-map
   ("M-d" . consult-dir)
   ("M-j" . consult-dir-jump-file)))
#+end_src

#+begin_src emacs-lisp
(use-package consult-org-roam
  :commands (consult-org-roam-mode
             consult-org-roam-search
             consult-org-roam-backlinks
             consult-org-roam-file-find)

  :custom
  (consult-org-roam-buffer-after-buffers t)
  (consult-org-roam-grep-func #'consult-ripgrep)

  :bind
  (:map my/search-map
   ("n" . consult-org-roam-search)

   :map my/notes-map
   ("S-b" . consult-org-roam-backlinks)
   ("S-f" . consult-org-roam-forward-links))

  :init
  (consult-org-roam-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package consult-jump-project
  :ensure (consult-jump-project
             :host github
             :repo "jdtsmith/consult-jump-project")
  :commands (consult-jump-project))
#+end_src

** Corfu

#+begin_src emacs-lisp
(use-package corfu
  :ensure (:host github
           :repo "minad/corfu"
           :files (:defaults "extensions/*"))

  :bind
  (:map corfu-map
   ("C-t" . corfu-next)
   ("C-n" . corfu-previous)

   ("M-m" . corfu-move-to-minibuffer))

  :init
  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let ((completion-extra-properties corfu--extra)
          completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))

  (global-corfu-mode t)

  :config
  (require 'corfu-popupinfo)
  (setq corfu-popupinfo-delay nil)
  (set-face-attribute 'corfu-popupinfo nil :height 1.0)
  (corfu-popupinfo-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package kind-icon
  :after  corfu
  :custom
  (kind-icon-default-face 'corfu-default)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

#+begin_src emacs-lisp
(use-package cape
  :after corfu
  :commands (cape-dabbrev
             cape-file
             cape-company-to-capf)
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))
#+end_src

** Avy

Avy is a really handy way to jump around your visible buffer contents. One aspect that doesn’t seem to really be documented is the avy-actions mechanism. It lets you do things other than just jump to the point you select. So you can hit the key for whichever avy function you like, then, /before/ making your selection, press the key associated with an avy-action function to do that thing instead. This way, you can easily copy a word from elsewhere on your screen and paste it at your cursor with avy, no cursor movement needed at all. Also, =avy-copy-line= is a useful standalone function. I find it useful particularly when working in Terraform files, as lines need to be duplicated fairly often there.

#+begin_src emacs-lisp
(use-package avy
  :demand t
  :bind
  (:map mode-specific-map
   ("jj" . avy-goto-char-timer)
   ("jq" . avy-pop-mark)
   ;; "l" #'avy-goto-line
   ("jl" . avy-copy-line)
   ("jr" . avy-copy-region)
   )

  ;; TODO might need a little avy transient/hydra for visibility/accessibility of all this good stuff
  ;; avy-next/prev
  ;; avy-resume
  ;; avy-isearch
  ;; avy-move-line
  ;; avy-push/pop-mark
  ;; avy-kill/move-region

  :custom
  (avy-dispatch-alist '((?x . avy-action-kill-move)
                        (?X . avy-action-kill-stay)
                        (?, . avy-action-embark)
                        (?T . avy-action-teleport)
                        (?m . avy-action-mark)
                        (?c . avy-action-copy)
                        (?C . my/avy-action-kill-whole-line)
                        (?y . avy-action-yank)
                        (?Y . avy-action-yank-line)
                        (?i . avy-action-ispell)
                        (?z . avy-action-zap-to-char)))

  ;; TODO look at how avy actions interact with evil; maybe I need more stuff like this
  ;;                       (?c . (lambda (pt)
  ;;                               (avy-action-copy pt)
  ;;                               (if (evil-insert-state-p)
  ;;                                   (progn (evil-paste-before 1)
  ;;                                          (evil-forward-char))
  ;;                                 (evil-paste-after 1))))

  (avy-keys '(?c ?i ?e ?a ?h ?t ?n ?s))
  (avy-line-insert-style 'below)

  :config
  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun my/avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t))
#+end_src

** Buffers

#+begin_src emacs-lisp
(use-package nswbuff
  :bind
  (:map my/window-map
   ("c" . nswbuff-switch-to-next-buffer)
   ("r" . nswbuff-switch-to-previous-buffer)
   :repeat-map buffer-switch-repeat-map
   ("n" . nswbuff-switch-to-next-buffer)
   ("p" . nswbuff-switch-to-previous-buffer))

  :custom
  (nswbuff-buffer-list-function #'my/local-buffer-list)
  (nswbuff-status-window-layout 'scroll)
  (nswbuff-display-intermediate-buffers t)
  (nswbuff-recent-buffers-first t)
  (nswbuff-exclude-buffer-regexps '("^ "
                                    "^\*.*\*"
                                    "^magit.*:.+"))
  (nswbuff-include-buffer-regexps '("^*Org Src"
                                    "*elfeed"
                                    "^*helpful"))

  :init
  (defun my/local-buffer-list ()
    (seq-remove #'popper-popup-p (beframe--buffer-list))))
#+end_src

#+begin_src emacs-lisp
(use-package ibuffer
  :ensure nil
  :hook (ibuffer-mode . ibuffer-auto-mode)
  :custom
  (ibuffer-show-empty-filter-groups nil)
  :bind
  (:map ibuffer-mode-map
   ;; a cheap hack to keep me from leaving ibuffer buffers open in the background
   ("q" . kill-current-buffer)))
#+end_src

#+begin_src emacs-lisp
;; doesn't seem to work in src blocks unless re-enabled?
(use-package topsy
  :hook (prog-mode . topsy-mode))
#+end_src

#+begin_src emacs-lisp
(use-package burly
  :commands (burly-bookmark-frames
             burly-bookmark-windows
             burly-open-bookmark
             burly-open-last-bookmark))
#+end_src

** Within buffers

#+begin_src emacs-lisp
(use-package beginend
  :config
  (beginend-global-mode t))
#+end_src

* Snippets

#+begin_src emacs-lisp
(use-package yasnippet
  :hook (org-mode . yas-minor-mode)
  :custom
  (yas-snippet-dirs `(,(concat user-emacs-directory "snippets"))))
#+end_src

* Projects

#+begin_src emacs-lisp
(use-package project
  :ensure nil
  :custom
  (project-switch-commands '((project-find-file "Find file" ?f)
                             (project-find-regexp "Find regexp" ?r)
                             (project-find-dir "Find directory" ?d)
                             (magit-project-status "Git" ?g)
                             (project-vc-dir "VC-Dir")
                             (project-eshell "Eshell")))
  :hook
  (elpaca-after-init . (lambda ()
                  (define-key ctl-x-map (kbd "C-p") project-prefix-map)))

  :init
  (defun my/find-file ()
    (interactive)
    (if (project-current)
        (project-find-file)
      (call-interactively #'find-file)))

  :bind
  (:repeat-map buffer-switch-repeat-map
   :exit
   ("f" . my/find-file))
  (:map ctl-x-map
   ("C-f" . my/find-file)
   ("C-S-f" . find-file)))
#+end_src

#+begin_src emacs-lisp
(use-package disproject
  :bind (:map ctl-x-map
         ("p" . disproject-dispatch)))
#+end_src

* Git

I find that diff-hl does a better job of showing diff information than git-gutter does. I’d like to use =diff-hl-flydiff-mode=, but it caused issues, which I can’t remember well enough to document now. Will revisit later.

#+begin_src emacs-lisp
(use-package diff-hl
  :hook ((dired-mode . diff-hl-dired-mode))
  :commands (diff-hl-mode
             global-diff-hl-mode
             diff-hl-flydiff-mode
             diff-hl-update)
  :bind
  (:map mode-specific-map
   ("jh" . diff-hl-next-hunk)
   :repeat-map diff-hl-repeat-map
   ("t" . diff-hl-next-hunk)
   ("n" . diff-hl-previous-hunk)
   ("s" . diff-hl-stage-current-hunk))
  ;;   "vD" #'diff-hl-mode)
  ;;   "gG" #'diff-at-point-open-and-goto-hunk
  :init
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  (advice-add 'vc-refresh-state :after #'diff-hl-update)
  :custom-face
  (diff-hl-change ((t (:foreground "#222222" :background "#ffd700"))))
  (diff-hl-insert ((t (:foreground "dark green" :background "ForestGreen"))))
  (diff-hl-delete ((t (:foreground "dark red" :background "red4"))))
  :config
  (global-diff-hl-mode t))
#+end_src

Diff-hl may be better at /showing/ diff info, but git-gutter is better at doing things with diffs. So I have it active for navigation and staging actions. It’s disabled in org mode because I had issues with it before. Now that my config is in org though, it would be handy to have back. Another TODO.

#+begin_src emacs-lisp
(use-package git-gutter
  :disabled
  :hook (prog-mode . git-gutter-mode)
  ;; :general
  ;; (general-define-key
  ;;  :states '(normal visual)
  ;;  "gp" 'git-gutter:previous-hunk
  ;;  "gn" 'git-gutter:next-hunk
  ;;  "gs" 'git-gutter:popup-hunk
  ;;  "gS" 'git-gutter:stage-hunk
  ;;  "gU" 'git-gutter:revert-hunk)

  :custom-face
  (git-gutter:modified ((t (:foreground "DeepSkyBlue2"))))
  (git-gutter:added ((t (:foreground "ForestGreen"))))
  (git-gutter:deleted ((t (:foreground "red4"))))

  :custom
  (git-gutter:disabled-modes '(org-mode))

  (git-gutter:added-sign "")
  (git-gutter:deleted-sign "")
  (git-gutter:modified-sign "")
  (git-gutter:ask-p nil)

  :init
  (global-git-gutter-mode -1)

  ;; :config
  ;; (advice-add 'git-gutter:previous-hunk :after #'my/after-jump)
  ;; (advice-add 'git-gutter:next-hunk :after #'my/after-jump)
  )
#+end_src

#+begin_src emacs-lisp
(use-package transient
  :custom
  (transient-display-buffer-action
   '(display-buffer-below-selected
     (dedicated . t)
     (inhibit-same-window . t)
     (window-parameters
      (no-other-window . t))))

  :config
  (transient-define-prefix roam-dailies-transient ()
    "Navigate Roam Dailies"
    ;; :transient-suffix 'transient--do-stay
    ["Daily Notes"
     :class transient-columns
     ["Today"
      ("." "Today" org-roam-dailies-goto-today)
      ("c" "Capture" org-roam-dailies-capture-today)
      ]
     ["Nav"
      ;; ("h" "Previous" my/roam-dailies-previous)
      ("h" "Previous" org-roam-dailies-goto-previous-note :transient t)
      ;; (:key "h" "Previous" org-roam-dailies-goto-previous-note)
      ;; ("s" "Next" my/roam-dailies-next)
      ("s" "Next" org-roam-dailies-goto-next-note :transient t)
      ;; ("n" "pgup" evil-scroll-page-up :transient t)
      ;; ("t" "pgdn" evil-scroll-page-down :transient t)
      ]
     ]
    )

  :bind
  (:map my/notes-map
   ("b" . roam-dailies-transient)))
#+end_src

#+begin_src emacs-lisp
(use-package transient-posframe
  :after (transient)
  ;; :config
  ;; (transient-posframe-mode t)
  )
#+end_src

Of course, the great magit.

#+begin_src emacs-lisp
(use-package magit
  :hook
  (git-commit-mode . my/insert-mode)
  (git-commit-mode . auto-fill-mode)
  (git-commit-mode . (lambda () (setq-local fill-column 72)))

  :after nerd-icons

  :custom
  (magit-commit-show-diff t)
  (magit-diff-refine-hunk t)
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (magit-format-file-function #'magit-format-file-nerd-icons)

  :bind
  (:map my/git-map
   ("s" . magit-status-here)
   ("f" . magit-file-dispatch)
   ("g" . magit-dispatch)))
#+end_src

“Forge” can talk to sites like github and provide tools to work with PRs etc. Installing dependencies manually for now [[https://github.com/raxod502/straight.el/issues/336][because]].

#+begin_src emacs-lisp
(use-package forge
  :after (magit)
  :init
  (setq forge-add-default-bindings nil)
  (setq forge-database-connector 'sqlite-builtin)
  ;; (setq forge-bug-reference-hooks nil)
  )
#+end_src

Handy package to browse to git repo web interfaces.
#+begin_src emacs-lisp
(use-package git-link
  :commands (git-link
             git-link-commit
             git-link-homepage)
  :bind
  (:map my/git-map
   ("B" . git-link)
   ("C" . git-link-commit)
   ("H" . git-link-homepage))
  :custom
  (git-link-open-in-browser t))
#+end_src

#+begin_src emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine
             git-timemachine-toggle))
#+end_src

#+begin_src emacs-lisp
(use-package abridge-diff
  :after magit
  :init
  (abridge-diff-mode 1))
#+end_src

#+begin_src emacs-lisp
(use-package consult-git-log-grep
  :after (consult
          magit)
  :commands (consult-git-log-grep)
  :custom
  (consult-git-log-grep-open-function #'magit-show-commit))
#+end_src

#+begin_src emacs-lisp
(use-package consult-ls-git
  :commands (consult-ls-git
             consult-ls-git-other-window))
#+end_src

#+begin_src emacs-lisp
(use-package blamer
  :commands (blamer-show-commit-info
             blamer-show-posframe-commit-info
             global-blamer-mode)
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                   :background "unspecified"
                   :height 140
                   :italic t))))
#+end_src

#+begin_src emacs-lisp
(use-package magit-commit-mark
  ;; will need to figure out keys for this, maybe util leader?
  ;; maybe a universal dwim mark read/unread/star/urgent/etc setup?
  :after magit
  :commands (magit-commit-mark-mode))
#+end_src

#+begin_src emacs-lisp
(use-package ediff
  :ensure nil
  :custom
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

* Org

My org config is pretty long, so I've broken it up for easier reading and explanation. The main structure of it is here, with the details following.

#+begin_src emacs-lisp :noweb yes :tangle no :noweb-ref org
(use-package org
  :hook (
         <<org-hooks>>
         )

  :bind
  (:map org-mode-map
   ("C-c C-l" . my/org-insert-link-dwim)
   :repeat-map org-mode-heading-jump-repeat-map
   ("p" . org-previous-visible-heading)
   ("n" . org-next-visible-heading))
  <<org-keys>>

  (:map org-read-date-minibuffer-local-map
   ("n" . my-org-in-calendar-calendar-backward-day)
   ("t" . my-org-in-calendar-calendar-forward-day)
   ("h" . my-org-in-calendar-calendar-backward-week)
   ("s" . my-org-in-calendar-calendar-forward-week)
   ("N" . my-org-in-calendar-calendar-backward-month)
   ("T" . my-org-in-calendar-calendar-forward-month)
   ("H" . my-org-in-calendar-calendar-backward-year)
   ("S" . my-org-in-calendar-calendar-forward-year))

  :custom
  <<org-custom>>

  :init
  <<org-init>>
  (defun my/log-line ()
    (interactive)
    (org-time-stamp-inactive '(16))
    (insert " "))

  (defun my/org-hide-all-drawers ()
    (org-cycle-hide-drawers 'all))

  (defun my/config-tangle ()
    (interactive)
    (let ((gc-cons-threshold most-positive-fixnum))
      (org-babel-tangle)))

  ;; stolen from https://xenodium.com/emacs-dwim-do-what-i-mean/
  (defun my/org-insert-link-dwim ()
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
             (delete-region (region-beginning) (region-end))
             (insert (org-make-link-string clipboard-url region-content)))
            ((and clipboard-url (not point-in-link))
             (insert (org-make-link-string
                      clipboard-url
                      (read-string "title: "
                                   (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                     (dom-text (car
                                                (dom-by-tag (libxml-parse-html-region
                                                             (point-min)
                                                             (point-max))
                                                            'title))))))))
            (t
             (call-interactively 'org-insert-link)))))

  ;; Original version stolen from https://emacs.stackexchange.com/questions/23870/org-babel-result-to-a-separate-buffer
  (defun my/babel-to-buffer ()
    "A function to efficiently feed babel code block result to a separate buffer"
    (interactive)
    (let ((revert-without-query '(".*"))
          (myframe (selected-frame)))
      (org-babel-open-src-block-result)
      (org-babel-remove-result)
      (sleep-for 0.1)
      (select-frame-set-input-focus myframe)))

  (defun my/babel-to-buffer-from-narrow ()
    (interactive)
    (org-src-do-at-code-block '(my/babel-to-buffer)))

  (defun my/toggle-local-emphasis-markers ()
    "Toggle visibility of org emphasis markers."
    (interactive)
    (setq-local org-hide-emphasis-markers (if org-hide-emphasis-markers nil t))
    (font-lock-fontify-buffer))

  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:"
            (org-id-get-with-outline-path-completion org-refile-targets)))

  (let* ((headline      `(:inherit variable-pitch :weight bold)))

    (custom-theme-set-faces
     'user
     `(org-ellipsis ((t (:inherit variable-pitch :underline nil))))
     `(org-tag ((t (:inherit default :underline nil :height 0.85))))

     `(org-indent ((t (:inherit (org-hide fixed-pitch)))))
     `(org-code ((t (:inherit fixed-pitch))))
     `(org-table ((t (:inherit fixed-pitch))))
     `(org-verbatim ((t (:inherit fixed-pitch))))
     `(org-block ((t (:inherit fixed-pitch))))

     `(org-level-8 ((t (,@headline :height 1.10))))
     `(org-level-7 ((t (,@headline :height 1.10))))
     `(org-level-6 ((t (,@headline :height 1.10))))
     `(org-level-5 ((t (,@headline :height 1.10))))
     `(org-level-4 ((t (,@headline :height 1.10))))
     `(org-level-3 ((t (,@headline :height 1.10))))
     `(org-level-2 ((t (,@headline :height 1.13))))
     `(org-level-1 ((t (,@headline :height 1.20 :underline t :extend t))))

     `(org-document-title ((t (,@headline :height 1.40 :underline nil))))))

  (defmacro my-org-in-calendar (command)
    (let ((name (intern (format "my-org-in-calendar-%s" command))))
      `(progn
         (defun ,name ()
           (interactive)
           (org-eval-in-calendar '(call-interactively #',command)))
         #',name)))

  (my-org-in-calendar calendar-backward-day)
  (my-org-in-calendar calendar-forward-day)
  (my-org-in-calendar calendar-backward-week)
  (my-org-in-calendar calendar-forward-week)
  (my-org-in-calendar calendar-backward-month)
  (my-org-in-calendar calendar-forward-month)
  (my-org-in-calendar calendar-backward-year)
  (my-org-in-calendar calendar-forward-year)

  :config
  <<org-config>>
  ;; from https://twitter.com/jay_f0xtr0t/status/982353141386461188
  ;; could be better; will currently keep adding to =org-emphasis-regexp-components=
  (setcar (nthcdr 1 org-emphasis-regexp-components)
          (concat (nth 1 org-emphasis-regexp-components) "s"))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)

  (add-to-list 'org-modules 'org-protocol)
  (add-to-list 'org-modules 'org-habit)
  (add-to-list 'org-modules 'org-id)

  (org-link-set-parameters "id"
                           :complete 'org-id-complete-link)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)
     (css . t)
     (sql . t)
     (sqlite . t)
     (python . t)))

  (defun my/insert-in-empty-src-edit ()
    (when (<= (buffer-size) 1)
      (cond ((meow-mode) (meow-insert)))))

  (advice-add 'org-edit-special :around #'my/around-recenter)

  ;; not sure why advising with :after for these breaks, but it does
  (defun my/around-recenter (orig-fun &rest args)
    (apply orig-fun args)
    (recenter))
  (advice-add 'org-next-visible-heading :around #'my/around-recenter)

  (advice-add 'org-next-link :around #'my/around-recenter))
#+end_src

Org-mouse enables nice mouse interaction with bits of org like headings and check boxes.

#+begin_src emacs-lisp
(use-package org-mouse
  :ensure nil)
#+end_src

#+begin_src emacs-lisp
(use-package org-id
  :ensure nil
  :custom
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

#+begin_src emacs-lisp
(use-package org-attach
  :ensure nil
  :after org
  :custom
  (org-attach-id-dir (concat org-directory "/data"))
  :config
  (defun my/attach (file-name)
    "Use in :tangle args of src blocks to tangle to org-attach-dir."
    (concat (file-name-as-directory (org-attach-dir t)) file-name))

  (require 'org-attach-git))
#+end_src

https://github.com/alphapapa/org-sidebar

#+begin_src emacs-lisp
(use-package org-sidebar
  :commands (org-sidebar-tree
             org-sidebar-tree-toggle
             org-sidebar-toggle
             org-sidebar))
#+end_src

Add plantuml for nice text-based diagram generation. I’ll mainly use this in org mode files, generating inline diagrams from src blocks.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :commands (plantuml-mode)
  :mode (("\\.plantuml\\'" . plantuml-mode))
  :custom
  (plantuml-default-exec-mode 'jar)
  (plantuml-jar-path "~/bin/plantuml.jar")
  (plantuml-java-args '("-Djava.awt.headless=true" "-jar")))
  ;; (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))

(use-package ob-plantuml
  :ensure nil
  :custom
  (org-plantuml-exec-mode 'jar)
  (org-plantuml-jar-path "~/bin/plantuml.jar")
  :commands
  (org-babel-execute:plantuml))
#+end_src

#+begin_src emacs-lisp
(use-package d2-mode
  :commands (d2-compile
             d2-compile-file
             d2-compile-buffer
             d2-compile-region
             d2-compile-file-and-browse
             d2-compile-buffer-and-browse
             d2-compile-region-and-browse
             d2-open-browser
             d2-view-current-svg
             d2-open-doc)
  :bind
  (:map embark-org-src-block-map
   ("F" . my/org-src-block-format))

  :custom
  (d2-flags "--sketch -t 103")

  :config
  (add-to-list 'apheleia-formatters '(d2 "d2" "fmt" "-"))
  (add-to-list 'apheleia-mode-alist '(d2-mode . d2))

  ;; Ok, this works for different blocks as long as there's a <lang>format-buffer function for the
  ;; language of the block. Good enough for d2 and sql for the moment.
  ;; Ideally it would use apheleia so everything would work the same everywhere.
  (defun my/org-src-block-format ()
    (interactive)
    (when (org-in-src-block-p)
      (let ((format-fun (intern (concat (car (org-babel-get-src-block-info))
                                        "format-buffer"))))
        (if (not (fboundp format-fun))
            (message "No format function defined")
          (org-edit-special)
          (funcall format-fun)
          (org-edit-src-exit)))))

  ;; depends on emacs-reformatter, based on sqlformat-region
  (reformatter-define d2format
    :program "d2"
    :args '("fmt" "-")
    :lighter " D2Fmt"
    :group 'd2format)
  )

;; need to sort out the load order here so this implementation is active on a restart
(use-package ob-d2
  :disabled t
  :ensure (:host github :repo "xcapaldi/ob-d2")
  :commands (org-babel-execute:d2))
#+end_src

#+begin_src emacs-lisp
(use-package restclient
  :commands (restclient-mode
             restclient-http-send-current
             restclient-http-send-current-stay-in-window))

(use-package ob-restclient
  :after (restclient)
  :commands
  (org-babel-execute:restclient))
#+end_src

A basic start at making different kinds of links look usefully different (eg. it's nice to be able to tell internal org/roam links from web links).

#+begin_src emacs-lisp
;; defface won't update an existing face (fixed in 28.1?), it has to be done like this:
;; (face-spec-set
;;  'my/org-link
;;  '((t :inherit org-link
;;       :weight normal
;;       :slant italic
;;       ))
;;  'face-defface-spec
;;  )

(defface my/org-link
  '((t (:inherit org-link :slant italic)))
  "A my-style link.")

(org-link-set-parameters "http" :face 'my/org-link)
(org-link-set-parameters "https" :face 'my/org-link)

;; (org-link-set-parameters "http" :face 'org-link)
;; (org-link-set-parameters "https" :face 'org-link)
#+end_src

Org export.

#+begin_src emacs-lisp
(use-package ox-pandoc)

(use-package ox-odt
  :ensure nil)

(use-package ox-slack
  :commands (org-slack-export-as-slack
             org-slack-export-to-slack
             org-slack-export-to-clipboard-as-slack))
#+end_src

#+begin_src emacs-lisp
(use-package org-menu
  :after (org
          transient)
  :ensure (org-menu
             :host github
             :repo "sheijk/org-menu")
  :commands (org-menu))
#+end_src

** Functions

I was sure I had a function for this, but can't find it anywhere, which means two things: I probably named it badly, and I hardly ever use it. But this was in the systemcrafters newsletter, and I do want that functionality sometimes, so here we go.

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
(defun my/org-move-done-tasks-to-bottom ()
  "Sort all tasks in the topmost heading by TODO state."
  (interactive)
  (save-excursion
    (while (org-up-heading-safe))
    (org-sort-entries nil ?o))

  ;; Reset the view of TODO items
  (org-overview)
  (org-show-entry)
  (org-show-children))
#+end_src

I was looking for a better way to insert src blocks (and other blocks) in org mode, and found [[https://takeonrules.com/2023/04/09/dig-my-grave-leveraging-the-triple-back-tick-in-org-mode/][Dig My Grave: Leveraging the Triple Back-tick in Org Mode // Take on Rules]], which I am now shamelessly stealing.

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
(defvar dig-my-grave/templates-alist/org-mode
  '(("Bash" . "#+begin_src bash :results scalar replace :exports both :tangle yes\n#+end_src")
    ("Details and Summary" . "#+begin_details\n#+begin_summary\n\n#+end_summary\n#+end_details")
    ("Emacs Lisp" . "#+begin_src emacs-lisp\n#+end_src")
    ("Org Structure" . org-insert-structure-template)
    ("Plant UML" . "#+begin_src plantuml\n@startuml\n!theme amiga\n\n@enduml\n#+end_src")
    ("SQL" . "#+begin_src sql\n#+end_src")
    ("Python" . "#+begin_src python\n#+end_src")
    ("Terraform" . "#+begin_src terraform\n#+end_src"))
  "A list of `cons' cells with `car' as the label and `cdr' as
 the value that we'll insert.  Used as the collection for the
 `dig-my-grave' `completing-read'.")

(define-key org-mode-map (kbd "`") #'dig-my-grave)
(defun dig-my-grave ()
  "Three consecutive graves (e.g. “`”) at the start of the line prompts for
 inserting content.  See `dig-my-grave/templates-alist/org-mode'."
  (interactive)
  (if (or (and (> (point) 3)
               (string= (buffer-substring-no-properties
                         (- (point) 3) (point)) "\n``"))
          ;; Account for starting on the first line
          (and (= (point) 3)
               (string= (buffer-substring-no-properties
                         (- (point) 2) (point)) "``")))
      ;; We have just hit our third backtick at the beginning of the line.
      (progn
        (delete-char -2)
        ;; I use the alist-get pattern a lot...perhaps a function?
        (let ((value (alist-get (completing-read "Special Content: "
                                                 dig-my-grave/templates-alist/org-mode nil t)
                                dig-my-grave/templates-alist/org-mode nil nil #'string=)))
          (cond
           ;; Let's assume that we're dealing with registered org blocks.
           ((stringp value)
            (insert value) (forward-line -1) (org-edit-special))
           ;; Trust the function
           ((commandp value) (call-interactively value))
           ((functionp value) (funcall value))
           ((ad-lambda-p) (funcall value))
           ;; Time for a pull request
           (t (error "Unprocessable value %s for #'dig-my-grave" value)))))
    (setq last-command-event ?`)
    (call-interactively #'org-self-insert-command)))
#+end_src

** Options

When using =C-c C-t=, allow todo state selection using single letters instead of cycling through choices. Also, don't let the options appear in a new window. Temporary org windows like this tend to be difficult to position sanely.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-use-fast-todo-selection 'expert)
#+end_src

Org file locations.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-directory "~/org")
(org-default-notes-file (if (boundp 'my/org-default-notes-file)
                            my/org-default-notes-file
                          "~/org/incoming.org"))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-refile-targets '((org-agenda-files :maxlevel . 3)))
(org-refile-allow-creating-parent-nodes 'confirm)
(org-refile-use-outline-path 'file)
(org-outline-path-complete-in-steps nil)
(org-reverse-note-order t)
(org-tags-column 0)
(org-goto-interface 'outline-path-completion)
#+end_src

This setting should make edits around special characters and collapsed outlines better. I haven't tested the various settings out yet, so this is just the first one to try.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-catch-invisible-edits 'show-and-error)
#+end_src

Just always show images; I always want them.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-startup-with-inline-images t)
(org-image-actual-width nil)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-M-RET-may-split-line '((default . nil)))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-todo-keywords '((sequence "SOMEDAY(m!)"
                               "TODO(t!)"
                               "NEXT(n!)"
                               "DOING(i!)"
                               "INTERRUPT(p!)"
                               "WAITING(w@/!)"
                               "TESTING(s@/!)"
                               "|"
                               "DONE(d!)"
                               "CANCELED(c@)")))

(org-log-into-drawer t)
(org-log-repeat nil)

;; (org-startup-indented t)
;; (org-hide-leading-stars t)
(org-ellipsis " …")
(org-fontify-whole-heading-line t)
(org-fontify-todo-headline nil)
(org-fontify-done-headline nil)
(org-hide-emphasis-markers t)
(org-pretty-entities t)
(org-cycle-separator-lines 2)
(org-M-RET-may-split-line '((default . nil)))
(org-indirect-buffer-display 'current-window)
(org-use-sub-superscripts nil)

(org-confirm-babel-evaluate nil)
(org-babel-results-keyword "results")
(org-src-fontify-natively t)
(org-src-window-setup 'current-window)
(org-src-tab-acts-natively t)
(org-src-preserve-indentation t)
(org-edit-src-content-indentation 0)

(org-fontify-whole-block-delimiter-line t)
(org-fontify-quote-and-verse-blocks t)

(org-plantuml-jar-path "~/bin/plantuml.jar")

(org-special-ctrl-a/e t)
#+end_src

Indent sub-items in lists a bit more so they're clearer.

#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-list-indent-offset 2)
#+end_src

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode))
#+end_src

#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :hook (org-mode . org-modern-mode)

  :custom
  (org-modern-hide-stars " ")
  (org-modern-star 'replace)
  (org-modern-replace-stars '("" "‣" "•" "◦" "•" "◦" "•"))
  ;; (org-modern-star ["▭" "‣" "•" "◦" "•" "◦" "•"])

  (org-modern-block-name '(("src" . ("" "⧟"))
                           ("quote" . ("〃" "⧟"))
                           (t . t)
                           ;; (t . (t " "))
                           ;; (t . ("beg" "eNd"))
                           ))
  (org-modern-block-fringe nil)

  (org-agenda-block-separator ?─)
  (org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")

  (org-modern-table nil)

  (org-modern-todo nil)
  (org-modern-timestamp nil)

  (org-modern-todo-faces '(
                           ("SOMEDAY"
                            :weight semibold
                            :background "steel blue"
                            :foreground "white")
                           ("TODO"
                            :weight semibold
                            :background "orange1"
                            :foreground "black")
                           ("NEXT"
                            :weight semibold
                            :background "gold"
                            :foreground "black")
                           ("DOING"
                            :weight semibold
                            :background "OliveDrab4"
                            :foreground "white")
                           ))

  :custom-face
  (org-modern-symbol ((t (:family "Iosevka" :height 1.13)))))
#+end_src

#+begin_src emacs-lisp
(use-package org-indent
  :ensure nil
  :after org
  :hook (org-mode . org-indent-mode)
  :custom
  (org-indent-mode-turns-on-hiding-stars nil)
  (org-indent-indentation-per-level 1))
#+end_src

** Hooks

For a bit more org mode prettiness: =variable-pitch-mode=, which sets up different fonts for different parts of the file, specifically, mono-space fonts for src blocks, and variable width fonts elsewhere.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . variable-pitch-mode)
#+end_src

I want all drawers hidden on file load.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . my/org-hide-all-drawers)
#+end_src

I use plantuml to generate various images, and this makes sure that generated images are redisplayed after re-processing diagram source code in a block.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-babel-after-execute . org-redisplay-inline-images)
#+end_src

Flycheck gives way too many errors when editing src blocks in their own buffer. I should probably look into re-enabling useful parts of it though.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-src-mode . disable-flycheck-in-org-src-block)
#+end_src

Show the heading of a table when it's scrolled offscreen.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . org-table-header-line-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-src-mode . my/insert-in-empty-src-edit)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-insert-heading . my/insert-mode)
(org-metareturn . my/insert-mode)
(org-capture-mode . my/insert-mode)
#+end_src

** Keybindings

#+begin_src emacs-lisp :tangle no :noweb-ref org-keys
(:repeat-map org-link-repeat-map
 ("n" . org-next-link)
 ("p" . org-previous-link))
#+end_src

** Org agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :custom
  (org-agenda-files '("~/org/"))

  (org-agenda-restore-windows t)
  (org-agenda-window-setup 'current-window)

  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)

  (org-agenda-format-date "%A, %B %-d, %Y")

  (org-stuck-projects '("+LEVEL=2/-DONE"
                        ("NEXT")
                        nil
                        ""))

  :bind
  (:map org-mode-map
   ("C-'" . nil)
   ("C-," . nil)
   :map mode-specific-map
   ("a" . org-agenda))

  :init
  (defun my/agenda-current-window ()
    (interactive)
    (let ((org-agenda-window-setup 'only-window))
      (org-agenda)
      (delete-other-windows))))
#+end_src

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after (org org-agenda)
  :hook (org-agenda-mode . org-super-agenda-mode)
  :bind
  (:map org-super-agenda-header-map
   ("n" . nil)
   ("t" . nil))
  :custom-face
  (org-super-agenda-header ((t (:inherit 'org-level-1 :extend t))))
  :custom
  (org-super-agenda-header-properties '(org-agenda-structural-header t))
  (org-super-agenda-date-format "%A, %B %d, %Y")

  (org-agenda-custom-commands
   '(("n" "Agenda and all TODOs"
      ((agenda "-archive")
       (alltodo ""))
      ((org-agenda-tag-filter-preset '("-archive"))))

     ("p" "Personal"
      ((agenda "" ((org-super-agenda-groups
                    '((:name " Schedule"
                       :time-grid t
                       :deadline t
                       :scheduled t
                       )))))
       (search "*" ((org-super-agenda-groups
                     '((:name "Inbox"
                        :file-path "~/org/incoming.org"
                        :discard (:heading-regexp ".*Incoming")
                        :tag "refile")
                       (:discard (:anything t))))))
       (tags-todo "-archive -work" ((org-super-agenda-groups
                                     '((:name " Doing"
                                        :todo "DOING")
                                       (:name " Waiting/Testing"
                                        :todo ("WAITING" "TESTING"))
                                       (:name " Next"
                                        :todo "NEXT")
                                       (:discard (:anything t)))))))
      ((org-agenda-files '("~/org"))
       (org-agenda-span 'day)
       (org-agenda-tag-filter-preset '("-work"))))

     ("w" "Work"
      ((agenda "" ((org-super-agenda-groups
                    `((:name ,(format " Schedule")
                       :time-grid t
                       :deadline t
                       :scheduled t
                       )))))
       (org-ql-block '(and (outline-path-segment "Notes")
                           (tags "work")
                           (ts-active))
                     ((org-ql-block-header "Notes To Process")))
       (tags-todo "-archive +work" ((org-super-agenda-groups
                                     `((:name ,(format " Interruptions")
                                        :todo "INTERRUPT")
                                       (:name ,(format " Doing")
                                        :todo "DOING")
                                       (:name ,(format " Waiting/Testing")
                                        :todo ("WAITING" "TESTING"))
                                       (:name ,(format " Next")
                                        :todo "NEXT")
                                       (:discard (:anything t)))))))
      ((org-agenda-files '("~/org/work-tveon.org"))
       (org-agenda-span 'day)))

     ))

   ;; (org-super-agenda-groups '(
   ;;                            (:name "Today"
   ;;                             :time-grid t)
   ;;                            (:name "now"
   ;;                             :deadline today
   ;;                             :scheduled today)
   ;;                            (:name "Doing"
   ;;                             :todo "DOING")
   ;;                            (:name "Next"
   ;;                             ;; :auto-parent t
   ;;                             :and (:todo "TODO" :priority "A"))
   ;;                            (:name "Projects"
   ;;                             :children 'todo)
   ;;                            (:name "Waiting"
   ;;                             ;; :auto-parent t
   ;;                             :todo "WAITING")
   ;;                            ))
                             )
#+end_src

** Org Capture

#+begin_src emacs-lisp
(use-package doct
  :commands (doct))
#+end_src

#+begin_src emacs-lisp
(use-package org-capture
  :ensure nil
  :after org
  :custom
  (org-capture-bookmark nil)
  (org-capture-templates
   (doct '(("todo"
            :keys "t"
            :file ""
            :headline "Incoming"
            :template ("* TODO %?" "%U")
            :prepend t)
           ("someday"
            :keys "m"
            :file ""
            :headline "Incoming"
            :template ("* SOMEDAY %?" "%U")
            :prepend t)
           ("interruption"
            :keys "i"
            :file ""
            :headline "Incoming"
            :template "* INTERRUPT %?"
            :prepend t)
           ("note"
            :keys "n"
            :file ""
            :headline "Incoming"
            :template ("* %?" "%T")
            :prepend t)
           ("link"
            :keys "l"
            :file ""
            :headline "Incoming"
            :template "* [[%x][%?]] %^g"
            :prepend t)
           ("web"
            :keys "w"
            :file ""
            :headline "Incoming"
            :template ("* %a" "%U" "%i%?")
            :prepend t)
           ("test"
            :keys "x"
            :file ""
            :headline "Incoming"
            :template ("* %:url" "Source: %u, %c" "%i%?")
            :prepend t)
           )))

  :hook (org-capture-mode . my/full-frame-capture)

  :init
  (defun my/org-capture-someday ()
    (interactive)
    (org-capture nil "m"))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (when (and (equal "capture" (frame-parameter nil 'name))
               (not (eq this-command 'org-capture-refile)))
      (delete-frame)))

  (defadvice org-capture-refile
      (after delete-capture-frame activate)
    "Advise org-refile to close the frame"
    (when (and (equal "capture" (frame-parameter nil 'name))
               (not (eq this-command 'org-capture-refile)))
      (delete-frame)))

  (defun my/capture-full-frame ()
    "Start org-capture in a frame by itself."
    (interactive)
    (org-capture)
    (delete-other-windows))

  (defun my/full-frame-capture ()
    (if (string= (frame-parameter nil 'name) "capture")
        (delete-other-windows)))

  :config
  ;; from https://stackoverflow.com/questions/54192239/open-org-capture-buffer-in-specific-window/54251825#54251825
  ;; modifies the capture process to not mess up window layouts, even temporarily, and make the capture window more controllable
  (defun my-org-capture-place-template-dont-delete-windows (oldfun &rest args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  (with-eval-after-load "org-capture"
    (advice-add 'org-capture-place-template :around
                'my-org-capture-place-template-dont-delete-windows))
  )
#+end_src

#+begin_src emacs-lisp
(use-package org-protocol
  :ensure nil
  :after org)
#+end_src

We need a little desktop integration for =org-protocol=, Linux-only, currently. First up is the systemd configuration for the emacs server process. Yes, there's one included with emacs, but this way I can customize it more easily. Needs a ~systemctl --user enable emacs-server~ and ~systemctl --user start emacs-server~ to use.

#+begin_src conf :tangle ~/.config/systemd/user/emacs-server.service :mkdirp yes
[Unit]
Description=Emacs (server)
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

# need WAYLAND_DISPLAY set in emacs
[Service]
Type=notify
ExecStart=emacs --fg-daemon --chdir %h
# ExecStart=/usr/bin/emacs --fg-daemon
ExecStop=emacsclient --eval "(kill-emacs)"
# Environment=SSH_AUTH_SOCK=/run/user/%U/ssh-agent.socket
Environment=SSH_AUTH_SOCK=/run/user/%U/keyring/ssh
# Environment=SSH_AUTH_SOCK=${XDG_RUNTIME_DIR}/ssh-agent.socket
# Environment=SSH_AUTH_SOCK=%t/keyring/ssh XDG_RUNTIME_DIR=/run/user/%U EMACS_SOCKET_NAME=/run/user/%U/emacs/server
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

And an ~emacsclient~ .desktop file to integrate it into the gnome desktop.

#+begin_src conf :tangle ~/.local/share/applications/emacsclient.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs (client)
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
# Exec=/usr/bin/emacsclient -c %F
Exec=emacsclient --create-frame --alternate-editor="emacs" %F
Icon=emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
#+end_src

Then a handler for =org-protocol:= URLs so that browsers can open them with ~emacsclient~.

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop :mkdirp yes
[Desktop Entry]
Name=org-protocol
Exec=emacsclient -c -F '(quote (name . "capture"))' %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

** Org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :commands (org-roam-db-autosync-mode
             org-roam-capture
             org-roam-buffer-toggle
             org-roam-node-find
             org-roam-node-insert)

  :custom
  (org-roam-database-connector 'sqlite-builtin)
  (org-roam-directory "~/org/roam")
  (org-roam-completion-everywhere t)
  (org-roam-list-files-commands '(rg find))
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("p" "project" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: project\n\n")
      :unnarrowed t)
     ;; ("l" "literature" plain
     ;;  "%?"
     ;;  :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "%^{roam_refs|%x}p#+title: ${title}\n#+filetags: literature\n\n")
     ;;  :unnarrowed t)
     ))
  ;; (org-roam-buffer-window-parameters '((no-other-window . t)))

  :bind
  (:map my/notes-map
   ("n" . org-roam-node-find)
   ("i" . org-roam-node-insert)
   ("S-r" . org-roam-node-random))

  ;;   "N" #'(lambda () (interactive) (my/customize-this "my/org-roam-context"))

  :init
  (defun my/dnd-only (node)
    (my/by-tag "d&d" node))

  (defun my/projects-only (node)
    (my/by-tag "project" node))

  (defun my/by-tag (tag node)
    (member tag (org-roam-node-tags node)))


  (defun my/org-roam-node-find ()
    (interactive)
    (org-roam-node-find t nil #'my/notes-by-context))

  (defun my/set-org-roam-context (sym value)
    (setq my/org-roam-context value))

  (defcustom my/org-roam-context "personal"
    "Set org roam context."
    :type '(choice
            (const "personal")
            (const "work")
            (const "d&d"))
    :set 'my/set-org-roam-context
    :initialize 'custom-initialize-set)

  (defun my/notes-by-context (node)
    (let ((tags (org-roam-node-tags node)))
      (cond ((equal my/org-roam-context "personal")
             ;; '(notes-not-tagged "work"))
             (not (member "work" tags)))
            ((equal my/org-roam-context "work")
             ;; '(notes-by-tag "work"))
             (member "work" tags))
            ((equal my/org-roam-context "d&d")
             (member "d&d" tags))
             ;; '(notes-by-tag "d&d"))
            (t '(lambda (node) t))
            )))

  (defmacro notes-by-context ()
    (cond ((equal my/org-roam-context "personal")
           (notes-not-tagged "work"))
          ((equal my/org-roam-context "work")
           (notes-by-tag "work"))
          ((equal my/org-roam-context "d&d")
           (notes-by-tag "d&d"))
          (t '(lambda (node) t))
          ))


  (defmacro notes-tagged (tag)
    (let ((name (intern (format "notes-tagged-%s" tag))))
      `(progn
         (defun ,name (node)
           (member ,tag (org-roam-node-tags node)))
         #',name)))

  (defmacro notes-by-tag (tag)
    `(lambda (node)
       (member ,tag (org-roam-node-tags node))))

  (defmacro notes-not-tagged (tag)
    `(lambda (node)
       (not (member ,tag (org-roam-node-tags node)))))


  (defun my/check-org-files ()
    (when (> (length (directory-files org-directory nil "\\.org$")) 0)
      (org-roam-db-autosync-mode t)
      (cancel-function-timers #'my/check-org-files)))

  (run-with-timer 0 5 #'my/check-org-files)

  :config
  (cl-defmethod org-roam-node-directories ((node org-roam-node))
    (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (format "%s" (car (split-string dirs "/")))
      ""))

  (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
    (let ((level (org-roam-node-level node)))
      (concat
       (when (> level 0) (concat (org-roam-node-file-title node) " > "))
       (when (> level 1) (concat (string-join (org-roam-node-olp node) " > ") " > "))
       (org-roam-node-title node))))

  (setq org-roam-node-display-template
        (concat "${directories:8} ${hierarchy:*} "
                (propertize "${tags:10}" 'face 'org-tag)))

  (defun my/org-roam-ref-add-dwim ()
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and clipboard-url (not point-in-link))
             (org-roam-ref-add clipboard-url))
            (t
             (call-interactively #'org-roam-ref-add)))))

  ;; https://org-roam.discourse.group/t/opening-url-in-roam-refs-field/2564/3
  (defun my/open-node-roam-ref-url ()
    "Open the URL in this node's ROAM_REFS property, if one exists"
    (interactive)
    (when-let ((ref-url (org-entry-get-with-inheritance "ROAM_REFS")))
      (browse-url ref-url)))

  ;; https://ag91.github.io/blog/2021/03/12/find-org-roam-notes-via-their-relations/
  (defun my/navigate-note (arg &optional node choices)
    "Navigate notes by link. With universal ARG tries to use only to navigate the tags of the current note. Optionally takes a selected NOTE and filepaths CHOICES."
    (interactive "P")
    (let* ((depth (if (numberp arg) arg 1))
           (choices
            (or choices
                (when arg
                  (-map #'org-roam-backlink-target-node (org-roam-backlinks-get (org-roam-node-from-id (or (ignore-errors (org-roam-node-id node))
                                                                                                           (org-id-get-create))))))))
           (all-notes (org-roam-node-read--completions))
           (completions
            (or (--filter (-contains-p choices (cdr it)) all-notes) all-notes))
           (next-node
            ;; taken from org-roam-node-read
            (let* ((nodes completions)
                   (node (completing-read
                          "Node: "
                          (lambda (string pred action)
                            (if (eq action 'metadata)
                                '(metadata
                                  (annotation-function . (lambda (title)
                                                           (funcall org-roam-node-annotation-function
                                                                    (get-text-property 0 'node title))))
                                  (category . org-roam-node))
                              (complete-with-action action nodes string pred))))))
              (or (cdr (assoc node nodes))
                  (org-roam-node-create :title node)))
            )
           )
      (if (equal node next-node)
          (org-roam-node-visit node)
        (my/navigate-note nil next-node (cons next-node (-map #'org-roam-backlink-source-node (org-roam-backlinks-get next-node)))))))
  )

(use-package org-roam-dailies
  :after org-roam
  :ensure nil
  :custom
  (org-roam-dailies-directory "daily/")
  (org-roam-dailies-capture-templates
   '(("d" "default" entry "* %<%k:%M> %?"
      :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))

  :bind
  (:map my/notes-map
   ("d" . org-roam-dailies-capture-today)
   ("S-d" . org-roam-dailies-capture-date)
   ("." . org-roam-dailies-goto-today)
   (">" . org-roam-dailies-goto-date)
   ("r" . my/org-roam-dailies-review))

  :config
  ;; deps: org, org-roam, org-transclusion, ts, s
  (defun my/org-roam-dailies-review (&optional start-date end-date)
    (interactive)
    (let* ((all-nodes (org-roam-db-query [:select [id file title] :from nodes :order-by [title]]))
           (daily-path (expand-file-name org-roam-dailies-directory org-roam-directory))
           (beg (ts-parse (or start-date
                              (org-read-date nil nil nil "Review start date: "))))
           (end (ts-parse (or end-date
                              (org-read-date nil nil nil "Review end date: "))))
           (nodes
            (mapcar (lambda (node)
                      (concat "#+transclude: [[id:" (nth 0 node) "][" (nth 2 node) "]]"))
                    (cl-delete-if-not (lambda (node)
                                        (and (s-starts-with? daily-path (nth 1 node))
                                             (ts-in beg end (ts-parse (nth 2 node)))))
                                      all-nodes))))

      (switch-to-buffer (get-buffer-create "*Review*"))
      (org-mode)
      (insert (string-join nodes "\n\n\n"))
      (org-roam-update-org-id-locations)
      (org-transclusion-mode t)
      (goto-char (point-min))))

  (defun my/org-roam-dailies-review-week-current ()
    (interactive)
    (let* ((now (ts-now))
           (adjust-beg-day (- (ts-dow now)))
           (adjust-end-day (+ (- 6 (ts-dow now))))
           (beg (ts-adjust 'day adjust-beg-day now))
           (end (ts-adjust 'day adjust-end-day now))
           (ts-default-format "%Y-%m-%d"))
      (my/org-roam-dailies-review (ts-format beg) (ts-format end))))
  )
#+end_src

#+begin_src emacs-lisp
(use-package ts)
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode)
  :custom
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-sync-theme t))
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-timestamps
  :after org-roam
  :config
  (org-roam-timestamps-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package org-download
  :after org
  :hook (dired-mode . org-download-enable)
  :commands (org-download-screenshot
             org-download-yank)
  :custom
  (org-download-method 'attach))
#+end_src

#+begin_src emacs-lisp
(use-package org-ql
  :commands (org-ql-select
             org-ql-search
             org-ql-view
             org-ql-view-recent-items
             org-ql-sparse-tree))
#+end_src

#+begin_src emacs-lisp
(use-package org-sticky-header
  :after org
  :hook (org-mode . org-sticky-header-mode)
  :commands (org-sticky-header-mode)
  :custom
  (org-sticky-header-prefix "🦜 ")
  (org-sticky-header-full-path 'reversed))
#+end_src

#+begin_src emacs-lisp
(use-package org-transclusion
  :commands (org-transclusion-add
             org-transclusion-mode)
  :custom
  (org-transclusion-extensions '(org-transclusion-src-lines
                                 org-transclusion-font-lock
                                 org-transclusion-indent-mode)))
#+end_src

* SVG Prettiness

Built-in SVG rendering provides some nice potential for some pretty, so let's set that up here. First, add the [[https://github.com/rougier/svg-lib][svg-lib]] package.

#+begin_src emacs-lisp
(use-package svg-lib)
#+end_src

Then we add [[https://github.com/rougier/svg-tag-mode][svg-tag-mode]], which makes it easy to replace some text elements with generated SVG images.

#+begin_src emacs-lisp
(use-package svg-tag-mode
  :commands (svg-tag-make
             svg-tag-mode)
  :init
  ;; from https://www.reddit.com/r/emacs/comments/18v02tc/fancy_tabbar_with_svg/
  (defface tab-bar-svg-active
    '((t (:foreground "#a1aeb5")))
    "Tab bar face for selected tab.")

  (defface tab-bar-svg-inactive
    '((t (:foreground "#a1aeb5")))
    "Tab bar face for inactive tabs.")

  (defun my/tab-bar-svg-padding (width string)
    (let* ((style svg-lib-style-default)
           (margin      (plist-get style :margin))
           (txt-char-width  (window-font-width nil 'fixed-pitch))
           (tag-width (- width (* margin txt-char-width)))
           (padding (- (/ tag-width txt-char-width) (length string))))
      padding))

  (defun my/tab-bar-tab-name-with-svg (tab i)
    (let* ((current-p (eq (car tab) 'current-tab))
           (name (concat (if tab-bar-tab-hints (format "%d " i) "")
                         (alist-get 'name tab)
                         (or (and tab-bar-close-button-show
                                  (not (eq tab-bar-close-button-show
                                           (if current-p 'non-selected 'selected)))
                                  tab-bar-close-button)
                             "")))
           (padding (plist-get svg-lib-style-default :padding))
           (width)
           (image-scaling-factor 1.0))
      (when tab-bar-auto-width
        (setq width (/ (frame-inner-width)
                       (length (funcall tab-bar-tabs-function))))
        (when tab-bar-auto-width-min
          (setq width (max width (if (window-system)
                                     (nth 0 tab-bar-auto-width-min)
                                   (nth 1 tab-bar-auto-width-min)))))
        (when tab-bar-auto-width-max
          (setq width (min width (if (window-system)
                                     (nth 0 tab-bar-auto-width-max)
                                   (nth 1 tab-bar-auto-width-max)))))
        (setq padding (my/tab-bar-svg-padding width name)))
      (propertize
       name
       'display
       (svg-tag-make
        name
        :face (if (eq (car tab) 'current-tab) 'tab-bar-svg-active 'tab-bar-svg-inactive)
        :inverse (eq (car tab) 'current-tab) :margin 0 :radius 6 :padding padding
        :height 1.1))))

  :config
  (plist-put svg-lib-style-default :font-family (face-attribute 'default :family))
  (plist-put svg-lib-style-default :font-size (/ (face-attribute 'default :height) 10))

  (defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
  (defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
  (defconst day-re "[A-Za-z]\\{3\\}")
  (defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

  (setq svg-tag-tags
        `(("TODO" . ((lambda (tag) (svg-tag-make "TODO"
                                                 :face '(:weight semibold
                                                         :background "orange1"
                                                         :foreground "black")))))
          ("SOMEDAY" . ((lambda (tag) (svg-tag-make "SOMEDAY"
                                                    :face '(:weight semibold
                                                            :background "steel blue"
                                                            :foreground "white")))))
          ("DOING" . ((lambda (tag) (svg-tag-make "DOING"
                                                  :face '(:weight semibold
                                                          :background "OliveDrab4"
                                                          :foreground "white")))))
          ("WAITING" . ((lambda (tag) (svg-tag-make "WAITING"
                                                    :face '(:weight semibold
                                                            :background "OliveDrab4"
                                                            :foreground "white")))))
          ("DONE" . ((lambda (tag) (svg-tag-make "DONE"
                                                 :face 'org-done))))
          ("CANCELED" . ((lambda (tag) (svg-tag-make "CANCELED"
                                                     :face 'org-done))))
          ("NEXT" . ((lambda (tag) (svg-tag-make "NEXT"
                                                 :face '(:weight semibold
                                                         :background "gold"
                                                         :foreground "black")))))

          (,(format "\\(<%s>\\)" date-re) .
           ((lambda (tag)
              (svg-tag-make tag :beg 1 :end -1 :margin 0))))
          (,(format "\\(<%s \\)%s>" date-re day-time-re) .
           ((lambda (tag)
              (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
          (,(format "<%s \\(%s>\\)" date-re day-time-re) .
           ((lambda (tag)
              (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

          ;; Inactive date  (with or without day name, with or without time)
          (,(format "\\(\\[%s\\]\\)" date-re) .
           ((lambda (tag)
              (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-modern-date-inactive))))
          (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
           ((lambda (tag)
              (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-modern-date-inactive))))
          (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
           ((lambda (tag)
              (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-modern-date-inactive))))
          ))

  ;; (setq tab-bar-tab-name-format-function #'my/tab-bar-tab-name-with-svg)
  )
#+end_src

* Window management

Let’s try to get some window behaviour under control.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(switch-to-buffer-in-dedicated-window 'pop)
(switch-to-buffer-obey-display-actions t)
#+end_src

 #+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(display-buffer-alist
 '(("\\*Org Select\\*"
    (display-buffer-below-selected))
   ("\\*Agenda Commands\\*"
    (display-buffer-below-selected))
   ("Calendar"
    (display-buffer-below-selected))
   ("\\^CAPTURE-"
    (display-buffer-below-selected))
   ("\\*Embark Collect:"
    (my/display-buffer-to-right-or-left))
   ;; ("\\*Messages\\*$"
   ;;  (display-buffer-below-selected))
   ("magit-diff:"
    (display-buffer-below-selected)
    (window-height . 0.6))
   ("\\*helpful"
    (display-buffer-reuse-mode-window display-buffer-pop-up-window)
    (mode . helpful-mode))))
#+end_src

Came from: [[https://stackoverflow.com/questions/50857088/emacs-auto-display-of-things-at-point-in-a-right-window][Emacs auto-display of things at point in a right window - Stack Overflow]]
#+begin_src emacs-lisp
(defun my/non-minibuffer-current-window ()
  (if (minibuffer-window-active-p (selected-window))
      (get-buffer-window (nth 1 (buffer-list)))
    (selected-window)))

(defun my-display-buffer (buffer-or-name alist direction &optional size pixelwise)
  "BUFFER:  The buffer that will be displayed.
ALIST:  See the doc-string of `display-buffer' for more information.
DIRECTION:  Must use one of these symbols:  'left 'right 'below 'above
SIZE:  See the doc-string for `split-window'.
PIXELWISE:  See the doc-string for `split-window'.
There are three possibilities:
-  (1) If a window on the frame already displays the target buffer,
then just reuse the same window.
-  (2) If there is already a window in the specified direction in relation
to the selected window, then display the target buffer in said window.
-  (3) If there is no window in the specified direction, then create one
in that direction and display the target buffer in said window."
  (let* ((buffer
          (if (bufferp buffer-or-name)
              buffer-or-name
            (get-buffer buffer-or-name)))
         (window
          (cond
           ((get-buffer-window buffer (selected-frame)))
           ((if (minibuffer-window-active-p (selected-window))
                (with-selected-window (my/non-minibuffer-current-window)
                  (window-in-direction direction))
              (window-in-direction direction)))
           (t
            (with-current-buffer buffer
              (add-hook 'kill-buffer-hook #'delete-window 0 t))
            (split-window (my/non-minibuffer-current-window) size direction pixelwise)))))
    (window--display-buffer buffer window 'reuse alist)
    window))

(defun my/display-buffer-to-right (buffer alist)
  (my-display-buffer buffer alist 'right)
  )

(defun my/find-window-direction ()
  (with-selected-window (if (minibuffer-window-active-p (selected-window))
                            (get-buffer-window (nth 1 (buffer-list)))
                          (selected-window))
    (let ((right (window-in-direction 'right))
          (left (window-in-direction 'left)))
      (cond ((windowp right) 'right)
            ((windowp left) 'left)
            (t 'right)))))

(defun my/display-buffer-to-right-or-left (buffer alist)
  (my-display-buffer buffer alist (my/find-window-direction)))
#+end_src

#+begin_src emacs-lisp
;; from https://christiantietze.de/posts/2022/12/updated-org-mode-agenda-display-buffer-alist/
(defun ct/display-buffer-org-agenda-managed-p (buffer-name action)
  "Determine whether BUFFER-NAME is an org-agenda managed buffer."
  (with-current-buffer buffer-name
    (and (derived-mode-p 'org-mode)
         (member (buffer-file-name) (org-agenda-files)))))

;; these seem to do odd things to org mode windows, I think I need my org-agenda-files var to be
;; more specific to make this stuff work? or maybe getting fancy with this in combination with
;; tabspaces won't really work.
;; (add-to-list 'display-buffer-alist
;;              `("\\*Org Agenda\\*"
;;                (display-buffer-in-tab  ;; Make sure to use the "agenda" tab
;;                 display-buffer-reuse-mode-window)
;;                (ignore-current-tab . t)
;;                (tab-name . "agenda")
;;                (window-width . fill-column)
;;                (dedicated . side)  ;; Make the agenda a dedicated side-window
;;                (side . left)       ;; to the left so it always stays open.
;;                (inhibit-same-window . nil)))
;; (add-to-list 'display-buffer-alist
;;              '(ct/display-buffer-org-agenda-managed-p
;;                (display-buffer-reuse-mode-window  ;; Prioritize reuse of current window
;;                 display-buffer-in-tab)            ;; over switching to the Org tab.
;;                (tab-name . "agenda")))

(defun my/toggle-window-dedication ()
  "Toggles window dedication in the selected window."
  (interactive)
  (set-window-dedicated-p (selected-window)
     (not (window-dedicated-p (selected-window)))))
#+end_src

#+begin_src emacs-lisp
(use-package winner
  :ensure nil
  :init
  (winner-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package tab-bar
  :ensure nil
  :custom
  (tab-bar-show 1)
  (tab-bar-tab-name-format-function #'my/tab-bar-tab-name-format-default)
  (tab-bar-format '(tab-bar-format-history
                    tab-bar-format-tabs-groups
                    tab-bar-separator
                    tab-bar-format-add-tab
                    ))
  (tab-bar-close-button-show nil)
  (tab-bar-new-button-show nil)
  (tab-bar-auto-width nil)
  :custom-face
  (tab-bar-tab ((t (:height 1.0
                    :family ,(face-attribute 'variable-pitch :family)
                    :weight bold
                    )))
               )
  (tab-bar-tab-inactive ((t (:height 0.95
                             :family ,(face-attribute 'variable-pitch :family)
                             :weight light
                             :box nil
                             )))
                        )

  :bind
  (:map tab-bar-map
   ("<mouse-4>" . tab-next)
   ("<mouse-5>" . tab-previous)
   ("<wheel-up>" . tab-next)
   ("<wheel-down>" . tab-previous)
   :map my/window-map
   ("g" . tab-previous)
   ("l" . tab-next)
   ("G" . tab-bar-move-tab-backward)
   ("L" . tab-move)
   :repeat-map tab-bar-switch-repeat-map
   ("o" . nil)
   ("O" . nil)
   ("g" . tab-previous)
   ("l" . tab-next)
   ("G" . tab-bar-move-tab-backward)
   ("L" . tab-move))

  :init
  (defun my/tab-bar-tab-name-format-default (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (propertize
       (concat
        "  "
        (if tab-bar-tab-hints (format "%d " i) "")
        (alist-get 'name tab)
        (or (and tab-bar-close-button-show
                 (not (eq tab-bar-close-button-show
                          (if current-p 'non-selected 'selected)))
                 tab-bar-close-button)
            "")
        "  "
        )
       'face (funcall tab-bar-tab-face-function tab))))

  :config
  (tab-bar-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package popper
  :bind
  (("C-`"   . popper-toggle)
   ("M-`"   . Popper-cycle)
   ("C-M-`" . popper-toggle-type))

  (:repeat-map popper-repeat-map
   ("c" . popper-cycle)
   ("k" . popper-kill-latest-popup)
   ("p" . popper-toggle))

  :custom
  (popper-group-function #'my/popper-group)
  (popper-display-function #'display-buffer-below-selected)
  (popper-display-control nil)
  (popper-reference-buffers
   '("\\*Messages\\*"
     messages-buffer-mode
     compilation-mode
     help-mode
     "\\*Warnings\\*"
     "\\*helpful"
     "Output\\*"
     ("\\*Shell Command Output\\*" . hide)))

  :init
  (defun my/current-tab-name ()
    (let* ((tabs (frame-parameter nil 'tabs))
           (current-tab (tab-bar--current-tab-find tabs))
           (current-tab-name (assq 'name current-tab)))
      (cdr current-tab-name)))

  (defun my/popper-group ()
    (selected-frame))

  (popper-mode t)
  (popper-echo-mode t))
#+end_src

** Sway

#+begin_src emacs-lisp
(use-package sway)
#+end_src

* Window Navigation

#+begin_src emacs-lisp
(use-package repeat
  :ensure nil
  :custom
  (repeat-exit-key "q")
  (repeat-exit-timeout 2)

  :init
  (defvar my/repeat-command-timeouts '()
    "A list of (command . timeout) pairs used to set repeat-exit-timeouts.")

  (setq my/repeat-command-timeouts '((scroll-other-window . no)
                                     (scroll-other-window-down . no)
                                     (other-window . 0.3)))

  (defun my/repeat-timeout-setter ()
    "Set specified repeat-exit-timeouts for some commands."
    (interactive)
    (dolist (command my/repeat-command-timeouts)
      (put (car command) 'repeat-exit-timeout (cdr command))))

  (add-hook 'elpaca-after-init-hook #'my/repeat-timeout-setter)

  :config
  (repeat-mode t))

(use-package repeat-help
  :hook (repeat-mode . repeat-help-mode))
#+end_src

#+begin_src emacs-lisp
(use-package window
  :ensure nil

  :preface
  ;; save a copy of the original recenter function, because I'm going to replace it
  (unless (fboundp 'original-recenter)
    (fset 'original-recenter (symbol-function 'recenter)))

  :custom
  (recenter-positions '(0.2 top bottom))

  :init
  (defcustom my/recenter-window-eye-level 0.2
    "The relative position of the line considered as eye level in the
current window, as a ratio between 0 and 1.")

  (defun my/recenter-eye-level (&optional arg redisplay)
    "Without args, recenter nearer the top of the window. With args, call original recenter."
    (interactive)
    (let ((line (or (if (number-or-marker-p arg) arg nil)
                    (round (* (window-height) my/recenter-window-eye-level)))))
      (original-recenter line redisplay)))
  (fset 'recenter #'my/recenter-eye-level)

  :bind
  ("M-o" . other-window)

  (:repeat-map act-on-other-window-repeat-map
   ("<next>" . scroll-other-window)
   ("<prior>" . scroll-other-window-down)
   :exit
   ("k" . delete-window)
   ("K" . delete-other-windows)

   :repeat-map center-top-bottom-repeat-map
   ("r" . move-to-window-line-top-bottom)

   :map my/window-map
   ("|" . split-window-right)
   ("-" . split-window-below)

   ("k" . delete-window)
   ("K" . delete-other-windows)))
#+end_src

#+begin_src emacs-lisp
(use-package which-key
  :custom
  (which-key-popup-type 'minibuffer)
  (which-key-separator " ")
  :config
  (which-key-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (:map my/window-map
   ("h" . windmove-left)
   ("s" . windmove-right)
   ("n" . windmove-up)
   ("t" . windmove-down)

   ("H" . windmove-swap-states-left)
   ("S" . windmove-swap-states-right)
   ("N" . windmove-swap-states-up)
   ("T" . windmove-swap-states-down)

   :repeat-map windmove-repeat-map
   ("h" . windmove-left)
   ("s" . windmove-right)
   ("n" . windmove-up)
   ("t" . windmove-down)

   ("H" . windmove-swap-states-left)
   ("S" . windmove-swap-states-right)
   ("N" . windmove-swap-states-up)
   ("T" . windmove-swap-states-down)))
#+end_src

#+begin_src emacs-lisp
(use-package ace-window
  :commands (aw-display-buffer
             ace-window
             my/other-window-prefix)
  :custom
  (aw-scope 'frame)
  (aw-keys '(?a ?o ?e ?u ?h ?t ?s))
  (aw-reverse-frame-list t)

  :bind
  (:map my/window-map
   ("j" . ace-window)
   ("x" . ace-delete-window)
   ("z" . my/other-window-prefix)
   :repeat-map act-on-other-window-repeat-map
   :exit
   ("x" . ace-delete-window))

  :init
  (defun my/other-window-prefix ()
    "Display the buffer of the next command in a new window.
The next buffer is the buffer displayed by the next command invoked
immediately after this command (ignoring reading from the minibuffer).
Creates a new window before displaying the buffer.
When `switch-to-buffer-obey-display-actions' is non-nil,
`switch-to-buffer' commands are also supported."
    (interactive)
    (display-buffer-override-next-command
     (lambda (buffer alist)
       (let ((aw-dispatch-always t)
             ;; (alist (append '((inhibit-same-window . t)) alist))
             window type)
         (setq window (ace-display-buffer buffer alist))
         (setq type 'window)
         ;; (if (setq window (display-buffer-pop-up-window buffer alist))
         ;;     (setq type 'window)
         ;;   (setq window (display-buffer-use-some-window buffer alist)
         ;;         type 'reuse))
         (cons window type)))
     (lambda (_ _) (balance-windows (window-parent))) "[other-window]")
    (message "Display next command buffer in a new window..."))

  :config
  (setq display-buffer-base-action
        '((display-buffer-reuse-window
           ace-display-buffer))))
#+end_src

* Scrolling

Set scrolling options. These stop the half-page jumps while scrolling, and make things smoother.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(mouse-wheel-scroll-amount '(4 ((shift) . 1)))
(mouse-wheel-progressive-speed nil)
(mouse-wheel-follow-mouse 't)
(mouse-autoselect-window nil)
(scroll-step 1)
(scroll-margin 3)
(hscroll-step 3)
(hscroll-margin 3)
(scroll-preserve-screen-position 'always)
(scroll-up-aggressively 0.01)
(scroll-down-aggressively 0.01)
(scroll-conservatively 101)
#+end_src

And let’s try out the new single-line-horizontal-scroll option in emacs 26.

#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(auto-hscroll-mode 'current-line)
#+end_src

#+begin_src emacs-lisp
(use-package scrollkeeper
  :disabled t
  :custom
  (scrollkeeper-scroll-steps 6)
  (scrollkeeper-scroll-distance 0.80)
  (scrollkeeper-guideline-pulse-interval 0.06)
  (scrollkeeper-guideline-fn #'scrollkeeper--highlight)
  :custom-face
  (scrollkeeper-guideline-highlight ((t (:background "#ffffaa" :extend t))))
  :bind
  (([remap scroll-up-command] . scrollkeeper-down)
   ([remap scroll-down-command] . scrollkeeper-up)
   )
  )
#+end_src

New smooth scrolling in emacs 29, would like to see if I can maybe combine it with scrollkeeper-style highlighting.

#+begin_src emacs-lisp
(use-package pixel-scroll
  :ensure nil
  :if (>= emacs-major-version 29)
  :commands (pixel-scroll-precision-mode)
  :custom
  (pixel-scroll-precision-interpolate-page t)
  (pixel-scroll-precision-interpolation-factor 2.0)
  (pixel-scroll-precision-large-scroll-height 20)
  :init
  (pixel-scroll-precision-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package scroll-on-jump
  :commands (scroll-on-jump
             scroll-on-jump-interactive
             scroll-on-jump-advice-add
             scroll-on-jump-advice-remove)

  :custom
  (scroll-on-jump-duration 0.2)
  (scroll-on-jump-curve 'linear)
  (scroll-on-jump-curve-power 1.0)

  :config
  (with-eval-after-load 'elfeed
    (scroll-on-jump-advice-add elfeed-search-last-entry)
    (scroll-on-jump-advice-add elfeed-search-first-entry)
    )

  (with-eval-after-load 'beginend
    (scroll-on-jump-advice-add beginend-elfeed-search-mode-goto-end)
    (scroll-on-jump-advice-add beginend-elfeed-search-mode-goto-beginning)

    (scroll-on-jump-advice-add beginend-elfeed-show-mode-goto-end)
    (scroll-on-jump-advice-add beginend-elfeed-show-mode-goto-beginning)
    (scroll-on-jump-advice-add beginend-org-mode-goto-end)
    (scroll-on-jump-advice-add beginend-org-mode-goto-beginning)
    )

  (with-eval-after-load 'goto-chg
    (scroll-on-jump-advice-add goto-last-change)
    (scroll-on-jump-advice-add goto-last-change-reverse))

  (with-eval-after-load 'simple
    (scroll-on-jump-advice-add goto-line)))
#+end_src

Finally found a package that lets org tables horizontally scroll while leaving the rest of the text alone.

#+begin_src emacs-lisp
(use-package phscroll
  :ensure (:host github :repo "misohena/phscroll")
  :after org
  :commands (org-phscroll-mode)
  :custom
  ;; (mouse-wheel-tilt-scroll t)
  ;; (mouse-wheel-flip-direction t)
  ;; (mouse-wheel-scroll-amount-horizontal 10)
  (phscroll-mwheel-scroll-amount-horizontal 10)
  :bind
  (:map phscroll-keymap
   ("<wheel-left>" . phscroll-mwheel-scroll-right)
   ("<wheel-right>" . phscroll-mwheel-scroll-left))
  :init
  (setq org-startup-truncated nil)
  :config
  (load "org-phscroll.el"))
#+end_src

* Highlighting

#+begin_src emacs-lisp
(use-package pulse
  :ensure nil
  :defer 0.5
  :custom
  (pulse-flag t)
  :config
  ;; stolen from https://blog.meain.io/2020/emacs-highlight-yanked/
  (defun meain/evil-yank-advice (orig-fn beg end &rest args)
    (pulse-momentary-highlight-region beg end)
    (apply orig-fn beg end args))
  (advice-add 'evil-yank :around 'meain/evil-yank-advice))
#+end_src

#+begin_src emacs-lisp
(use-package pulsar
  :hook (focus-in . pulsar-pulse-line)
  :custom
  (pulsar-delay 0.08)
  :init
  (pulsar-global-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package prism
  :commands (prism-mode
             prism-whitespace-mode)
  :hook
  (yaml-mode . prism-whitespace-mode)
  (yaml-ts-mode . prism-whitespace-mode)
  :config
  (add-to-list 'prism-whitespace-mode-indents '(yaml-mode . yaml-indent-offset)))
#+end_src

#+begin_src emacs-lisp
(use-package highlight-parentheses
  :hook (prog-mode . highlight-parentheses-mode)
  :custom
  (highlight-parentheses-colors '("red2" "DarkOrange1" "goldenrod2" "IndianRed4"))
  (highlight-parentheses-attributes '((:weight ultra-bold)
                                      (:weight ultra-bold)
                                      (:weight ultra-bold)
                                      (:weight ultra-bold))))
#+end_src

#+begin_src emacs-lisp
(use-package hl-todo
  :commands (hl-todo-mode
             global-hl-todo-mode)
  :config
  (global-hl-todo-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package magit-todos
  :config
  (magit-todos-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package hl-line-mode
  :ensure nil
  :commands (hl-line-mode
             global-hl-line-mode))
#+end_src

#+begin_src emacs-lisp
(use-package lin
  :config
  (lin-global-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package hi-lock
  :ensure nil
  ;; :general
  ;; (my/leader-keys
  ;;   :infix "h"
  ;;   "l" #'highlight-lines-matching-regexp
  ;;   "r" #'highlight-regexp
  ;;   "u" #'unhighlight-regexp)
  )
#+end_src

#+begin_src emacs-lisp
(use-package highlight-thing
  :commands (highlight-thing-mode
             global-highlight-thing-mode))
#+end_src

#+begin_src emacs-lisp
(use-package symbol-overlay
  :bind
  (:map symbol-overlay-map
   ("i" . nil)
   ("n" . nil)
   ("p" . nil)
   ("t" . nil)
   ("s" . nil)
   ("h" . nil)

   ("?" . symbol-overlay-map-help)

   ("S" . symbol-overlay-toggle-in-scope)

   ("M-n" . (lambda () (interactive) (symbol-overlay-jump-prev) (recenter)))
   ("M-t" . (lambda () (interactive) (symbol-overlay-jump-next) (recenter)))
   ("M-<up>" . (lambda () (interactive) (symbol-overlay-jump-prev) (recenter)))
   ("M-<down>" . (lambda () (interactive) (symbol-overlay-jump-next) (recenter)))
   ("M-N" . (lambda () (interactive) (symbol-overlay-switch-backward) (recenter)))
   ("M-T" . (lambda () (interactive) (symbol-overlay-switch-forward) (recenter)))

   ("c" . symbol-overlay-put)
   ("C" . symbol-overlay-remove-all))

  ;; (my/leader-keys
  ;;   "hs" #'symbol-overlay-put
  ;;   "hn" #'symbol-overlay-switch-backward
  ;;   "ht" #'symbol-overlay-switch-forward
  ;;   "hc" #'symbol-overlay-remove-all
  ;;   "hM" #'symbol-overlay-mode)
  )
#+end_src

* Languages

#+begin_src emacs-lisp
(use-package jinx
  :hook (text-mode . jinx-mode)
  :custom (jinx-languages "en_CA en_US")
  :bind ([remap ispell-word] . jinx-correct))
#+end_src

#+begin_src emacs-lisp
(use-package jinja2-mode
  :mode (("\\.j2\\'" . jinja2-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (global-treesit-auto-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode (("\\.clj\\'" . clojure-mode)))

(use-package cider
  :commands (cider
             cider-mode
             cider-jack-in))

(use-package ob-clojure
  :ensure nil
  :after org
  :custom
  (org-babel-clojure-backend 'cider)
  :commands
  (org-babel-execute:clojure))
#+end_src

#+begin_src emacs-lisp
(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode))
#+end_src

#+begin_src emacs-lisp
(defun my/python-mode-hook ()
  "My python mode settings."
  (setq-local fill-column 80)
  ;; (auto-virtualenv-set-virtualenv)
  ;; (lsp-deferred)
  )

(use-package python-mode
  :ensure nil
  :hook (python-mode . my/python-mode-hook)
  :custom
  (python-shell-interpreter "python3")
  (org-babel-python-command "python3"))

(use-package pyvenv
  :commands (pyvenv-activate))

(use-package auto-virtualenv
  :commands (auto-virtualenv-set-virtualenv))
#+end_src

#+begin_src emacs-lisp
(use-package comint
  :ensure nil
  :custom
  (comint-scroll-to-bottom-on-input t)
  (comint-scroll-to-bottom-on-output t)
  (comint-move-point-for-output t))
#+end_src

#+begin_src emacs-lisp
(use-package eglot
  :ensure nil
  :config
  (add-to-list 'eglot-server-programs
               '(terraform-mode . ("terraform-ls" "serve"))))
#+end_src

#+begin_src emacs-lisp
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
#+end_src

#+begin_src emacs-lisp
(use-package groovy-mode
  :mode ("Jenkinsfile\\'" . groovy-mode))
#+end_src

#+begin_src emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")

(use-package go-eldoc
  :commands go-eldoc-setup
  :hook (go-mode . go-eldoc-setup))
#+end_src

* Formatters

#+begin_src emacs-lisp
(use-package sqlformat
  :commands (sqlformat
             sqlformat-buffer
             sqlformat-region
             sqlformat-on-save-mode)
  :hook (sql-mode . sqlformat-on-save-mode)
  :custom
  (sqlformat-command 'pgformatter)
  (sqlformat-args '("-f1"
                    "-u1"
                    "--spaces=2")))
#+end_src

#+begin_src emacs-lisp
(use-package apheleia
  :config
  (apheleia-global-mode t))
#+end_src

* Shells

#+begin_src emacs-lisp
(use-package terminal-here
  :commands (terminal-here-launch
             terminal-here-project-launch)
  :custom
  (terminal-here-linux-terminal-command 'alacritty)
  ;; :general
  ;; (my/leader-keys
  ;;   "ot" #'terminal-here-launch
  ;;   "oT" #'terminal-here-project-launch)
  )
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :defer 1
  :commands (vterm
             vterm-other-window)
  :custom
  (vterm-max-scrollback 10000)
  (vterm-always-compile-module t)

  :bind
  (:repeat-map vterm-prompt-repeat-map
   ("p" . vterm-previous-prompt)
   ("n" . vterm-next-prompt))

  :init
  (defun my/vterm-mode-p (buffer-or-name &optional action)
    (with-current-buffer buffer-or-name
      (or (equal major-mode 'vterm-mode)
          (string-prefix-p vterm-buffer-name (if (bufferp buffer-or-name)
                                                 (buffer-name buffer-or-name)
                                               buffer-or-name)))))

  (defun my/vterm-list-buffers ()
    (interactive)
    (seq-filter #'my/vterm-mode-p (buffer-list (current-buffer))))

  ;; would be nice to have more info about vterm buffers in the list... marginalia time?
  (with-eval-after-load 'consult
    (defvar vterm-buffer-source
      `(:name "vterm"
        :hidden t
        :narrow ?v
        :category buffer
        :state    ,#'consult--buffer-state
        :items    ,(lambda () (mapcar #'buffer-name (my/vterm-list-buffers)))))

    (add-to-list 'consult-buffer-sources 'vterm-buffer-source 'append)

    (defun vterm-consult-yank (orig-fun &rest args)
      (if (equal major-mode 'vterm-mode)
          (let ((inhibit-read-only t)
                (yank-undo-function (lambda (_start _end) (vterm-undo))))
            (cl-letf (((symbol-function 'insert-for-yank)
                       (lambda (str) (vterm-send-string str t))))
              (apply orig-fun args)))
        (apply orig-fun args)))

    (advice-add 'consult-yank-from-kill-ring :around #'vterm-consult-yank)
    )
  )
#+end_src

#+begin_src emacs-lisp
(use-package vterm-toggle
  :after vterm
  :defer 2
  :commands (vterm-toggle)

  :custom
  (vterm-toggle-reset-window-configration-after-exit nil)
  (vterm-toggle-hide-method 'bury-all-vterm-buffer)

  :bind
  (:map boon-goto-map
   ("tg" . my/global-vterm-toggle)
   ("tG" . my/global-vterm-toggle-cd)
   ("tp" . my/project-vterm-toggle)
   ("tP" . my/project-vterm-toggle-cd)

   :map vterm-mode-map
   ("C-'" . my/project-vterm-toggle)
   ("C-." . vterm-toggle-insert-cd))

  :init
  (defun my/vterm-toggle-same-window (scope &optional cd)
    (interactive)
    (let ((vterm-toggle-scope scope)
          (display-buffer-alist '((my/vterm-mode-p
                                   (display-buffer-same-window)))))
      (if cd
          (vterm-toggle-cd)
        (vterm-toggle))))

  (defun my/project-vterm-toggle ()
    (interactive)
    (my/vterm-toggle-same-window 'project))

  (defun my/project-vterm-toggle-cd ()
    (interactive)
    (my/vterm-toggle-same-window 'project t))

  (defun my/frame-vterm-toggle ()
    (interactive)
    (my/vterm-toggle-same-window 'frame))

  (defun my/frame-vterm-toggle-cd ()
    (interactive)
    (my/vterm-toggle-same-window 'frame t))

  (defun my/global-vterm-toggle ()
    (interactive)
    (my/vterm-toggle-same-window 'dedicated))

  (defun my/global-vterm-toggle-cd ()
    (interactive)
    (my/vterm-toggle-same-window 'dedicated t))
  )
#+end_src

#+begin_src emacs-lisp
(use-package eshell
  :ensure nil
  :custom
  (eshell-scroll-to-bottom-on-input 'this)
  (eshell-error-if-no-glob t)
  (eshell-hist-ignoredups t)
  (eshell-save-history-on-exit t)
  (eshell-destroy-buffer-when-process-dies t)
  (eshell-banner-message "")
  (eshell-prompt-function
   (lambda ()
     (concat (abbreviate-file-name (eshell/pwd))
             (if (= (user-uid) 0) " # " "  "))))
  (eshell-prompt-regexp "^[^#$\n]* [#] ")

  :hook (eshell-mode . my/eshell-mode-hook)

  :bind
  (:map eshell-mode-map
   ("C-r" . consult-history)
   :repeat-map eshell-prompt-repeat-map
   ("p" . eshell-previous-prompt)
   ("n" . eshell-next-prompt))

  :init
  (defun my/eshell-mode-hook ()
    (add-to-list 'eshell-visual-commands "htop")
    (add-to-list 'eshell-visual-commands "tail")
    (add-to-list 'eshell-visual-commands "ssh")

    (add-to-list 'eshell-modules-list 'eshell-tramp)

    (setq-local imenu-generic-expression '(("Prompt" "^[^#$\n]* [#] \\(.*\\)$" 1)))

    (eshell/alias "ll" "ls -l")
    (eshell/alias "la" "ls -al")
    (eshell/alias "ff" "find-file $1"))

  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  ;; from https://karthinks.com/software/jumping-directories-in-eshell/
  (defun eshell/z (&optional regexp)
    "Navigate to a previously visited directory in eshell, or to
any directory proferred by `consult-dir'."
    (let ((eshell-dirs (delete-dups
                        (mapcar 'abbreviate-file-name
                                (ring-elements eshell-last-dir-ring)))))
      (cond
       ((and (not regexp) (featurep 'consult-dir))
        (let* ((consult-dir--source-eshell `(:name "Eshell"
                                             :narrow ?e
                                             :category file
                                             :face consult-file
                                             :items ,eshell-dirs))
               (consult-dir-sources (cons consult-dir--source-eshell
                                          consult-dir-sources)))
          (eshell/cd (substring-no-properties
                      (consult-dir--pick "Switch directory: ")))))
       (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                       (completing-read "cd: " eshell-dirs)))))))
  )
#+end_src

#+begin_src emacs-lisp
(use-package eshell-prompt-extras
  :disabled t
  :init
  (defun epe-theme-my ()
    ""
    (setq eshell-prompt-regexp "^[^#\n]*[#]* ")

    (concat
     "\n"
     (if (epe-remote-p)
         (progn
           (concat
            (epe-colorize-with-face "─ " 'epe-my-delimiter-face)
            (epe-colorize-with-face (epe-remote-user) 'epe-my-user-face)
            (epe-colorize-with-face "@" 'epe-my-delimiter-face)
            (epe-colorize-with-face (epe-remote-host) 'epe-my-host-face)
            ""))
       (progn
         (when (not (string= user-login-name "nathan"))
           (concat
            (epe-colorize-with-face "─ " 'epe-my-delimiter-face)
            (epe-colorize-with-face (user-login-name) 'epe-my-user-face)
            (epe-colorize-with-face (system-name) 'epe-my-host-face)
            " "))))

     (concat
      (epe-colorize-with-face "─ " 'epe-my-delimiter-face)
      (epe-colorize-with-face (concat (eshell/pwd)) 'epe-dir-face)
      " "

      (when (epe-git-p)
        (concat
         (epe-colorize-with-face "─ " 'epe-my-delimiter-face)
         (epe-colorize-with-face " " 'epe-git-face)
         (epe-colorize-with-face
          (concat (epe-git-branch)
                  (epe-git-dirty)
                  (epe-git-untracked)
                  (let ((unpushed (epe-git-unpushed-number)))
                    (unless (= unpushed 0)
                      (concat ":" (number-to-string unpushed)))))
          'epe-git-face)))

      (epe-colorize-with-face  "\n" 'epe-my-delimiter-face))

     (when (> 0 eshell-last-command-status)
       (epe-colorize-with-face eshell-last-command-status 'epe-symbol-face))

     (when (and epe-show-python-info (bound-and-true-p venv-current-name))
       (epe-colorize-with-face (concat "(" venv-current-name ") ") 'epe-venv-face))

     (epe-colorize-with-face "" 'epe-symbol-face)
     (epe-colorize-with-face (if (= (user-uid) 0) "#" "") 'epe-sudo-symbol-face)

     " "))

  :custom-face
  (epe-my-delimiter-face ((t (:inherit 'shadow))))
  (epe-my-user-face ((t (:inherit 'default))))
  (epe-my-host-face ((t (:inherit 'default))))

  :custom
  (epe-show-python-info t)
  (epe-git-dirty-char "*")
  (epe-git-untracked-char "?")
  (epe-git-detached-HEAD-char "D:")
  (epe-path-style 'fish)
  (eshell-prompt-function 'epe-theme-my))
#+end_src

#+begin_src emacs-lisp
(use-package eshell-syntax-highlighting
  :commands (eshell-syntax-highlighting-mode
             eshell-syntax-highlighting-global-mode)
  :config
  (eshell-syntax-highlighting-global-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package eat
  :commands (eat)
  :hook ((eshell-load . eat-eshell-mode)
         (eshell-load . eat-eshell-visual-command-mode))
  )
#+end_src

#+begin_src emacs-lisp
(use-package sticky-shell
  :commands (sticky-shell-mode
             sticky-shell-global-mode))
#+end_src

#+begin_src emacs-lisp
(use-package fish-mode
  :commands (fish-mode))
#+end_src

* Dired

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :hook ((dired-mode . dired-hide-details-mode)
         (dired-mode . dired-async-mode))
  :commands (dired-jump
             dired-mode)

  :custom
  (dired-create-destination-dirs 'ask)
  (dired-listing-switches "-alhv")
  (dired-recursive-copies 'always)
  (dired-dwim-target t)
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-use-ls-dired t)
  (dired-async-large-file-warning-threshold 10000000000)

  :bind
  (:map boon-goto-map
   ;; ("jxx" . my/dired-open)
   ("d" . dired-jump))

  :init
  (defun my/dired-copy-full-path ()
    "Copy full path of entries that are marked or at point."
    (interactive)
    (let ((current-prefix-arg 0))
      (call-interactively #'dired-copy-filename-as-kill)))

  (defun my/dired-copy-full-path-shell-quoted ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (kill-new (shell-quote-argument (my/dired-copy-full-path))))


  (defun my/dired-copy-full-path-quoted ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (my/copy-file-path nil nil t))

  (defun my/dired-copy-full-path-quoted-list ()
    "Copy quoted full path of entries that are marked or at point."
    (interactive)
    (my/copy-file-path nil "\n" t))

  (defun my/copy-file-path (&optional @dir-path-only-p separator shell-quote-p)
    "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.

If in dired, copy the file/dir cursor is on, or marked files.

If a buffer is not file and not dired, copy value of `default-directory' (which is usually the “current” dir when that buffer was created)

URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2017-09-01"
    (interactive "P")
    (fset 'quote-or-not (if shell-quote-p
                            'shell-quote-argument
                          'identity))
    (let* ((separator (or separator " "))
           ($fpath
           (if (string-equal major-mode 'dired-mode)
               (progn
                 (let (($result (mapconcat 'quote-or-not (dired-get-marked-files) separator)))
                   (if (equal (length $result) 0)
                       (progn default-directory )
                     (progn $result))))
             (if (buffer-file-name)
                 (buffer-file-name)
               (expand-file-name default-directory)))))
      (kill-new
       (if @dir-path-only-p
           (progn
             (message "Directory path copied: 「%s」" (file-name-directory $fpath))
             (file-name-directory $fpath))
         (progn
           (message "File path copied: 「%s」" $fpath)
           $fpath )))))

  (setq dired-deletion-confirmer 'y-or-n-p
        dired-guess-shell-alist-user '(("\\.rar\\'" "unrar x" "unrar e")
                                       ("" "xdg-open")))

  (defvar my-dired-new-file-first-dirs
    '("Downloads?/$")
    "Dired directory patterns where newest files are on the top.")

  (defun my-dired-mode-hook-setup ()
    "Set up Dired."
    (when (cl-find-if (lambda (regexp)
                        (let ((case-fold-search t))
                          (string-match regexp default-directory)))
                      my-dired-new-file-first-dirs)
      (setq dired-actual-switches "-lahvt")))
  (add-hook 'dired-mode-hook 'my-dired-mode-hook-setup))
#+end_src

#+begin_src emacs-lisp
(use-package ls-lisp
  :ensure nil
  :custom
  (ls-lisp-ignore-case t)
  (ls-lisp-use-insert-directory-program nil))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-hydras
(major-mode-hydra-define dired-mode
  (:color amaranth :quit-key ("q" "<escape>"))
  ("Show"
   (("d" dired-hide-details-mode "hide details" :toggle t)
    ("g" dired-git-info-mode "git info" :toggle t)
    ("u" dired-du-mode "usage" :toggle t)
    ("cl" dired-collapse-mode "collapse" :toggle t)
    ("cp" my/dired-copy-full-path "copy path" :exit t)
    ("cP" my/dired-copy-full-path-quoted "copy \"path\"" :exit t)
    )
   "Filter"
   (("p" dired-filter-pop "pop")
    ;;TODO ("a" (lambda () (interactive) (counsel-M-x "dired-filter-by-")) "add")
    ("n" dired-narrow-fuzzy "fuzzy narrow")
    ("r" revert-buffer "revert"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-hydras
(major-mode-hydra-define markdown-mode
  (:color amaranth :quit-key ("q" "<escape>"))
  ("View"
   (("v" markdown-view-mode "view mode" :exit t)
    ("g" gfm-view-mode "gfm view mode" :exit t)
    ("p" markdown-preview "preview in browser")
    )
   )
  )
#+end_src

#+begin_src emacs-lisp
(use-package dired-imenu
  :after dired)
#+end_src

#+begin_src emacs-lisp
(use-package dired-git-info
  :commands (dired-git-info-mode))
#+end_src

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :commands (dired-subtree-toggle
             dired-subtree-cycle)
  :hook (after-load-theme . my/set-dired-subtree-background)

  :bind
  (:map dired-mode-map
   ("<tab>" . dired-subtree-toggle))

  :init
  (defun my/set-dired-subtree-background ()
    (if (featurep 'dired-subtree)
        (let* ((bg (face-background 'default))
               (lighten-or-darken (if (my/dark-p)
                                      #'color-lighten-name
                                    #'color-darken-name))
               (even (funcall lighten-or-darken bg 6))
               (odd (funcall lighten-or-darken bg 3)))
          (set-face-attribute 'dired-subtree-depth-1-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-2-face nil :background even :extend t)
          (set-face-attribute 'dired-subtree-depth-3-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-4-face nil :background even :extend t)
          (set-face-attribute 'dired-subtree-depth-5-face nil :background odd :extend t)
          (set-face-attribute 'dired-subtree-depth-6-face nil :background even :extend t))))

  :config
  (my/set-dired-subtree-background))
#+end_src

This seems useful, especially in combination with =dired-subtree=, as then it's active in the buffer as you view sub-trees.

#+begin_src emacs-lisp
(use-package dired-collapse
  :hook (dired-mode . dired-collapse-mode))
#+end_src

Handy live filtering of dired buffers.

#+begin_src emacs-lisp
(use-package dired-narrow
  :commands (dired-narrow
             dired-narrow-regexp
             dired-narrow-fuzzy))
#+end_src

Nice dired filtering, plus it replaces =dired-omit-mode=.

#+begin_src emacs-lisp
(use-package dired-filter
  :hook ((dired-mode . dired-filter-mode)
         (dired-filter-mode . dired-filter-by-dot-files)))
#+end_src

#+begin_src emacs-lisp
(use-package dired-du
  :commands (dired-du-mode)
  :custom
  (dired-du-size-format t))
#+end_src

#+begin_src emacs-lisp
(use-package dired-open-with
  :commands (dired-open-with))
#+end_src

* Hydra

#+begin_src emacs-lisp :noweb yes
(use-package posframe
  :commands (posframe-show)
  :config
  (defun posframe-poshandler-frame-bottom-center (info)
    "Posframe's position handler.

    Get a position which let posframe stay onto its parent-frame's
    bottom center.  The structure of INFO can be found
    in docstring of `posframe-show'."
    (cons (/ (- (plist-get info :parent-frame-width)
                (plist-get info :posframe-width))
             2)
          (- 0
             (plist-get info :mode-line-height)
             (plist-get info :minibuffer-height))))

  (defun posframe-poshandler-window-bottom-center (info)
    "Posframe's position handler.

    Get a position which let posframe stay onto current window's
    center.  The structure of INFO can be found in docstring
    of `posframe-show'."
    (let* ((window-left (plist-get info :parent-window-left))
           (window-top (plist-get info :parent-window-top))
           (window-width (plist-get info :parent-window-width))
           (window-height (plist-get info :parent-window-height))
           (mode-line-height (plist-get info :mode-line-height))
           (posframe-width (plist-get info :posframe-width))
           (posframe-height (plist-get info :posframe-height)))
      (cons (+ window-left (/ (- window-width posframe-width) 2))
            (- (+ window-top window-height) (+ posframe-height mode-line-height 15))))))
#+end_src

#+begin_src emacs-lisp :noweb yes
(use-package hydra
  ;; :general
  ;; (my/leader-keys
  ;;   "rc" #'hydra-codereading/body
  ;;   "rg" #'hydra-git-gutter/body
  ;;   "ro" #'hydra-org/body
  ;;   "rr" #'hydra-reading/body)

  :custom
  (hydra-hint-display-type 'lv)

  :init
  (setq hydra--work-around-dedicated nil)
  (setq hydra-posframe-show-params '(:internal-border-width 10
                                     :internal-border-color "grey21"
                                     ;; :min-height 15
                                     :poshandler posframe-poshandler-point-bottom-left-corner))

  :config
  <<hydra-hydras>>

  (use-package hydra-posframe
    :disabled
    :ensure (hydra-posframe
               :host github
               :repo "Ladicle/hydra-posframe")

    :commands (hydra-posframe-enable)

    :config
    (setq hydra-posframe-show-params '(:internal-border-width 2
                                       :internal-border-color "green"
                                       ;; :min-height 15
                                       :poshandler posframe-poshandler-point-bottom-left-corner))

    (hydra-posframe-enable))
  )
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
;; (defhydra hydra-reading (:color red
;;                          :hint nil)
;;   "
;;   _N_ pg up         _gg_ go to top        _zt_ line to top
;;   _n_ ½ pg up       _G_  go to bottom     _zz_ line to center
;;   _t_ ½ pg dn       ^ ^                   _zb_ line to bottom
;;   _T_ pg dn

;; "
;; ("n" (evil-scroll-up 0))
;; ("t" (evil-scroll-down 0))
;; ("T" (scroll-up))
;; ("N" (scroll-down))

;; ("gg" evil-goto-first-line)
;; ("G" evil-goto-line)

;; ("zt" (evil-scroll-line-to-top (line-number-at-pos)))
;; ("zz" (evil-scroll-line-to-center (line-number-at-pos)))
;; ("zb" (evil-scroll-line-to-bottom (line-number-at-pos)))

;; ("+" (my/adjust-text-height 7) "bigger")
;; ("-" (my/adjust-text-height -7) "smaller")
;; ("0" (my/adjust-text-height 0) "reset")
;; ("q" nil "quit"))
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1))
  "Browse/stage/revert git hunks"
  ;; ("n" (progn (git-gutter:previous-hunk 1)
  ;;             (evil-scroll-line-to-center (line-number-at-pos))) "previous hunk")
  ;; ("t" (progn (git-gutter:next-hunk 1)
  ;;             (evil-scroll-line-to-center (line-number-at-pos))) "next hunk")
  ("H" (progn (goto-char (point-min))
              (git-gutter:next-hunk 1)) "first hunk")
  ("S" (progn (goto-char (point-min))
              (git-gutter:previous-hunk 1)) "last hunk")
  ("c" magit-commit "commit" :exit t)
  ("s" git-gutter:stage-hunk "stage hunk")
  ("k" git-gutter:revert-hunk "revert hunk")
  ("q" nil "quit" :color blue))
#+end_src

#+begin_src emacs-lisp :noweb-ref hydra-hydras :tangle no
(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("t" outline-next-visible-heading "next heading")
  ("n" outline-previous-visible-heading "prev heading")
  ("T" org-forward-heading-same-level "next heading at same level")
  ("N" org-backward-heading-same-level "prev heading at same level")
  ("H" outline-up-heading "up heading")
  ("<tab>" org-cycle "cycle")
  ("g" org-goto "goto" :exit t)
  ("q" nil "quit" :color blue))
#+end_src

=Pretty-hydra= comes from the =major-mode-hydra= package, but I’m using it separately to define various hydras as I begin to use them more. Each hydra is broken out below.

#+begin_src emacs-lisp :noweb yes
(use-package pretty-hydra
  :after hydra
  :commands (pretty-hydra-define)
  :bind
  (:map mode-specific-map
   ("," . my/toggles/body)
   ;; "'" #'my/movement/body
   ;; "G" 'hydra-git/body
   ;; "rR" 'my/reading/body
   )

  :config
  <<pretty-hydras>>
  )
#+end_src

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-go (:hint nil
                               :quit-key "q")

  ("open" (("p" project-switch-project "project" :exit t)
           ("t" org-roam-dailies-goto-today "today's note" :exit t)
           ("o" consult-buffer "buffer" :exit t)
           ("b" ibuffer "ibuffer" :exit t)
           ("e" execute-extended-command "command" :exit t)
           ("n" org-roam-node-find "notes" :exit t)
           ("a" my/agenda-current-window "agenda" :exit t)
           ("c" my/capture-full-frame "capture" :exit t)
           ("f" find-file "file" :exit t))

   "search" (("N" my/roam-rg "notes" :exit t)
             ("F" consult-find "files" :exit t)
             ("A" consult-org-agenda "agenda" :exit t)
             ("5" hydra-5e/body "5e" :exit t))
   ))
#+end_src

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-5e (:hint nil
                               :quit-key "q")

  ("open" (("p" project-switch-project "project" :exit t)
           ("o" consult-buffer "buffer" :exit t)
           ("f" find-file "file" :exit t))

   "search" (("N" my/roam-rg "notes" :exit t)
             ("F" consult-find "files" :exit t)
             ("A" consult-org-agenda "agenda" :exit t))
   ))
#+end_src

Browser/link handling hydra.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-browse (:hint nil
                                   :quit-key "q")

  ("browse" (("f" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (browse-url-at-point))) " firefox" :exit t)
             ("o" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (org-open-at-point))) " org firefox" :exit t)
             ("F" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-firefox))
                      (browse-url-at-point t))) " firefox (new window)" :exit t)
             ("c" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-chromium))
                      (browse-url-at-point))) " chromium" :exit t)
             ("d" (lambda ()
                    (interactive)
                    (let ((browse-url-browser-function 'browse-url-default-browser))
                      (browse-url-at-point))) " default" :exit t))
   ))
#+end_src

Working on a =git= hydra to replace all or most of my usual git keybinds. This is an experiment to see whether I want to use a lot more hydras.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define hydra-git (:hint nil
                                :quit-key "q"
                                :body-pre (git-gutter-mode 1))

  ("go" (("gg" (progn (goto-char (point-min))
                      (git-gutter:next-hunk 1)) "first hunk")
         ;; ("n" (progn (git-gutter:previous-hunk 1)
         ;;             (evil-scroll-line-to-center (line-number-at-pos))) "previous hunk")
         ;; ("t" (progn (git-gutter:next-hunk 1)
         ;;             (evil-scroll-line-to-center (line-number-at-pos))) "next hunk")
         ("G" (progn (goto-char (point-min))
                     (git-gutter:previous-hunk 1)) "last hunk"))

   "do" (("s" git-gutter:stage-hunk "stage")
         ("k" git-gutter:revert-hunk "revert hunk")
         ("c" magit-commit "commit" :exit t)
         ("P" magit-push "push" :exit t))

   "see" (("S" magit-status "status" :exit t)
          ("l" magit-log-buffer-file "log" :exit t)
          ("L" magit-log "log (menu)" :exit t))
   ))
#+end_src

Another work-in-progress hydra, this one for a general reading/browsing set of commands. Not sure exactly what it will be yet.

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(pretty-hydra-define my/reading (:hint nil
                                  :foreign-keys warn
                                  :quit-key "q")
  ("move up/down" (("N" scroll-down "pg up")
                   ("T" scroll-up "pg down"))

   "text size" (("+" (my/adjust-text-height 7) "bigger")
                ("-" (my/adjust-text-height -7) "smaller")
                ("0" (my/adjust-text-height 0) "reset"))
   ))
#+end_src

#+begin_src emacs-lisp :noweb-ref pretty-hydras :tangle no
(defun my/set-frame-width (multiple)
  "Sets frame width to MULTIPLE of FILL-COLUMN."
  (interactive)
  (message "%s %i" "setting frame width to " (+ (* multiple fill-column) 2))
  (set-frame-parameter
   nil
   'width
   (* multiple fill-column))
  ;; (modify-frame-parameters
  ;;  nil
  ;;  '((width . (+ (* multiple fill-column) 2))))
  (message "%s %i" "frame width is " (frame-parameter nil 'width))
  (message "%s %i" "fill-column is " fill-column))

(pretty-hydra-define my/toggles
  (:color amaranth
   :quit-key ("q" "<escape>")
   :title (format "  Options"))

  ("Formatting"
   (("vl" global-visual-line-mode "visual lines" :toggle t)
    ("vf" visual-line-fill-column-mode "visual fill" :toggle t)
    ("w" whitespace-mode "whitespace" :toggle t)
    ("c" rainbow-mode "colours" :toggle t)
    ("t" toggle-truncate-lines "truncate lines" :toggle truncate-lines)
    ("d" rainbow-delimiters-mode "delimiters" :toggle t)
    ("TAB" my/indent-region-or-block-or-buffer "indent" :exit t)
    ("fa" auto-fill-mode "auto-fill" :toggle t)
    ("fp" fill-paragraph "fill paragraph" :exit t)
    ("fr" fill-region "fill region" :exit t))
   "UI"
   (("l" global-hl-line-mode "highlight line" :toggle t)
    ("b" toggle-frame-tab-bar "toggle tab bar" :exit t)
    ("B" (my/customize-this "tab-bar-show") "tab bar" :exit t)
    ("k" my/toggle-dark-mode "dark mode" :toggle my/dark-mode :exit t)
    ("T" (my/customize-this "my/themeset") "themeset" :exit t)
    ("D" auto-dim-other-buffers-mode "dimmer" :toggle t)
    ("O" olivetti-mode "olivetti" :toggle t)
    ("W" writeroom-mode "writeroom" :toggle t)
    ("+" (my/adjust-text-height 7) "bigger text")
    ("-" (my/adjust-text-height -7) "smaller text")
    ("0" (my/adjust-text-height 0) "reset text size")
    ("vc" hide-cursor-mode "cursor" :toggle t))
   "Window"
   (("1" (my/set-frame-width 1) "single width")
    ;; ("z" (my/set-frame-width 2) "double width")
    ("2" (set-frame-width nil (* fill-column 2)) "double width")
    ("3" (my/set-frame-width 3) "triple width"))))

(pretty-hydra-define my/movement
  (:color amaranth
   :quit-key ("q" "<escape>")
   :title (format "  Movement"))
  ("Move Buffer"
   (("H" buf-move-left "left")
    ("T" buf-move-down "down")
    ("N" buf-move-up "up")
    ("S" buf-move-right "right"))
   "Move to Window"
   (("h" windmove-left "left")
    ("t" windmove-down "down")
    ("n" windmove-up "up")
    ("s" windmove-right "right"))
   "Split Window"
   (("=" balance-windows "balance")
    ("o" delete-other-windows "delete others"))
   "Close"
   (("x" bury-buffer "bury buffer")
    ("X" kill-current-buffer "delete buffer")
    )
   ))
#+end_src

Not using this one yet, but will allow associating a hydra to any major mode to provide common commands.

#+begin_src emacs-lisp :noweb yes
(use-package major-mode-hydra
  :bind
  (:map mode-specific-map
   ("." . major-mode-hydra))

  :config
  (major-mode-hydra-define emacs-lisp-mode
    (:color amaranth :quit-key ("q" "<escape>"))
    ("Eval"
     (("b" eval-buffer "buffer" :exit t)
      ("e" eval-defun "defun")
      ("r" eval-region "region"))
     "REPL"
     (("I" ielm "ielm"))
     "Doc"
     (("d" describe-foo-at-point "thing-at-pt")
      ("f" describe-function "function")
      ("v" describe-variable "variable"))))
  <<major-mode-hydras>>
  )
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref major-mode-hydras
(major-mode-hydra-define org-mode
  (:color amaranth :quit-key ("q" "<escape>"))
  ("Show"
   (("e" my/toggle-local-emphasis-markers "emphasis" :toggle t)
    ("E" org-appear-mode "appear" :toggle t)
    ("H" org-sticky-header-mode "header" :toggle t)
    ("L" literate-calc-minor-mode "literate calc" :toggle t)
    ("l" org-toggle-link-display "links" :toggle t)
    ("i" org-toggle-inline-images "images" :toggle t)
    ("t" svg-tag-mode "svg tags" :toggle t)
    )
  ))
#+end_src

* Reading and Note-taking

First, set up =pdf-tools= for nice PDF handling.

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :hook ((pdf-view-mode . (lambda () (blink-cursor-mode -1)))
         (pdf-view-mode . my/pdf-dark-maybe))

  :init
  (defun my/pdf-dark-maybe ()
    (when (my/dark-p)
      pdf-view-themed-minor-mode))

  :custom
  (pdf-view-midnight-colors '("#f8f8f2" . "#282a36"))
  (pdf-view-display-size 'fit-page))
#+end_src

#+begin_src emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :hook
  (pdf-view-mode . pdf-view-restore-mode)
  :custom
  (pdf-view-restore-filename (expand-file-name "pdf-view-history" user-emacs-directory)))
#+end_src

PDF link handling in =org-mode=.

#+begin_src emacs-lisp
(use-package org-pdftools
  :hook (org-load . org-pdftools-setup-link))
#+end_src

Add =nov.el= for =epub=s.

#+begin_src emacs-lisp 
(use-package nov
  :mode (("\\.epub\\'" . nov-mode)))
#+end_src

Try out =org-noter=.

#+begin_src emacs-lisp
(use-package org-noter
  :commands (org-noter)
  :config
  (org-noter-set-auto-save-last-location t))
#+end_src

* Gaming

#+begin_src emacs-lisp
(use-package org-d20
  :commands (org-d20-mode)
  :init
  (put 'org-d20-party 'safe-local-variable
       (lambda (x) (listp x))))
#+end_src

#+begin_src emacs-lisp
(use-package random-table
  :ensure (:host github :repo "jeremyf/random-table.el")
  :commands (random-table/roll
             random-table/register))
#+end_src

* Web

#+begin_src emacs-lisp
(use-package shr
  :ensure nil
  :custom-face
  (shr-text ((t (:inherit 'variable-pitch)))))
#+end_src

#+begin_src emacs-lisp
(use-package shrface
  ;; this breaks link recognition in eww/elfeed somehow
  :disabled t
  :commands (shrface-mode)
  :hook ((eww-after-render . shrface-mode))
  :custom
  (shrface-bullets-bullet-list org-modern-star)
  :config
  (shrface-basic))
#+end_src

#+begin_src emacs-lisp
(use-package org-chef
  :commands (org-chef-insert-recipe
             org-chef-get-recipe-from-url))
#+end_src

* Feeds

#+begin_src emacs-lisp
(use-package elfeed
  :commands (elfeed)
  :bind
  (:map elfeed-show-mode-map
   ("I". my/elfeed-show-hide-images)
   ("U" . my/elfeed-mark-unread-and-exit))

  :config
  (defun my/elfeed-show-hide-images ()
    "Toggle showing images in elfeed articles."
    (interactive)
    (setq-local shr-inhibit-images
                (if (bound-and-true-p shr-inhibit-images) nil t))
    (elfeed-show-refresh))

  (defun my/elfeed-mark-unread-and-exit ()
    "Add unread tag and exit entry."
    (interactive)
    (elfeed-show-tag--unread)
    (elfeed-kill-buffer))


  (defvar my/elfeed-last-update-time nil
    "Last time elfeed-update ran.")
  (defvar my/elfeed-idle-update-timer nil
    "Timer object for elfeed idle updates.")
  (defcustom my/elfeed-idle-update-interval 3600
    "Run elfeed-update this long after the last time.")
  (defcustom my/elfeed-idle-update-idle-time 60
    "Emacs should be idle for this long before running elfeed-update.")

  (defun my/elfeed-idle-save-last-update-time ()
    (setq my/elfeed-last-update-time (current-time)))
  (advice-add #'elfeed-update :after #'my/elfeed-idle-save-last-update-time)

  (defun my/elfeed-idle-update-elfeed-active-p ()
    (or (get-buffer-window "*elfeed-search*" t)
        (get-buffer "*elfeed-entry*")))

  (defun my/elfeed-idle-update ()
    (let* ((now (current-time))
           (elfeed-inactive (not (my/elfeed-idle-update-elfeed-active-p)))
           (idle (>= (time-convert (current-idle-time) 'integer) my/elfeed-idle-update-idle-time))
           (since-last-update (time-convert (time-subtract now
                                                           my/elfeed-last-update-time)
                                            'integer))
           (long-enough (or (not my/elfeed-last-update-time)
                            (>= since-last-update my/elfeed-idle-update-interval)))
           )
      (when (and (daemonp) elfeed-inactive idle long-enough)
        (progn
          (message "%s Updating feeds" (format-time-string "%F %T" now))
          (elfeed-update)
          ))))

  (defun my/elfeed-idle-update-custom-toggle (sym value)
    (if (and (daemonp) value)
        (progn (unless (timerp my/elfeed-idle-update-timer)
                 (setq my/elfeed-idle-update-timer (run-with-timer 30 60 #'my/elfeed-idle-update)))
               (setq my/elfeed-idle-update-enabled t))
      (when (timerp my/elfeed-idle-update-timer)
        (cancel-timer my/elfeed-idle-update-timer)
        (setq my/elfeed-idle-update-timer nil
              my/elfeed-idle-update-enabled nil))))

  (defcustom my/elfeed-idle-update-enabled nil
    "Enable or disable automatic idle updates for elfeed."
    :type 'boolean
    :set 'my/elfeed-idle-update-custom-toggle
    :initialize 'custom-initialize-set)

  ;; doesn't work on startup, the -enabled var isn't defined on start
  ;; I need to actually learn how customs work
  (defun my/elfeed-idle-update-toggle ()
    (interactive)
    (if my/elfeed-idle-update-enabled
        (customize-set-variable 'my/elfeed-idle-update-enabled nil)
      (customize-set-variable 'my/elfeed-idle-update-enabled t)))
  )

(use-package elfeed-org
  :after (elfeed
          org)
  :commands (elfeed-org)
  :custom
  (rmh-elfeed-org-files `(,(concat org-directory "/feeds.org")))
  :init
  (elfeed-org))
#+end_src

* Email

#+begin_src emacs-lisp
(use-package notmuch
  :ensure nil
  :commands (notmuch)
  :custom
  (notmuch-show-logo nil)
  )

;; doesn't exist any more maybe?
;; (use-package org-notmuch)
#+end_src

* Chat

#+begin_src emacs-lisp
(use-package ement
  :commands (ement-connect)
  :custom
  (ement-save-sessions t)
  (ement-room-prism t)
  (ement-room-prism-message-desaturation 25)
  (ement-room-prism-minimum-contrast 6)
  (ement-room-sender-in-left-margin nil)
  (ement-room-message-format-spec "%B%r%R%t")
  (ement-notify-notification-predicates
   '(ement-notify--event-mentions-session-user-p
     ement-notify--event-mentions-room-p
     ement-notify--room-unread-p)))
#+end_src

#+begin_src emacs-lisp
(use-package mastodon
  :custom
  (mastodon-instance-url "https://hachyderm.io")
  (mastodon-active-user "neh")

  (mastodon-tl--highlight-current-toot t)
  (mastodon-tl--enable-proportional-fonts t)
  (mastodon-tl--show-avatars t)
  (mastodon-media--preview-max-height 500)
  (mastodon-media--avatar-height 50))
#+end_src

* Misc packages

#+begin_src emacs-lisp
(use-package casual
  :after (transient)
  :commands (casual-agenda-tmenu
             casual-bookmarks-tmenu
             casual-calc-tmenu
             casual-calendar-tmenu
             casual-dired-tmenu
             casual-ibuffer-tmenu
             casual-info-tmenu
             casual-isearch-tmenu
             casual-rebuilder-tmenu))
#+end_src

#+begin_src emacs-lisp
(use-package casual-avy
  :after (transient
          casual)
  :commands (casual-avy-tmenu))
#+end_src

#+begin_src emacs-lisp
(use-package xkb-mode)
#+end_src

#+begin_src emacs-lisp
(use-package chezmoi
  :commands (chezmoi-find
             chezmoi-write))
#+end_src

#+begin_src emacs-lisp
(use-package sops
  :commands (sops-mode
             global-sops-mode))
#+end_src

#+begin_src emacs-lisp
(use-package goggles
  :hook ((prog-mode text-mode) . goggles-mode)
  :commands (goggles-mode))
#+end_src

#+begin_src emacs-lisp
(use-package tab-jump-out
  :config
  (tab-jump-out-global-mode t))
#+end_src

I missed easy jumping to matching pairs (quotes, parentheses, etc.) from evil, it turns out you can just use evil-matchit on its own.
TODO see if I want to bind any more functions from it

#+begin_src emacs-lisp
(use-package evil-matchit
  :commands (evil-matchit-mode
             global-evil-matchit-mode
             evilmi-jump-items-native)
  :config
  (global-evil-matchit-mode t))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref meow-config
(meow-normal-define-key '("%" . evilmi-jump-items-native))
#+end_src

#+begin_src emacs-lisp
(use-package string-inflection
  :commands (string-inflection-all-cycle)
  :bind
  ("C-_" . string-inflection-all-cycle)
  (:map embark-identifier-map
   ("_" . string-inflection-all-cycle))
  :config
  (add-to-list 'embark-repeat-actions #'string-inflection-all-cycle))
#+end_src
#+end_src

#+begin_src emacs-lisp
(use-package whitespace
  :ensure nil
  :commands (whitespace-mode)
  :custom
  (whitespace-line-column 80)
  (whitespace-style '(face trailing tabs lines-tail)))
#+end_src

#+begin_src emacs-lisp
(use-package ws-butler
  :hook (prog-mode . ws-butler-mode))
#+end_src

#+begin_src emacs-lisp
(use-package embrace
  :commands (embrace-change
             embrace-delete
             embrace-add
             embrace-commander)
  :hook (org-mode . embrace-org-mode-hook)
  :bind
  ("C-'" . embrace-commander))
#+end_src

#+begin_src emacs-lisp
(use-package etrace
  :ensure (:host github :repo "aspiers/etrace")
  :commands (etrace-clear
             etrace-write))
#+end_src

Device tree is the format used by ZMK keyboard firmware.

#+begin_src emacs-lisp
(use-package dts-mode
  :commands (dts-mode))
#+end_src

#+begin_src emacs-lisp
(use-package hammy
  :commands (hammy-start
             hammy-start-org-clock-in
             hammy-define
             hammy-mode)
  :config
  (hammy-define (propertize "🍅" 'face '(:foreground "tomato"))
    :documentation "The classic pomodoro timer."
    :intervals
    (list
     (interval :name "🔨"
               :duration "25 minutes"
               :before (do (announce "Starting work time.")
                           (notify "Starting work time."))
               :advance (do (announce "Break time!")
                            (notify "Break time!")))
     (interval :name "🎉"
               :duration (do (if (and (not (zerop cycles))
                                      (zerop (mod cycles 3)))
                                 ;; If a multiple of three cycles have
                                 ;; elapsed, the fourth work period was
                                 ;; just completed, so take a longer break.
                                 "30 minutes"
                               "5 minutes"))
               :before (do (announce "Starting break time.")
                           (notify "Starting break time."))
               :advance (do (announce "Break time is over!")
                            (notify "Break time is over!"))))))
#+end_src

#+begin_src emacs-lisp
(use-package age
  :demand t
  :custom
  (age-program "rage")
  (age-default-identity "~/.ssh/age_identities")
  (age-default-recipient "~/.ssh/age_recipients")
  :config
  (age-file-enable)
  (add-to-list 'auth-sources "~/.authinfo.age"))
#+end_src

#+begin_src emacs-lisp
(use-package nerd-icons)

(use-package nerd-icons-completion
  :after nerd-icons
  :config
  (nerd-icons-completion-mode))
#+end_src

Large remote directories (at least over ssh) are /really/ slow to load icons, so I'm doing the easy thing for now and only enabling nerd-icons in dired for local directories.

#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :after nerd-icons
  :hook (dired-mode . my/nerd-icons-dired-dwim)
  :init
  (defun my/nerd-icons-dired-dwim ()
    (if (not (file-remote-p dired-directory))
        (nerd-icons-dired-mode))))
#+end_src

#+begin_src emacs-lisp
(use-package powershell
  :commands (powershell-mode)
  :mode (("\\.ps1\\'" . powershell-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package ob-powershell
  :commands
  (org-babel-execute:powershell))
#+end_src

#+begin_src emacs-lisp
(use-package proced
  :ensure nil
  :custom
  (proced-enable-color-flag t)
  (proced-auto-update-flag t)
  (proced-auto-update-interval 1)
  :config
  (add-to-list
   'proced-format-alist
   '(custom user pid ppid sess tree pcpu pmem rss start time state (args comm))))
#+end_src

Very nice screenshot package I learned about here: [[https://www.n16f.net/blog/taking-code-screenshots-in-emacs/][Brain dump – Taking code screenshots in Emacs]]

#+begin_src emacs-lisp
(use-package screenshot
  :ensure (:host github :repo "tecosaur/screenshot")
  :commands (screenshot))
#+end_src

#+begin_src emacs-lisp
(use-package smart-hungry-delete
  :bind (([remap backward-delete-char-untabify] . smart-hungry-delete-backward-char)
	 ([remap delete-backward-char] . smart-hungry-delete-backward-char)
	 ([remap delete-char] . smart-hungry-delete-forward-char))
  :init (smart-hungry-delete-add-default-hooks))
#+end_src

#+begin_src emacs-lisp
(use-package devdocs-browser
  :commands (devdocs-browser-install-doc
             devdocs-browser-open
             devdocs-browser-open-in))
#+end_src

#+begin_src emacs-lisp
(use-package just-mode
  :mode (("justfile" . just-mode))
  :commands (just-mode))
#+end_src

#+begin_src emacs-lisp
(use-package justl
  :commands (justl))
#+end_src

#+begin_src emacs-lisp
(use-package goto-addr
  :ensure nil
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
         ("<RET>" . goto-address-at-point)
         ("M-<RET>" . newline))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+end_src

#+begin_src emacs-lisp
(use-package detached
  :init
  (detached-init)
  :bind (;; Replace `async-shell-command' with `detached-shell-command'
         ([remap async-shell-command] . detached-shell-command)
         ;; Replace `compile' with `detached-compile'
         ([remap compile] . detached-compile)
         ([remap recompile] . detached-compile-recompile)
         ;; Replace built in completion of sessions with `consult'
         ([remap detached-open-session] . detached-consult-session))
  :custom ((detached-show-output-on-attach t)
           ;; don't use fish here
           (detached-shell-program "/usr/bin/env bash")
           (detached-terminal-data-command system-type)))
#+end_src

#+begin_src emacs-lisp
(use-package x509-mode
  :commands (x509-dwim))
#+end_src

#+begin_src emacs-lisp
(use-package websearch
  :commands (websearch
             websearch-mode
             websearch-define)
  :config
  (websearch-define "mdn"
      :query-separator "+"
      :query-url "developer.mozilla.org/en-US/search?q=")
  :bind
  (:map my/search-map
   ("w" . websearch)))
#+end_src

#+begin_src emacs-lisp
(use-package annotate
  :commands (annotate-mode))
#+end_src

#+begin_src emacs-lisp
(use-package org-mpv-notes
  :commands (org-mpv-notes-open
             org-mpv-notes-mode))
#+end_src

#+begin_src emacs-lisp
(use-package tabspaces
  :disabled t
  :hook (elpaca-after-init . tabspaces-mode)
  :commands (tabspaces-switch-or-create-workspace
             tabspaces-open-or-create-project-and-workspace
             tabspaces--buffer-list)

  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "default")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '("*scratch*"))
  ;; sessions
  (tabspaces-session t)
  (tabspaces-session-auto-restore nil)

  :config
  (with-eval-after-load 'consult
    ;; hide full buffer list (still available with "b" prefix)
    (consult-customize consult--source-buffer :hidden t :default nil)
    ;; set consult-workspace buffer list
    (defvar consult--source-workspace
      (list :name     "Workspace Buffers"
            :narrow   ?w
            :history  'buffer-name-history
            :category 'buffer
            :state    #'consult--buffer-state
            :default  t
            :items    (lambda () (consult--buffer-query
                                  :predicate #'tabspaces--local-buffer-p
                                  :sort 'visibility
                                  :as #'buffer-name)))

      "Set workspace buffer list for consult-buffer.")
    (add-to-list 'consult-buffer-sources 'consult--source-workspace))
  )
#+end_src

#+begin_src emacs-lisp
(use-package activities
  :bind
  (("C-x C-a C-n" . activities-new)
   ("C-x C-a C-d" . activities-define)
   ("C-x C-a C-a" . activities-resume)
   ("C-x C-a C-s" . activities-suspend)
   ("C-x C-a C-k" . activities-kill)
   ("C-x C-a RET" . activities-switch)
   ("C-x C-a C-b" . activities-switch-buffer)
   ("C-x C-a C-g" . activities-revert)
   ("C-x C-a C-l" . activities-list))
  :init
  (activities-mode t)
  (activities-tabs-mode t)
  (setq edebug-inhibit-emacs-lisp-mode-bindings t))
#+end_src

#+begin_src emacs-lisp
(use-package beframe
  :hook (elpaca-after-init . beframe-mode)
  :custom
  ;; (beframe-rename-function #'beframe-rename-frame)
  (beframe-rename-function #'my/beframe-rename-frame)
  (beframe-create-frame-scratch-buffer nil)

  :config
  (defvar consult-buffer-sources)
  (declare-function consult--buffer-state "consult")

  (with-eval-after-load 'consult
    (defface beframe-buffer
      '((t :inherit font-lock-string-face))
      "Face for `consult' framed buffers.")

    (defvar beframe--consult-source
      `( :name     "Frame-specific buffers (current frame)"
         :narrow   ?F
         :category buffer
         :face     beframe-buffer
         :history  beframe-history
         :items    ,#'beframe--buffer-names
         :action   ,#'switch-to-buffer
         :state    ,#'consult--buffer-state))

    (add-to-list 'consult-buffer-sources 'beframe--consult-source))

  (defun my/beframe-rename-frame (frame &optional name)
    "Rename FRAME per `beframe-rename-function'.

When called interactively, prompt for FRAME.  Else accept FRAME
if it is an object that satisfies `framep'.

With optional NAME as a string, use it to name the given FRAME.
When called interactively, prompt for NAME when a prefix argument
is given.

With no NAME argument try to infer a name based on the following:

- If the current window has a buffer that visits a file, name the
  FRAME after the file's name and its `default-directory'.

- If the current window has a non-file-visiting buffer, use the
  `buffer-name' as the FRAME name.

- Else use the `default-directory'.

Remember that this function doubles as an example for
`beframe-rename-function': copy it and modify it accordingly."
    (interactive
     (let ((select-frame (beframe--frame-prompt)))
       (list
        (beframe--frame-object select-frame)
        (when current-prefix-arg
          (read-string
           (format "Rename the frame now called `%s' to: "
                   select-frame)
           nil 'beframe--rename-frame-history select-frame)))))
    (modify-frame-parameters
     frame
     (list (cons 'name (my/beframe--infer-frame-name frame name)))))

  (defun my/beframe--infer-frame-name (frame name)
    "Infer a suitable name for FRAME with given NAME.
See `beframe-rename-frame'."
    (let* ((buffer (car (frame-parameter frame 'buffer-list)))
           (file-name (when (bufferp buffer)
                        (buffer-file-name buffer)))
           (id (frame-parameter frame 'window-id))
           (buf-name (buffer-name buffer))
           (dir (with-current-buffer buffer
                  default-directory)))

      ;; completely avoid naming issues; use the window-id as the frame name
      id

      ;; (cond
      ;;  ((and name (stringp name))
      ;;   name)
      ;;  ((and (not (minibufferp)) file-name)
      ;;   (format "%s  %s" buf-name dir))
      ;;  ((not (minibufferp))
      ;;   buf-name)
      ;;  (t
      ;;   dir))
      ))
  )
#+end_src

#+begin_src emacs-lisp
(use-package iedit
  :commands (iedit-mode
             iedit-rectangle-mode)
  :bind
  ("C-;" . iedit-mode))
#+end_src

#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
#+end_src

#+begin_src emacs-lisp
(use-package diff-at-point
  :commands (diff-at-point-open-and-goto-hunk
             diff-at-point-goto-source-and-close)
  :bind
  (:map diff-mode-shared-map
   ("gG" . diff-at-point-goto-source-and-close)))
#+end_src

#+begin_src emacs-lisp
(use-package rfc-mode
  :commands (rfc-mode-browse
             rfc-mode-read))
#+end_src

#+begin_src emacs-lisp
(use-package dwim-shell-command
  :config
  (require 'dwim-shell-commands))
#+end_src

#+begin_src emacs-lisp
(use-package org-web-tools
  :commands (org-web-tools-insert-web-page-as-entry
             org-web-tools-read-url-as-org))
#+end_src

#+begin_src emacs-lisp
(use-package treemacs
  :commands (treemacs)
  :bind
  (:map treemacs-mode-map
   ("t" . treemacs-next-line)
   ("n" . treemacs-previous-line)))

(use-package treemacs-magit
  :after (treemacs
          magit))
#+end_src

#+begin_src emacs-lisp
(use-package literate-calc-mode
  :commands (literate-calc-mode
             literate-calc-minor-mode))
#+end_src

#+begin_src emacs-lisp
(use-package journalctl-mode
  :commands (journalctl
             journalctl-boot
             journalctl-unit
             journalctl-user-unit))
#+end_src

#+begin_src emacs-lisp
(use-package no-littering)
#+end_src

#+begin_src emacs-lisp
(use-package kubedoc
  :commands (kubedoc))
#+end_src

#+begin_src emacs-lisp
(use-package kubernetes
  :commands (kubernetes-overview))
#+end_src

#+begin_src emacs-lisp
(use-package kubel
  :commands (kubel
             kubel-set-namespace
             kubel-set-context
             kubel-set-resource))
#+end_src

#+begin_src emacs-lisp
(use-package docker
  :commands (docker))
#+end_src

#+begin_src emacs-lisp
(use-package compile
  :ensure nil
  :custom
  (compilation-scroll-output 'first-error)
  )

(use-package xterm-color
  :custom
  (compilation-environment '("TERM=xterm-256color"))
  :config
  (defun my/advice-compilation-filter (f proc string)
    (funcall f proc (xterm-color-filter string)))
  (advice-add 'compilation-filter :around #'my/advice-compilation-filter))
#+end_src

#+begin_src emacs-lisp
(use-package run-command
  :commands (run-command)
  :custom
  (run-command-recipes '(run-command-recipe-terraform-init
                         run-command-recipe-terraform-init-upgrade
                         run-command-recipe-terraform-plan
                         run-command-recipe-terraform-plan-continuous
                         run-command-recipe-terraform-apply
                         run-command-recipe-packer-build
                         run-command-recipe-packer-validate))
  (run-command-run-method 'compile)

  :init
  (defun run-command-recipe-terraform-init ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Init"
             :command-name "terraform-init"
             :command-line "terraform init"))))

  (defun run-command-recipe-terraform-init-upgrade ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Init + Upgrade"
             :command-name "terraform-init-upgrade"
             :command-line "terraform init -upgrade"))))

  (defun run-command-recipe-terraform-plan ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Plan"
             :command-name "terraform-plan"
             :command-line "terraform plan"))))

  (defun run-command-recipe-terraform-plan-continuous ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Plan Continuously On Change"
             :command-name "terraform-plan-continuous"
             :command-line (format "find . | entr terraform plan")))))

  (defun run-command-recipe-terraform-apply ()
    (list
     (when (equal major-mode 'terraform-mode)
       (list :display "Apply"
             :command-name "terraform-apply"
             :command-line "terraform apply"))))

  (defun run-command-recipe-packer-validate ()
    (list
     (when (equal major-mode 'hcl-mode)
       (list :display "Validate"
             :command-name "packer-validate"
             :command-line "packer validate ."))))

  (defun run-command-recipe-packer-build ()
    (list
     (when (equal major-mode 'hcl-mode)
       (list :display "Build"
             :command-name "packer-build"
             :command-line "packer build -on-error=ask ."))))
  )
#+end_src

#+begin_src emacs-lisp
(use-package sudo-edit
  :after embark
  :commands (sudo-edit
             sudo-edit-find-file)
  :bind
  (:map embark-file-map
   ("$" . sudo-edit-find-file)
   :map embark-become-file+buffer-map
   ("$" . sudo-edit-find-file)))
#+end_src

#+begin_src emacs-lisp
(use-package scratch
  :commands (scratch))
#+end_src

#+begin_src emacs-lisp
(use-package link-hint
  :commands (link-hint-open-link
             link-hint-define-type)
  :bind
  (:map boon-goto-map
   ("w" . link-hint-open-link)
   ("W" . my/link-hint-open-in-external))

  :config
  (link-hint-define-type 'text-url
    :my-open-eww #'eww)
  (defun my/link-hint-eww ()
    (interactive)
    (avy-with my/link-hint-eww
      (link-hint--one :my-open-eww)))

  (defun my/link-hint-open-in-eww ()
    (interactive)
    (let ((browse-url-browser-function #'eww-browse-url))
      (link-hint-open-link)))

  (defun my/link-hint-open-in-external ()
    (interactive)
    (let ((browse-url-browser-function #'browse-url-default-browser))
      (link-hint-open-link))))
#+end_src

#+begin_src emacs-lisp
(use-package buffer-move
  :commands (buf-move-left
             buf-move-down
             buf-move-up
             buf-move-right))
#+end_src

#+begin_src emacs-lisp
(use-package edit-indirect
  :commands (edit-indirect-region))
#+end_src

#+begin_src emacs-lisp
(use-package dumb-jump
  :commands (xref-find-definitions
             xref-find-definitions-other-window)
  :hook (xref-backend-functions #'dumb-jump-xref-activate)
  :custom
  (dumb-jump-prefer-searcher 'rg))
#+end_src

#+begin_src emacs-lisp
(use-package deadgrep
  :init
  (defun my/deadgrep-context-adjust (amount)
    (let* ((old-before (or (car deadgrep--context) 0))
           (old-after (or (cdr deadgrep--context) 0))
           (before (+ old-before amount))
           (after (+ old-after amount)))

      (setq-local deadgrep--context (cons (if (< before 0) 0 before)
                                          (if (< after 0) 0 after)))
      (deadgrep-restart)))

  (defun my/deadgrep-context-more ()
    (interactive)
    (my/deadgrep-context-adjust 2))
  (defun my/deadgrep-context-less ()
    (interactive)
    (my/deadgrep-context-adjust -2))

  (defun my/deadgrep-here ()
    (interactive)
    (deadgrep (deadgrep--read-search-term) default-directory))

  :bind
  (:map my/search-map
   ("r" . deadgrep)
   ("R" . my/deadgrep-here)

   :map deadgrep-mode-map
   ("M-n" . deadgrep-backward-match)
   ("M-t" . deadgrep-forward-match)
   ("M-<up>" . deadgrep-backward-match)
   ("M-<down>" . deadgrep-forward-match)
   ("M-h" . deadgrep-backward-filename)
   ("M-s" . deadgrep-forward-filename)
   ("D" . deadgrep-search-directory)
   ("S" . deadgrep-search-term)
   ("+" . my/deadgrep-context-more)
   ("-" . my/deadgrep-context-less))

  :config
  (advice-add 'deadgrep-backward-filename :after #'recenter)
  (advice-add 'deadgrep-forward-filename :after #'recenter)
  (advice-add 'deadgrep-backward-match :after #'recenter)
  (advice-add 'deadgrep-forward-match :after #'recenter)

  (defun my/deadgrep--include-args (rg-args)
    (if (string= (project-name) ".config")
        ;; (push "--hidden" rg-args) ;; consider hidden folders/files
        ;; (push "--follow" rg-args) ;; follow symlink
        (push "--no-ignore-vcs" rg-args) ;; ignore .gitignore
      rg-args
      ))

  (advice-add 'deadgrep--arguments :filter-return #'my/deadgrep--include-args)
  )
#+end_src

#+begin_src emacs-lisp
(use-package image-mode
  :ensure nil
  :defer t
  :hook (image-mode . (lambda () (blink-cursor-mode -1))))
#+end_src

#+begin_src emacs-lisp
;; The auto-decrypt-encrypt hook complains about the password-file var not being set, even though
;; the manual encrypt/decrypt functions work just fine.
(use-package ansible
  :commands (ansible ansible-auto-decrypt-encrypt)
  :hook ((yaml-mode . ansible)
         (ansible . ansible-auto-decrypt-encrypt))
  :custom
  (ansible-vault-password-file ""))
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :custom-face
  (rainbow-delimiters-unmatched-face ((t (:height 1.0 :inherit 'error))))
  (rainbow-delimiters-depth-1-face ((t (:height 1.0))))
  (rainbow-delimiters-depth-2-face ((t (:height 1.1))))
  (rainbow-delimiters-depth-3-face ((t (:height 1.2))))
  (rainbow-delimiters-depth-4-face ((t (:height 1.3))))
  (rainbow-delimiters-depth-5-face ((t (:height 1.4))))
  (rainbow-delimiters-depth-6-face ((t (:height 1.5))))
  (rainbow-delimiters-depth-7-face ((t (:height 1.6))))
  (rainbow-delimiters-depth-8-face ((t (:height 1.7))))
  (rainbow-delimiters-depth-9-face ((t (:height 1.8)))))
#+end_src

#+begin_src emacs-lisp
(use-package wgrep
  :commands wgrep-change-to-wgrep-mode)
#+end_src

#+begin_src emacs-lisp
(use-package wgrep-deadgrep
  :after (wgrep
          deadgrep)
  :hook (deadgrep-finished . wgrep-deadgrep-setup))
#+end_src

#+begin_src emacs-lisp
(use-package elec-pair
  :ensure nil
  :hook (prog-mode . electric-pair-mode)
  :custom
  (electric-pair-skip-whitespace nil))
#+end_src

#+begin_src emacs-lisp
(use-package executable
  :ensure nil
  :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

#+begin_src emacs-lisp
(use-package quick-peek
  :commands (quick-peek-show
             quick-peek-hide
             quick-peek-overlay-contents
             quick-peek-overlay-ensure-at)
  :custom
  (quick-peek-add-spacer nil))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck
  :disabled
  :hook (prog-mode . flycheck-mode)
  :custom (flycheck-check-syntax-automatically '(save mode-enabled)))

(use-package flycheck-inline
  :disabled
  :hook (flycheck-mode . turn-on-flycheck-inline)

  :init
  (setq flycheck-inline-display-function
        (lambda (msg pos err)
          (let* ((ov (quick-peek-overlay-ensure-at pos))
                 (contents (quick-peek-overlay-contents ov)))
            (setf (quick-peek-overlay-contents ov)
                  (concat contents (when contents "\n") msg))
            (quick-peek-update ov)))
        flycheck-inline-clear-function #'quick-peek-hide)

  :custom-face
  (flycheck-inline-info ((t (:height 1.0
                             :foreground "#000000" :background "#87ceeb"
                             :inherit 'info
                              :extend t
                             :box (:line-width 5 :color "#87ceeb")))))
  (flycheck-inline-warning ((t (:height 1.0
                                :foreground "#000000" :background "#ffd700"
                                :inherit 'warning
                                :extend t
                                :box (:line-width 5 :color "#ffd700")))))
  (flycheck-inline-error ((t (:height 1.0
                              :foreground "#ffffff" :background "#b22222"
                              :inherit 'error
                              :extend t
                              :box (:line-width 5 :color "#b22222"))))))

(use-package flycheck-posframe
  :disabled
  :hook (flycheck-mode . flycheck-posframe-mode)
  :config
  (set-face-attribute 'flycheck-posframe-warning-face nil
                      :height 1.1 :foreground "#111111" :background "#ffd700" :inherit 'warning)
  (set-face-attribute 'flycheck-posframe-error-face nil
                      :height 1.1 :foreground "#eeeeee" :background "#b22222" :inherit 'error))
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-mode
  :commands (rainbow-mode))
#+end_src

#+begin_src emacs-lisp
(use-package aggressive-indent
  :disabled
  :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src

#+begin_src emacs-lisp
(use-package dtrt-indent
  :commands (dtrt-indent-mode
             dtrt-indent-global-mode)
  :config
  (dtrt-indent-global-mode t))
#+end_src

#+begin_src emacs-lisp
(use-package envrc
  :hook (elpaca-after-init . envrc-global-mode))
#+end_src

#+begin_src emacs-lisp
(use-package yaml-mode
  :disabled
  :commands yaml-mode
  :mode (("\\(host\\|group\\)_vars.*" . yaml-mode)
         ("\\.*cloud-\\(init\\|config\\).*" . yaml-mode)
         ("\\.yml|yaml\\'" . yaml-mode))
  :init
  (add-to-list 'magic-mode-alist '("#cloud-config" . yaml-mode)))

(use-package yaml-pro
  :mode (("\\(host\\|group\\)_vars.*" . yaml-pro-ts-mode)
         ("\\.*cloud-\\(init\\|config\\).*" . yaml-pro-ts-mode)
         ("\\.yml|yaml\\'" . yaml-pro-ts-mode))
  :commands (yaml-pro-ts-mode)
  :init
  (add-to-list 'magic-mode-alist '("#cloud-config" . yaml-pro-ts-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package json-mode
  :mode (("\\.json\\'" . json-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package scad-mode
  :mode (("\\.scad__'" . scad-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package gcode-mode
  :mode (("\\.gcode__'" . gcode-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package expreg
  :ensure nil
  :load-path "site-lisp"
  :bind
  (("M-v" . expreg-expand)
   :repeat-map expreg-repeat-map
   ("v" . expreg-expand)
   ("V" . expreg-contract)))
#+end_src

#+begin_src emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode)
  :mode ("\\.md'" . markdown-mode))
#+end_src

#+begin_src emacs-lisp
(use-package hcl-mode
  :commands hcl-mode)

(use-package terraform-mode
  :mode ("\\.tf|tfvars\\'" . terraform-mode)
  :hook ((terraform-mode . yas-minor-mode-on))
  :custom-face
  (terraform--resource-type-face
   ((t (:inherit 'font-lock-constant-face))))
  (terraform--resource-name-face
   ((t (:inherit 'font-lock-variable-name-face))))
  :config
  (delete 'gnu compilation-error-regexp-alist)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(terraform-error
                 "^Error: [[:print:]]+[[:space:]]+[[:blank:]]+on \\([^[:blank:]]+\\) line \\([[:digit:]]+\\)[,:]"
                 1 2))
  (add-to-list 'compilation-error-regexp-alist
               'terraform-error))

(use-package terraform-doc
  :commands (terraform-doc)
  :custom
  (terraform-doc-markdown-mode-function #'gfm-view-mode))
#+end_src

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile\\'" . dockerfile-mode))
#+end_src

#+begin_src emacs-lisp
(use-package csv-mode
  :mode "\\.csv\\'")
#+end_src

#+begin_src emacs-lisp
(use-package elf-mode
  :commands elf-mode
  :magic ("ELF" . elf-mode))
#+end_src

* Misc functions

Handy snippet found [[https://emacs.ch/@bram85/112463005253079332][on mastodon]] and modified a little. Just adds the time and date (and system load) to the mode line when emacs is in fullscreen mode.

#+begin_src emacs-lisp
(defun my/show-time-when-fullscreen (frame)
  "Show the time in the modeline when the FRAME becomes full screen."
  (let ((fullscreen (frame-parameter frame 'fullscreen)))
    (if (memq fullscreen '(fullscreen fullboth))
        (display-time-mode 1)
      (display-time-mode -1))))

(customize-set-variable 'display-time-day-and-date t)
(customize-set-variable 'display-time-24hr-format t)
(add-hook 'window-size-change-functions #'my/show-time-when-fullscreen)
#+end_src

I want some repeat maps to timeout, but I don't want to set it globally with =repeat-exit-timeout=, so I have this function that will iterate through a map and apply a timeout setting to them. I may want another function to turn the timeout off for a map, or the option to pass a list of commands so I can set timeout for only some of the commands in a map. I'll deal with that when I actually need it though.

#+begin_src emacs-lisp :tangle no :noweb-ref misc-functions
(defun my/set-repeat-map-timeout (keymap timeout)
  "Set the TIMEOUT for commands in a repeat map."
  (map-keymap
   (lambda (_key cmd)
     (when (symbolp cmd)
       (put cmd 'repeat-exit-timeout timeout)))
   keymap))
#+end_src

I like the vim/evil style join where the next line is pulled up and joined to the one at point, rather than joining the line at point to the previous line. So this function uses the built in =join-line= to do that by default, and preserves the region joining behaviour that I didn't actually know about before.

#+begin_src emacs-lisp :tangle no :noweb-ref misc-functions
(defun my/join-line ()
  (interactive)
  (if (region-active-p)
      (join-line nil (region-beginning) (region-end))
    (let ((current-prefix-arg '(4)))
      (call-interactively #'join-line))))
#+end_src

And let's give it the same keybinding as evil, since I'm used to it.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-config
;; need to find a new key for either this or meow-block
;; jk works now if on second line to be joined
;; (meow-normal-define-key '("J" . my/join-line))
#+end_src

From this unrelated [[https://www.reddit.com/r/emacs/comments/13v3op3/an_improved_emacs_search/][reddit thread]].

#+begin_src emacs-lisp
(defun my/delete-visited-file (buffer-name)
  "Delete the file visited by the buffer named BUFFER-NAME."
  (interactive "bDelete file visited by buffer ")
  (let* ((buffer (get-buffer buffer-name))
         (filename (buffer-file-name buffer)))
    (when buffer
      (when (and filename
                 (file-exists-p filename))
        (delete-file filename))
      (kill-buffer buffer))))
#+end_src

From: [[https://xenodium.com/deleting-from-emacs-sequence-vars/][Deleting from Emacs sequence vars]]. Magic. Did this not exist before? How? Modified slightly to accept an argument for usage with embark.
TODO would be great if this showed something useful for keys when deleting from a keymap

#+begin_src emacs-lisp
(defun my/remove-from-list-variable (&optional seqvar)
  (interactive)
  (let* ((var (or seqvar
                  (intern
                   (completing-read "From variable: "
                                    (let (symbols)
                                      (mapatoms
                                       (lambda (sym)
                                         (when (and (boundp sym)
                                                    (seqp (symbol-value sym)))
                                           (push sym symbols))))
                                      symbols) nil t))))
         (values (mapcar (lambda (item)
                           (setq item (prin1-to-string item))
                           (concat (truncate-string-to-width
                                    (nth 0 (split-string item "\n"))
                                    (window-body-width))
                                   (propertize item 'invisible t)))
                         (symbol-value var)))
         (index (progn
                  (when (seq-empty-p values) (error "Already empty"))
                  (seq-position values (completing-read "Delete: " values nil t)))))
    (unless index (error "Eeek. Something's up."))
    (set var (append (seq-take (symbol-value var) index)
                     (seq-drop (symbol-value var) (1+ index))))
    (message "Deleted: %s" (truncate-string-to-width
                            (seq-elt values index)
                            (- (window-body-width) 9)))))

(with-eval-after-load 'embark
  (keymap-set embark-variable-map "R" #'my/remove-from-list-variable))
#+end_src

Originally this came from [[https://karthinks.com/software/more-less-emacs/][more < less < emacs | Karthinks]], but I had to make some changes to make it work with evil and blink-cursor-mode. There's a little bit of relevant config in with the evil-collection package as well.
[[https://emacs.stackexchange.com/questions/18374/persistently-hide-cursor-evil-mode-problem][buffers - Persistently hide cursor [evil-mode problem] - Emacs Stack Exchange]]
[[https://github.com/emacs-evil/evil/issues/592][Evil makes hidden cursor reappear on window configuration changes · Issue #592 · emacs-evil/evil · GitHub]]

#+begin_src emacs-lisp
(define-minor-mode hide-cursor-mode
  "Hide or show the cursor.

When the cursor is hidden `scroll-lock-mode' is enabled, so that
the buffer works like a pager."
  :global nil
  :lighter "H"
  (if hide-cursor-mode
      (progn
        (scroll-lock-mode 1)
        (blink-cursor-mode -1)
        (internal-show-cursor nil nil)
        )
    (scroll-lock-mode -1)
    (internal-show-cursor nil t)))

(add-hook 'elfeed-show-mode-hook #'hide-cursor-mode-enable)

(defun hide-cursor-mode-enable ()
  (hide-cursor-mode 1)
  (add-hook 'kill-buffer-hook #'hide-cursor-mode-disable 0 t))

(defun hide-cursor-mode-disable ()
  (hide-cursor-mode -1))
#+end_src

#+begin_src emacs-lisp
;; from https://www.reddit.com/r/emacs/comments/z5r75b/how_to_open_a_file_with_external_program_with/
;; it works well, but the launched process will die with emacs

(defun async/open-with-zathura (files)
  "
It can be used programatically

  (it \"~/a.pdf\" \"~/b.pdf\")

interactively, or via #'embark-act.
"
  (interactive "sOpen file with zathura: ")
  (when (stringp files) (setf files (list files)))
  (let ((buf (current-buffer))
        (command `("zathura"
                   ,@(mapcar (lambda (x)
                               (format "%s" x))
                             files))))
    (message (format "Running command: %S" command))
    (make-process
     :name     "dired/async/open-with-zathura"
     :command  command
     :buffer   (get-buffer "*Messages*")
     :sentinel (lambda (proc type)
                 (declare (ignore (proc type)))
                 (with-current-buffer buf
                   (revert-buffer))))))

(add-hook 'elpaca-after-init-hook
          #'(lambda ()
              (define-key embark-file-map "z" #'async/open-with-zathura)))

;; this doesn't work, because I don't have dired/funcall-on-marked-files
(defun dired/async/open-with-zathura ()
  "Open selected files with zathura."
  (interactive)
  (dired/funcall-on-marked-files #'async/open-with-zathura))
#+end_src

#+begin_src emacs-lisp
;; from https://www.reddit.com/r/emacs/comments/l51ocx/what_is_the_most_useful_part_of_your_emacs_config/gkrz1di
(defun insert-date ()
  "Insert today's date at point"
  (interactive "*")
  (insert (format-time-string "%F")))
#+end_src

#+begin_src emacs-lisp
(defun my/indent-buffer ()
  "Indent the current buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

(defun my/indent-region-or-block-or-buffer ()
  "Indent the active region, org src block, or the current buffer."
  (interactive)
  (save-excursion
    (cond ((region-active-p)
           (indent-region (region-beginning) (region-end)))
          ((and (string= major-mode 'org-mode)
                (org-in-src-block-p))
           (let ((context (org-element-context)))
             (indent-region (plist-get (cl-second context) :begin)
                            (plist-get (cl-second context) :end))))
          (t (my/indent-buffer)))))

(defun my/indent-region-or-buffer ()
  "Indent the active region or the current buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (indent-region (region-beginning) (region-end))
      (my/indent-buffer))))
#+end_src

A nice couple of functions for opening files from dired asynchronously. Handy use of =nohup= so external programs keep running when the launching emacs exits. This is a combination of bits from [[https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/][this thread on reddit]].

#+begin_src emacs-lisp
(defun open-file-external (file)
  "Open a file externally with xdg-open."
  (interactive "f")
  (let ((process-connection-type nil))
    (start-process
     "" nil shell-file-name
     shell-command-switch
     (format "nohup 1>/dev/null 2>/dev/null xdg-open %s"
             (expand-file-name file)))))

(defun my/dired-open()
  (interactive)
  (cond
   ;; use dired-find-file if it is a directory
   ((file-directory-p (dired-get-file-for-visit))
    (dired-find-file))
   ;; use dired-find-file if the mime type of the file is emacs.desktop
   ((string= "emacs.desktop" (string-trim-right (shell-command-to-string
                                                 (format "xdg-mime query filetype %s | xargs xdg-mime query default"
                                                         (shell-quote-argument (dired-get-file-for-visit))))))
    (dired-find-file))
   (t
    ;; use xdg-open for everything else
    (open-file-external (shell-quote-argument (dired-get-file-for-visit))))))
#+end_src

This function gives me a quicker way to edit src blocks in org mode, as well as making indirect buffer cloning a bit /less/ accessible (only on headings), since I do it relatively infrequently and have actually been ending up in indirect buffers a bit /too/ easily. I just bind this to =enter= in org mode.

#+begin_src emacs-lisp :tangle no
(defun my/org-ret ()
  "Make RET either narrow to the heading at point or edit the src block at point."
  (interactive)
  (cond ((org-at-heading-p) (org-tree-to-indirect-buffer))
        ((org-in-src-block-p) (org-edit-src-code))))

(defun my/org-shift-ret ()
  "Make S-RET either narrow to the heading at point or edit the src block at point."
  (interactive)
  (cond ((org-at-heading-p) (org-tree-to-indirect-buffer-other-frame))
        ((org-in-src-block-p) (org-edit-src-code))))
#+end_src

I wanted a way to move org items to the top of their own level, and found one [[https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent][on stackoverflow]]. I inverted its behaviour to move to the top by default, and to the bottom with a prefix arg.

#+begin_src emacs-lisp
(defun JK-org-move-to-extreme (down)
  "Move current org subtree to the start of its parent.
With prefix arg move subtree to the end of its parent."
  (interactive "P")
  (condition-case err
      (while t
        (funcall (if down
                     'org-move-subtree-down
                   'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg)))))))
#+end_src

Attaching this next one to =org-src-mode= will disable the annoying flycheck warnings that are really only relevant to complete files.

#+begin_src emacs-lisp
(defun disable-flycheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src

#+begin_src emacs-lisp
(defun narrow-to-region-indirect (start end)
  "Restrict editing in this buffer to the current region (from START to END), indirectly."
  (interactive "r")
  (deactivate-mark)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-region start end))
    (switch-to-buffer buf)))
#+end_src

#+begin_src emacs-lisp
(defun shorten-directory (dir max-length)
  "Show up to MAX-LENGTH characters of a directory name DIR."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
        (output ""))
    (when (and path (equal "" (car path)))
      (setq path (cdr path)))
    (while (and path (< (length output) (- max-length 4)))
      (setq output (concat (car path) "/" output))
      (setq path (cdr path)))
    (when path
      (setq output (concat "…/" output)))
    output))
#+end_src

#+begin_src emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
        (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))
#+end_src

#+begin_src emacs-lisp
;; https://github.com/noctuid/general.el#use-package-keyword
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
(defun Fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.

  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:

  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);

  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;

  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.

  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))

(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'Fuco1/lisp-indent-function)))
#+end_src

#+begin_src emacs-lisp
;; from https://stackoverflow.com/questions/47327066/how-to-open-an-indirect-buffer-in-a-new-frame-in-a-single-call-in-emacs
(defun clone-indirect-buffer-other-frame (newname display-flag &optional norecord)
  "Like `clone-indirect-buffer' but display in another frame."
  (interactive
   (progn
     (if (get major-mode 'no-clone-indirect)
         (error "Cannot indirectly clone a buffer in %s mode" mode-name))
     (list (if current-prefix-arg
               (read-buffer "Name of indirect buffer: " (current-buffer)))
           t)))
  ;; (let ((pop-up-windows t))
  (let ((pop-up-frames t)) ; <==========
    (clone-indirect-buffer newname display-flag norecord)))
#+end_src

#+begin_src emacs-lisp
(defun org-tree-to-indirect-buffer-other-frame ()
  (interactive)
   (let ((org-indirect-buffer-display 'new-frame))
     (org-tree-to-indirect-buffer)))
#+end_src

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
