#+property: header-args:emacs-lisp :tangle (concat (file-name-sans-extension (buffer-file-name)) ".el")
#+property: header-args :mkdirp yes :comments no :results silent
#+startup: indent

#+begin_src emacs-lisp :exports none
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programming source file (config.org).
;; You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

#+title: My Emacs config file
#+author: Nathan Howell
#+email: nath@nhowell.net

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:init.el][init.el]] for the generated file. This configuration was heavily influenced/started from [[http://zzamboni.org/post/my-emacs-configuration-with-commentary/][Diego Zamboni’s configuration]], as well as [[https://github.com/blaenk/dots/tree/master/emacs/.emacs.d][Jorge Israel Peña's]].

This is a handy command I’ve been using to test as I move to a literate config. =C-c C-c= will launch a new emacs, using the tangled version of this config.
#+begin_src shell :tangle no :results silent
emacs -Q -l profile-dotemacs.el --eval "(setq profile-dotemacs-file (setq load-file-name \"/home/nathan/.emacs.d/init.el\"))" -f profile-dotemacs
#+end_src

Enable [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][lexical binding]].
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Performance optimization

Lately I've been playing with optimizing my Emacs load time. I have found a couple of useful resources, including:

- [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][Two easy little known steps to speed up Emacs start up time]]
- [[https://blog.d46.us/advanced-emacs-startup/][Advanced Techniques for Reducing Emacs Startup Time]]

Based on these, I have added the code below.

First, a hook that reports how long and how many garbage collections the startup took. Use a hook so the message doesn't get clobbered by other messages.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

Next, we wrap the whole init file in a block that sets =file-name-handler-alist= to =nil= to prevent any special-filename parsing of files loaded from the init file (e.g. remote files loaded through tramp, etc.). The =let= block gets closed in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp
(let ((file-name-handler-alist nil))
#+end_src

We set =gc-cons-threshold= to its maximum value, to prevent any garbage collection from happening during load time. We also reset this value in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

* Package management

I use [[https://github.com/raxod502/straight.el][straight.el]] instead of package.el.

This setting makes the straight bootstrap /much/ faster. See the discussion [[https://github.com/raxod502/straight.el/issues/304][here]].

#+begin_src emacs-lisp
(setq straight-check-for-modifications '(check-on-save))
#+end_src

And now bootstrap straight, using the snippet from the docs.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

And then make [[https://github.com/jwiegley/use-package][use-package]] use straight, and install use-package using straight:

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
(straight-use-package 'use-package)
(setq use-package-verbose nil
      ;; use-package-always-defer t
      )
#+end_src

This =use-package= extension allows declaring dependencies on system commands.

#+begin_src emacs-lisp
(use-package use-package-ensure-system-package)
#+end_src

Set up ESUP for startup profiling. In theory. [[https://github.com/jschaf/esup/issues/54][It breaks.]]

#+begin_src emacs-lisp
(use-package esup
  :disabled t)
#+end_src

* Base settings

Turn off all startup messages, splash screens, menu bars, scrollbars, etc. for a clean start.

#+begin_src emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      initial-scratch-message nil
      inhibit-startup-echo-area-message t)

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

Set scrolling options. These stop the half-page jumps while scrolling, and make things smoother. Haven’t tried out =pixel-scroll-mode= yet.

#+begin_src emacs-lisp
(setq-default mouse-wheel-scroll-amount '(2 ((shift) . 1)) ;; one line at a time
              mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
              mouse-wheel-follow-mouse 't ;; scroll window under mouse
              scroll-step 1 ;; keyboard scroll one line at a time
              scroll-margin 5
              hscroll-step 5
              hscroll-margin 5
              scroll-preserve-screen-position 'always
              scroll-up-aggressively 0.01
              scroll-down-aggressively 0.01
              scroll-conservatively 101) ;; Don't jump around when scrolling
#+end_src

And let’s try out the new single-line-horizontal-scroll option in emacs 26.

#+begin_src emacs-lisp
(setq-default auto-hscroll-mode 'current-line)
#+end_src

Set the window titles. Nothing fancy, just the buffer name.

#+begin_src emacs-lisp
(setq frame-title-format "%b" ;; focused window title format
      icon-title-format "%b") ;; unfocused window title format
#+end_src

Set my preferred font and size, taking display DPI into account. Bits and pieces of this came from various places, but especially [[https://www.reddit.com/r/emacs/comments/a01fs1/dispwatch_watch_the_current_display_for_changes/][this reddit thread]], which led me to [[https://emacs.stackexchange.com/questions/28390/quickly-adjusting-text-to-dpi-changes/44930#44930][this useful StackExchange question]]. I will probably revisit and incorporate more of what’s there later, but for now this will do. I’ll have to test this with different screens and moving frames between them (particularly, the =set-frame-font= args may need adjustment). Also, a hook for a frame moving to a different screen would be useful.

#+begin_src emacs-lisp
(defun frame-monitor-mm ()
  "Return the size of the current monitor in mm."
  (alist-get 'mm-size (frame-monitor-attributes)))

(defun frame-monitor-pixels ()
  "Return the geometry of the current monitor in pixels."
  (alist-get 'geometry (frame-monitor-attributes)))

(defun monitor-dpi ()
  "Return the DPI of the current monitor."
  (let* ((mm (frame-monitor-mm))
         (mm-width (car mm))
         (pixels (frame-monitor-pixels))
         (pixel-width (nth 2 pixels)))
    (/ pixel-width (/ mm-width 25.4))))

(defun neh/set-frame-options (frame)
  "Set font options for a FRAME based on the DPI."
  (let ((myfont "Iosevka")
        (mysize (if (> (monitor-dpi) 160)
                    20
                  10.5)))
    (set-frame-font (format "%s-%f" myfont mysize) t t)
    (set-face-attribute 'default nil :font (format "%s-%f" myfont mysize))))

(neh/set-frame-options nil)
(add-hook 'after-make-frame-functions #'neh/set-frame-options)
#+end_src

I don’t really use the customization system in Emacs (yet?) but let’s at least make it use a file that isn’t the main config.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'no-error)
#+end_src

All UTF-8, all the time.

#+begin_src emacs-lisp
(setq coding-system-for-read 'utf-8
      coding-system-for-write 'utf-8)
#+end_src

Don’t use tabs when indenting.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

More options. I’m not sure where to put some things in this file yet. Here are some.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
(setq ring-bell-function 'ignore)
(setq enable-recursive-minibuffers t)
(global-subword-mode 1)
#+end_src

Don’t warn me when I do these potentially confusing narrowing operations.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
#+end_src

Set some backup file options.

#+begin_src emacs-lisp
(setq make-backup-files nil
      delete-old-versions t
      backup-directory-alist
      `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

I view man pages in emacs sometimes, and want a fixed width for them.

#+begin_src emacs-lisp
(setenv "MANWIDTH" "100")
#+end_src

I’m testing out [[https://github.com/swaywm/sway][sway]] as my window manager, and apparently ~$SSH_AUTH_SOCK~ doesn’t get set (maybe just for xwayland apps?). So we workaround. I already set a fixed link to the real socket for tmux usage, I can reuse it for this.

#+begin_src emacs-lisp
(when (string= (getenv "SSH_AUTH_SOCK") nil)
  (setenv "SSH_AUTH_SOCK" (format "/tmp/ssh-agent-%s-tmux" (getenv "USER"))))
#+end_src

Some text fill options.

#+begin_src emacs-lisp
(setq-default fill-column 100)
(setq comment-auto-fill-only-comments t)
#+end_src

How to make display buffer names.

#+begin_src emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+end_src

Some git/vc options.

#+begin_src emacs-lisp
(setq auto-revert-check-vc-info t
      vc-follow-symlinks t)
#+end_src

When pasting (yanking) into emacs, paste at the point, not where I click (I like to paste with the middle mouse button, xorg-style).

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

* Keybindings

[[https://github.com/noctuid/general.el][General.el]] handles keybinding management.

#+begin_src emacs-lisp
(use-package general
  :demand t

  :config
  (general-create-definer
    neh/leader-keys
    :keymaps 'override
    :states '(emacs normal visual motion insert)
    :non-normal-prefix "C-SPC"
    :prefix "SPC")

  (general-override-mode)

  (general-define-key
   :keymaps 'override
   :states '(emacs normal insert)
   "C-M-t" 'scroll-other-window
   "C-M-n" 'scroll-other-window-down

   ;; "C-<tab>" 'next-buffer
   ;; "C-S-<iso-lefttab>" 'previous-buffer
   )

  (neh/leader-keys
    "<SPC>" '(save-buffer :which-key "save")

    "b" '(:ignore t :which-key "buffer")

    "cc" '(comment-or-uncomment-region-or-line :which-key "toggle comment")

    "f" '(:ignore t :which-key "formatting")
    "fa" '(auto-fill-mode :which-key "auto fill")
    "fi" '(indent-region :which-key "indent region")
    "fp" '(fill-paragraph :which-key "paragraph")
    "fr" '(fill-region :which-key "fill region")
    "ft" '(toggle-truncate-lines :which-key "truncate lines")

    "g" '(:ignore t :which-key "git")

    "h" '(:ignore t :which-key "help")

    "hl" '(highlight-lines-matching-regexp :which-key "highlight line")
    "hr" '(highlight-regexp :which-key "highlight regexp")
    "hu" '(unhighlight-regexp :which-key "unhighlight regexp")

    "i" '(:ignore t :which-key "insert")
    "ip" '(clipboard-yank :which-key "paste from clipboard")

    "n" '(:ignore t :which-key "narrow")
    "nd" '(narrow-to-defun :which-key "narrow to defun")
    "np" '(narrow-to-page :which-key "narrow to page")
    "nr" '(narrow-to-region :which-key "narrow to region")
    "nw" '(widen :which-key "widen")

    "o" '(:ignore t :which-key "open")
    "oe" '(mode-line-other-buffer :which-key "previous buffer")
    ;; "oo" '(persp-switch-to-buffer :which-key "switch buffer")
    ;; "ov" '(persp-switch :which-key "switch perspective")

    "Q" #'bury-buffer

    "s" '(:ignore t :which-key "search")

    "r" '(:ignore t :which-key "read")

    "v" '(:ignore t :which-key "view")

    "xb" '(eval-buffer :which-key "eval buffer")
    "xe" '(eval-expression :which-key "eval expression")
    "xr" '(eval-region :which-key "eval region")
    "xs" '(eval-last-sexp :which-key "eval sexp")))
#+end_src

Which-key shows a handy popup for available keybindings at any given time.

#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :config
  (which-key-setup-side-window-bottom)
  (setq which-key-idle-secondary-delay 0.25)
  (which-key-mode))
#+end_src

Key chords are interesting, and I’m not sure I’ll keep them yet. Doing vim-style bindings with leaders is maybe just as good?

#+begin_src emacs-lisp
(use-package key-chord
  :demand t)

(use-package use-package-chords
  :after key-chord
  :demand t
  :config
  (key-chord-mode 1))
#+end_src

* Base2

Not sure where to put everything yet, so this section is a grab bag of stuff that needs package management (straight) to be in place.

#+begin_src emacs-lisp
(use-package saveplace
  :demand t
  :config
  (save-place-mode t))

(use-package eldoc
  :straight nil
  :init
  (setq eldoc-echo-area-use-multiline-p nil))

(use-package undo-tree
  :config
  (global-undo-tree-mode t))

(use-package paren
  :init
  (setq show-paren-delay 0
        show-paren-style 'parenthesis)
  :config
  (show-paren-mode 1))

(use-package whitespace
  :commands (whitespace-mode)
  :general
  (neh/leader-keys
    "vw" '(whitespace-mode :which-key "whitespace"))
  :init
  (setq whitespace-line-column 80
        whitespace-style '(face trailing tabs lines-tail)))

(use-package helpful
  :init
  (setq helpful-max-buffers 1)
  :general
  (neh/leader-keys
    "h." '(helpful-at-point :which-key "point help")
    "hf" '(helpful-callable :which-key "function help")
    "hk" '(helpful-key :which-key "key help")
    "hv" '(helpful-variable :which-key "variable help")))
#+end_src

Make sure my local bin dir is in emacs =$PATH=, and keep it updated.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init
  (setq exec-path (append exec-path '("~/bin"))
        exec-path-from-shell-arguments '("-l"))
  :config
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+end_src

* Text mode

General settings when in text editing modes.

#+begin_src emacs-lisp
(use-package simple
  :straight nil
  :hook ((text-mode prog-mode) . visual-line-mode)
  :general
  (neh/leader-keys
    "fv" '(visual-line-mode :which-key "visual line mode")))

(use-package visual-fill-column
  :hook (visual-line-mode . visual-fill-column-mode)
  :general
  (neh/leader-keys
    "fc" '(visual-fill-column-mode :which-key "visual fill column"))

  :config
  (advice-add 'text-scale-adjust :after
              #'visual-fill-column-adjust))
#+end_src

I’ll put olivetti mode here since I think it’s mainly a text mode thing rather than for programming, but who knows.

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :config
  (setq-default olivetti-body-width 100))
#+end_src

* Prog mode

General settings for programming modes.

#+begin_src emacs-lisp
(defun my-prog-mode-hook ()
  "Set line-numbers settings for 'prog-mode'."
  ;; (setq display-line-numbers 'relative)
  (add-hook 'prog-mode-hook #'my-prog-mode-hook)
  (add-hook 'yaml-mode-hook #'my-prog-mode-hook))
#+end_src

* Pretty it up

I’ve been liking dark-on-light themes lately, and brutalist with some tweaks has been good.

#+begin_src emacs-lisp
(use-package poet-theme
  :config
  (load-theme 'poet t))
#+end_src

But I like some things to be set no matter the theme. For example, I always like italic code comments. And the brutalist theme has a smaller modeline font size that I don’t like. So I set up a hook/advice method of keeping these things “fixed”. I found the idea in [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/][this helpful reddit thread]] while looking for what I thought /must/ have a /good/ solution.

#+begin_src emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))

(add-hook 'after-load-theme-hook #'neh/theme-tweaks)
(add-hook 'after-init-hook #'neh/theme-tweaks)
#+end_src

And here’s my hook function where I collect my tweaks to the theme.

#+begin_src emacs-lisp
(defun neh/theme-tweaks ()
  (interactive)

  (let* ((variable-tuple (cond
                          ((x-list-fonts "InterUI") '(:font "InterUI" :height 112))
                          ((x-list-fonts "DejaVu Sans") '(:font "DejaVu Sans" :height 105))
                          ((x-family-fonts "Sans Serif") '(:family "Sans Serif"))
                          (nil (warn "Cannot find a variable width font."))))
         (fixed-tuple (cond
                       ((x-list-fonts "Iosevka") '(:font "Iosevka" :height 105))
                       ((x-family-fonts "Monospace") '(:family "Monospace"))
                       (nil (warn "Cannot find a fixed width font.")))))

    (custom-theme-set-faces
     'user
     `(fixed-pitch ((t (,@fixed-tuple))))
     `(variable-pitch ((t (,@variable-tuple))))))

  (set-face-italic 'font-lock-comment-face t)

  (set-face-attribute 'mode-line nil :height 1.0)
  (set-face-attribute 'mode-line-inactive nil :height 1.0)

  (set-face-attribute 'org-block-begin-line nil :height 0.75)
  (set-face-attribute 'org-block-end-line nil :height 0.75))
#+end_src

* Modeline

Trying out doom-modeline.

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-init)

  :custom-face
  (doom-modeline-evil-emacs-state
   ((t (:background "DarkMagenta" :foreground "#ffd700"))))
  (doom-modeline-evil-insert-state
   ((t (:background "#ffd700" :foreground "#000000"))))
  (doom-modeline-evil-motion-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-normal-state
   ((t (:background "ForestGreen" :foreground "#ffffff"))))
  (doom-modeline-evil-operator-state
   ((t (:background "SteelBlue" :foreground "#ffffff"))))
  (doom-modeline-evil-visual-state
   ((t (:background "#fe8019" :foreground "#000000"))))
  (doom-modeline-evil-replace-state
   ((t (:background "red4" :foreground "#ffffff"))))

  :config
  (setq-default doom-modeline-column-zero-based nil)
  (setq doom-modeline-height 20
        doom-modeline-bar-width 1)
  (column-number-mode t))
#+end_src

* Eeeeevil

I come from vim, so evil is a necessity.

#+begin_src emacs-lisp
(use-package evil
  :demand t
  :after general
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil
        evil-move-cursor-back t
        evil-vsplit-window-right t)

  :general
  (general-define-key
   :keymaps 'override
   :states '(normal emacs)
   "C-h" nil
   "C-t" nil
   "C-n" nil
   "C-s" nil
   "C-e" nil

   "C-h" 'evil-window-left
   "C-t" 'evil-window-down
   "C-n" 'evil-window-up
   "C-s" 'evil-window-right)

  (general-define-key
   :states '(normal visual)
   "h" 'evil-backward-char
   "t" 'evil-next-visual-line
   "n" 'evil-previous-visual-line
   "s" 'evil-forward-char

   "l" 'evil-search-next
   "L" 'evil-search-previous
   "S" 'evil-window-bottom

   "N" 'evil-narrow-indirect)

  (neh/leader-keys
    "bd" '(evil-delete-buffer :which-key "delete buffer"))

  :config
  (evil-mode 1)

  (evil-set-initial-state 'ivy-occur-grep-mode 'normal)

  (general-add-advice (list #'evil-search-next
                            #'evil-search-previous)
                      :after #'recenter)

  (setq evil-normal-state-tag   (propertize " N ")
        evil-emacs-state-tag    (propertize " E ")
        evil-insert-state-tag   (propertize " I ")
        evil-replace-state-tag  (propertize " R ")
        evil-motion-state-tag   (propertize " M ")
        evil-visual-state-tag   (propertize " V ")
        evil-operator-state-tag (propertize " O "))

  (evil-define-operator evil-narrow-indirect (beg end type)
    "Indirectly narrow the region from BEG to END."
    (interactive "<R>")
    (evil-normal-state)
    (narrow-to-region-indirect beg end))

  (use-package evil-surround
    :config
    (global-evil-surround-mode t))

  (use-package evil-indent-plus
    :config
    (evil-indent-plus-default-bindings))

  (use-package evil-textobj-line)
  (use-package evil-textobj-syntax)
  (use-package evil-ex-fasd))
#+end_src

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :init
  (defun neh/evil-key-translations (_mode mode-keymaps &rest _rest)
    (evil-collection-translate-key 'normal mode-keymaps
      "t" "j"
      "n" "k"
      "s" "l"))

  (setq evil-collection-outline-bind-tab-p nil
        evil-collection-company-use-tng nil)

  :config
  (evil-collection-init)
  (add-hook 'evil-collection-setup-hook  #'neh/evil-key-translations))
#+end_src

* Navigation?

#+begin_src emacs-lisp
(use-package ivy
  :hook (after-init . ivy-mode)

  :init
  (defun reloading (cmd)
    (lambda (x)
      (funcall cmd x)
      (ivy--reset-state ivy-last)))

  (defun given-file (cmd prompt) ; needs lexical-binding
    (lambda (source)
      (let ((target
             (let ((enable-recursive-minibuffers t))
               (read-file-name
                (format "%s %s to:" prompt source)))))
        (funcall cmd source target 1))))

  (defun confirm-delete-file (x)
    (dired-delete-file x 'confirm-each-subdirectory))

  (defun neh-open-file-in-vsplit (f)
    (evil-window-vsplit 80 f)
    (balance-windows))

  (defun neh-open-file-in-frame (f)
    (find-file-other-frame f))

  :general
  (neh/leader-keys
    "oo" '(ivy-switch-buffer :which-key "switch buffer")
    "xa" '(ivy-resume :which-key "ivy resume"))

  (general-define-key
   :keymaps 'ivy-minibuffer-map
   "<escape>" 'keyboard-escape-quit
   "C-t" 'ivy-next-line
   "C-n" 'ivy-previous-line
   "C-M-t" 'ivy-next-line-and-call
   "C-M-n" 'ivy-previous-line-and-call
   "C-b" 'ivy-scroll-down-command
   "C-f" 'ivy-scroll-up-command
   "C-d" 'ivy-call)

  (general-define-key
   :keymaps 'counsel-find-file-map
   "TAB" 'ivy-alt-done
   "C-s" 'neh-open-file-in-vsplit)

  (general-define-key
   :keymaps 'ivy-occur-mode-map
   "t" 'ivy-occur-next-line
   "n" 'ivy-occur-previous-line
   "RET" 'ivy-occur-press
   "a" 'ivy-occur-read-action
   "c" 'ivy-occur-toggle-calling
   "C-f" 'evil-scroll-page-down
   "C-b" 'evil-scroll-page-up)

  :config
  (ivy-add-actions
   t
   '(("f" neh-open-file-in-frame "other frame")))

  (setq ivy-use-virtual-buffers t
        ivy-count-format "%d/%d "
        ivy-format-function #'ivy-format-function-arrow
        ivy-extra-directories nil
        ivy-height 15
        ivy-use-selectable-prompt t
        ivy-re-builders-alist
        '((t . ivy--regex-fuzzy))
        ivy-initial-inputs-alist nil))

(use-package prescient
  :demand t
  :config
  (prescient-persist-mode t))

(use-package ivy-prescient
  :hook (ivy-mode . ivy-prescient-mode)

  :config
  ;; Prescient sorting didn't apply to some counsel-projectile commands without this.
  (add-to-list 'ivy-prescient-sort-commands 'counsel-projectile-find-file))

(use-package company-prescient
  :hook (company-mode . company-prescient-mode))

(use-package counsel
  :hook (after-init . counsel-mode)

  :general
  (neh/leader-keys
    "e" '(counsel-M-x :which-key "M-x")

    "ha" '(counsel-apropos :which-key "apropos")

    "oa" '(counsel-linux-app :which-key "app")
    "of" '(counsel-find-file :which-key "open file")

    "sa" '(swiper-all :which-key "search all buffers")
    "sf" '(counsel-ag :which-key "search files")
    "sg" '(counsel-git-grep :which-key "search files in git")
    "sh" '(counsel-grep-or-swiper :which-key "search buffer")
    "so" '(counsel-org-goto-all :which-key "search org")
    "st" '(counsel-semantic-or-imenu :which-key "search tags"))

  :init
  (setq counsel-ag-base-command "ag --nocolor --nogroup --ignore-case %s"
        counsel-grep-base-command "grep -inE '%s' %s")

  ;; These don't work on a fresh load, but seem to start working at some
  ;; point. Strange.
  ;; (ivy-add-actions
  ;;  'counsel-find-file
  ;;  `(("c" ,(given-file #'copy-file "Copy") "copy")
  ;;    ;; ("d" ,(reloading #'confirm-delete-file) "delete")
  ;;    ("f" neh-open-file-in-frame "frame")
  ;;    ("s" neh-open-file-in-vsplit "vsplit")
  ;; ("m" ,(reloading (given-file #'rename-file "Move")) "move")))
  )
#+end_src
#+begin_src emacs-lisp
(use-package avy
  :chords (("qj" . avy-goto-char-2)
           ("jl" . avy-goto-line))

  :general
  (general-define-key
   :states '(normal visual)
   :prefix "j"
   "j" '(avy-goto-char-2 :which-key "char(2)")
   "c" '(avy-goto-char-timer :which-key "char")
   "h" '(avy-org-goto-heading-timer :which-key "org heading")
   "l" '(avy-goto-line :which-key "line"))

  :init
  (setq avy-keys '(?a ?o ?e ?u ?h ?t ?n ?s)))
#+end_src

#+begin_src emacs-lisp
(use-package ace-jump-buffer
  :commands (ace-jump-buffer
             ace-jump-buffer-other-window
             ace-jump-same-mode-buffers
             ace-jump-projectile-buffers
             ace-jump-persp-buffers)
  :general
  (general-def
    :states '(emacs normal)
    "jb" 'ace-jump-buffer))
#+end_src

#+begin_src emacs-lisp
(use-package iflipb
  :commands (iflipb-next-buffer
             iflipb-previous-buffer)
  :general
  (general-def
    :keymaps 'override
    :states '(emacs normal insert)
    "<C-tab>" 'iflipb-previous-buffer
    "C-S-<iso-lefttab>" 'iflipb-next-buffer))
#+end_src

* Projectile

#+begin_src emacs-lisp
(use-package projectile
  :init
  (setq projectile-completion-system 'ivy))

(use-package counsel-projectile
  :hook (counsel-mode . counsel-projectile-mode)

  :general
  (neh/leader-keys
    "oh" '(counsel-projectile :which-key "open file/buffer in project")
    "op" '(counsel-projectile-switch-project :which-key "switch project")
    "sp" '(counsel-projectile-rg :which-key "search project"))

  :config
  ;; Set the default switch project action to find files so that paths are included in the search
  ;; list
  (counsel-projectile-modify-action
   'counsel-projectile-switch-project-action
   '((default counsel-projectile-switch-project-action-find-file)))

  (ivy-add-actions
   'counsel-projectile-find-file
   `(("c" ,(given-file #'copy-file "Copy") "copy")
     ("d" ,(reloading #'confirm-delete-file) "delete")
     ("m" ,(reloading (given-file #'rename-file "Move")) "move")
     ("b" counsel-find-file-cd-bookmark-action "cd bookmark"))))
#+end_src

* Company

Ok, so the =:demand+:hook= combo works with doom-modeline, but not with company. What. The =prog-mode= hook works though. Or just load it in =:config=.

#+begin_src emacs-lisp
(use-package company
  :commands (global-company-mode)
  :hook ((after-init . global-company-mode)
         (evil-collection-setup . (lambda (&rest a)
                                    (evil-define-key 'insert 'company-search-map
                                      (kbd "C-t") 'company-select-next)
                                    (evil-define-key 'insert 'company-search-map
                                      (kbd "C-n") 'company-select-previous))))
  ;; :init
  ;; (add-hook 'after-init-hook 'global-company-mode)
  ;; :config
  ;; (evil-define-key 'insert 'company-search-map
  ;;   (kbd "C-t") 'company-select-next)
  ;; (evil-define-key 'insert 'company-search-map
  ;;   (kbd "C-n") 'company-select-previous)
  )

(use-package company-terraform
  :after company
  :hook (terraform-mode . company-terraform-init))

(use-package company-box
  :after company
  :hook (company-mode . company-box-mode)
  :init
  (setq company-box-enable-icon nil)
  ;; (add-to-list 'company-box-frame-parameters
  ;; '(font . "-CYEL-Iosevka-normal-normal-normal-*-14-*-*-*-d-0-iso10646-1"))
  ;; (add-to-list 'company-box-frame-parameters
  ;; '(font-parameter . "-CYEL-Iosevka-normal-normal-normal-*-14-*-*-*-d-0-iso10646-1"))
  )

(use-package company-quickhelp
  :hook (company-mode . company-quickhelp-mode)
  :general
  (:keymaps 'company-active-map
   "C-m" 'company-quickhelp-manual-begin))

(use-package company-ansible
  :commands (company-ansible)
  :config
  (add-to-list 'company-backends 'company-ansible))
#+end_src

* Git

I find that diff-hl does a better job of showing diff information than git-gutter does. I’d like to use =diff-hl-flydiff-mode=, but it caused issues, which I can’t remember well enough to document now. Will revisit later.

#+begin_src emacs-lisp
(use-package diff-hl
  :hook ((after-init . global-diff-hl-mode)
         (global-diff-hl-mode . diff-hl-flydiff-mode)
         (dired-mode . diff-hl-dired-mode))
  :init
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  :config
  (set-face-attribute 'diff-hl-change nil :foreground "medium blue" :background "DodgerBlue1")
  (set-face-attribute 'diff-hl-insert nil :foreground "dark green" :background "ForestGreen")
  (set-face-attribute 'diff-hl-delete nil :foreground "dark red" :background "red4"))
#+end_src

Diff-hl may be better at /showing/ diff info, but git-gutter is better at doing things with diffs. So I have it active for navigation and staging actions. It’s disabled in org mode because I had issues with it before. Now that my config is in org though, it would be handy to have back. Another TODO.

#+begin_src emacs-lisp
(use-package git-gutter
  :hook (prog-mode . git-gutter-mode)
  :general
  (general-define-key
   :states '(normal visual)
   "gp" 'git-gutter:previous-hunk
   "gn" 'git-gutter:next-hunk
   "gs" 'git-gutter:popup-hunk
   "gS" 'git-gutter:stage-hunk
   "gU" 'git-gutter:revert-hunk)

  :init
  (setq git-gutter:disabled-modes '(org-mode))
  (global-git-gutter-mode -1)

  :config
  (advice-add 'git-gutter:previous-hunk :after #'neh/after-jump)
  (advice-add 'git-gutter:next-hunk :after #'neh/after-jump)

  (setq git-gutter:added-sign ""
        git-gutter:deleted-sign ""
        git-gutter:modified-sign ""
        git-gutter:ask-p nil)
  (set-face-foreground 'git-gutter:modified "DeepSkyBlue2")
  (set-face-foreground 'git-gutter:added "ForestGreen")
  (set-face-foreground 'git-gutter:deleted "red4")
  )
#+end_src

Of course, the great magit.

#+begin_src emacs-lisp
(straight-use-package 'magit)
(use-package magit
  :straight nil
  :hook
  (git-commit-mode . evil-insert-state)

  :general
  (general-define-key
   :keymaps 'magit-mode-map
   "C-b" 'evil-scroll-page-up
   "C-f" 'evil-scroll-page-down
   "M-h" 'magit-section-up
   "M-s" 'magit-section-goto-successor
   "M-t" 'magit-section-forward-sibling
   "M-n" 'magit-section-backward-sibling
   "t" 'evil-next-visual-line
   "n" 'evil-previous-visual-line)

  (general-define-key
   :keymaps 'magit-diff-mode-map
   "/" 'evil-search-forward
   "l" 'evil-search-next
   "L" 'evil-search-previous)

  (neh/leader-keys
    "gf" '(magit-file-popup :which-key "file")
    "gg" '(magit-dispatch-popup :which-key "menu")
    "gs" '(magit-status :which-key "status"))

  :init
  (setq magit-diff-refine-hunk t)

  :config
  (magit-define-popup-action 'magit-file-popup
    ?R "Rename file" 'magit-file-rename)
  (magit-define-popup-action 'magit-file-popup
    ?K "Delete file" 'magit-file-delete)
  (magit-define-popup-action 'magit-file-popup
    ?U "Untrack file" 'magit-file-untrack)
  (magit-define-popup-action 'magit-file-popup
    ?C "Checkout file" 'magit-file-checkout)

  (setq magit-completing-read-function 'ivy-completing-read))
#+end_src

“Forge” can talk to sites like github and provide tools to work with PRs etc. Installing dependencies manually for now [[https://github.com/raxod502/straight.el/issues/336][because]].

#+begin_src emacs-lisp
(use-package forge
  :after markdown-mode
  :init
  (use-package closql)
  (use-package ghub))
#+end_src

Handy package to browse to git repo web interfaces.
#+begin_src emacs-lisp
(use-package git-link
  :commands (git-link
             git-link-commit
             git-link-homepage)
  :general
  (neh/leader-keys
    "gB" 'git-link
    "gC" 'git-link-commit
    "gH" 'git-link-homepage)
  :init
  (setq git-link-open-in-browser t))
#+end_src

* Org

#+begin_src emacs-lisp
(use-package org
  :hook ((org-mode . (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                          'run-at-end 'only-in-org-mode)))
         (org-mode . org-indent-mode)
         (org-mode . variable-pitch-mode)
         (org-capture-mode . evil-insert-state)
         (org-src-mode . disable-flycheck-in-org-src-block))

  :general
  ;; (general-add-advice (list #'org-previous-visible-heading
  ;;                           #'org-next-visible-heading)
  ;;                     :after #'neh/after-jump)

  (neh/leader-keys
    "nb" '(org-narrow-to-block :which-key "narrow to block")
    "ne" '(org-narrow-to-element :which-key "narrow to element")
    "ns" '(org-narrow-to-subtree :which-key "narrow to subtree")

    "oc" 'org-capture
    "oC" '(lambda () (interactive) (find-file org-default-notes-file))
    "og" '(org-agenda :which-key "agenda")
    "o." '(org-open-at-point :which-key "follow link"))

  (general-def
    :keymaps 'org-mode-map
    :states '(normal emacs)
    :prefix  "g"
    "." 'org-open-at-point)

  (general-def
    :keymaps 'org-mode-map
    :states '(normal emacs)
    "<RET>" 'org-tree-to-indirect-buffer
    "ze" 'outline-show-branches)

  (general-def
    :keymaps 'org-mode-map
    :states '(normal)
    "H" 'org-shiftleft
    "T" 'org-shiftdown
    "N" 'org-shiftup
    "S" 'org-shiftright)

  :init
  (setq org-use-fast-todo-selection t
        org-directory "~/org"
        org-default-notes-file "~/org/incoming.org"
        org-agenda-files '("~/org/")
        org-refile-targets '((org-agenda-files :maxlevel . 3))
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil
        org-reverse-note-order t
        org-capture-templates
        (quote (("t" "todo" entry
                 (file+headline "" "Tasks")
                 "* TODO %?"
                 :prepend t)
                ("n" "note" entry
                 (file+headline "" "Notes")
                 "* %?"
                 :prepend t)
                ("l" "link" entry
                 (file+headline "" "Links")
                 "* [[%x][%?]] %^g"
                 :prepend t)
                ("j" "journal" entry
                 (file+olp+datetree
                  (lambda ()
                    (concat org-agenda-files "/journal.org")))
                 "* %?")))
        org-tags-column 0)

  (defface org-inprogress
    '((default :inherit org-todo))
    "Face for INPROGRESS org tasks")
  (defface org-waiting
    '((default :inherit org-todo))
    "Face for WAITING org tasks")

  (let* ((headline      `(:inherit variable-pitch :weight normal))
         (done          `(:inherit variable-pitch :weight normal :foreground "#7c6f64")))

    (custom-theme-set-faces
     'user
     `(org-ellipsis ((t (:underline nil :weight normal))))
     `(org-tag ((t (:underline nil :weight normal :height 0.7 ,@done))))

     `(org-indent ((t (:inherit (org-hide fixed-pitch)))))
     `(org-code ((t (:inherit fixed-pitch))))
     `(org-table ((t (:inherit fixed-pitch))))
     `(org-verbatim ((t (:inherit fixed-pitch))))
     `(org-block ((t (:inherit fixed-pitch))))

     `(org-level-8 ((t (,@headline :height 1.0))))
     `(org-level-7 ((t (,@headline :height 1.0))))
     `(org-level-6 ((t (,@headline :height 1.0))))
     `(org-level-5 ((t (,@headline :height 1.0))))
     `(org-level-4 ((t (,@headline :height 1.0))))
     `(org-level-3 ((t (,@headline :height 1.0))))
     `(org-level-2 ((t (,@headline :height 1.0))))

     `(org-todo ((t (,@headline
                     :weight bold
                     :foreground "#555555"))))
     `(org-inprogress ((t (,@headline
                           :weight bold
                           :foreground "white"
                           :background "ForestGreen"))))
     `(org-waiting ((t (,@headline
                        :weight bold
                        :background "#ffd700"))))
     `(org-done ((t (,@done :strike-through t))))
     `(org-archived ((t (,@done :strike-through t))))
     `(org-headline-done ((t (,@done))))

     `(org-document-title ((t (,@headline :height 1.3 :underline nil))))))

  (setq org-todo-keyword-faces
        '(("TODO" . org-todo)
          ("INPROGRESS" . org-inprogress)
          ("WAITING" . org-waiting)))

  (defmacro my-org-in-calendar (command)
    (let ((name (intern (format "my-org-in-calendar-%s" command))))
      `(progn
         (defun ,name ()
           (interactive)
           (org-eval-in-calendar '(call-interactively #',command)))
         #',name)))

  (general-def org-read-date-minibuffer-local-map
    "M-h" (my-org-in-calendar calendar-backward-day)
    "M-s" (my-org-in-calendar calendar-forward-day)
    "M-n" (my-org-in-calendar calendar-backward-week)
    "M-t" (my-org-in-calendar calendar-forward-week)
    "M-H" (my-org-in-calendar calendar-backward-month)
    "M-S" (my-org-in-calendar calendar-forward-month)
    "M-N" (my-org-in-calendar calendar-backward-year)
    "M-T" (my-org-in-calendar calendar-forward-year))

  :config
  ;; from https://twitter.com/jay_f0xtr0t/status/982353141386461188
  ;; could be better; will currently keep adding to =org-emphasis-regexp-components=
  (setcar (nthcdr 1 org-emphasis-regexp-components)
          (concat (nth 1 org-emphasis-regexp-components) "s"))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)

  (setq org-todo-keywords '((sequence "TODO(t)"
                                      "INPROGRESS(i!)"
                                      "WAITING(w@/!)"
                                      "|"
                                      "DONE(d!)"
                                      "CANCELED(c@)")))

  (setq org-startup-indented t
        org-ellipsis " ⋯"
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-cycle-separator-lines 2
        org-M-RET-may-split-line '((default . nil))
        org-indirect-buffer-display 'current-window
        org-use-sub-superscripts nil)

  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-window-setup 'current-window
        org-src-tab-acts-natively t
        org-src-preserve-indentation t)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t))))

(use-package org-tempo
  :straight nil
  :after org)
#+end_src

#+begin_src emacs-lisp
(use-package evil-org
  :after evil
  :hook ((org-mode . evil-org-mode)
         (evil-org-mode . (lambda ()
                            (evil-org-set-key-theme))))

  :config
  (setq evil-org-movement-bindings '((up . "n")
                                     (down . "t")
                                     (left . "h")
                                     (right . "s")))

  (add-to-list 'evil-org-key-theme 'shift))
#+end_src

Make org-mode prettier.

#+begin_src emacs-lisp
(use-package org-bullets
  :init
  (setq org-bullets-bullet-list '(" "))
  :hook (org-mode . org-bullets-mode))
#+end_src

Org export.

#+begin_src emacs-lisp
(use-package ox-pandoc
  :ensure-system-package (pandoc
                          pdflatex
                          mktexfmt))

(use-package ox-odt
  :straight nil
  :ensure-system-package zip)

(use-package ox-slack
  :commands (org-slack-export-as-slack
             org-slack-export-to-slack
             org-slack-export-to-clipboard-as-slack))
#+end_src

* Shackle

Let’s try to get some window behaviour under control.

#+begin_src emacs-lisp
(use-package shackle
  :hook (after-init . shackle-mode)
  :init
  (setq shackle-rules
        '((magit-diff-mode :align 'below :size 0.8))))
#+end_src

* Dired

#+begin_src emacs-lisp
(use-package dired
  :straight nil
  :hook (dired-mode . dired-hide-details-mode)
  :commands (dired-jump
             dired-mode)
  :general
  (neh/leader-keys
    "od" 'dired-jump)
  :init
  (setq dired-listing-switches "-alh"))

(use-package dired-x
  :straight nil
  :hook (dired-mode . dired-omit-mode)
  :general
  (general-define-key
   :states 'normal
   :keymaps 'dired-mode-map
   ")" 'dired-omit-mode)
  :init
  (setq dired-omit-files "^\\...+$"))

(use-package dired-single
  :after dired
  :commands (dired-single-buffer
             dired-single-buffer-mouse
             dired-single-up-directory)
  :general
  (general-define-key
   :states 'normal
   :keymaps 'dired-mode-map
   "<return>" 'dired-single-buffer
   "^" 'dired-single-up-directory))

(use-package dired-sidebar
  :disabled t
  :general
  (neh/leader-keys
    "ot" 'dired-sidebar-toggle-sidebar)

  :init
  (setq dired-sidebar-theme 'nerd))

(use-package dired-k
  :disabled t
  :hook ((dired-initial-position-hook . dired-k)
         (dired-after-readin-hook . dired-k-no-revert))
  :init
  (setq dired-k-human-readable t))
#+end_src

* Imenu

#+begin_src emacs-lisp
(use-package imenu-list
  :general
  (neh/leader-keys
    "os" '(imenu-list-smart-toggle :which-key "code structure"))

  :init
  (setq imenu-list-focus-after-activation t))

(use-package imenu-anywhere
  :after ivy
  :general
  (neh/leader-keys
    "sT" '(ivy-imenu-anywhere :which-key "imenu anywhere")))
#+end_src

* Hydra

#+begin_src emacs-lisp
(use-package hydra
  :general
  (neh/leader-keys
    "rc" '(hydra-codereading/body :which-key "changes")
    "rg" '(hydra-git-gutter/body :which-key "changes")
    "ro" '(hydra-org/body :which-key "org")
    "rr" '(hydra-reading/body :which-key "plain text")
    "zt" '(hydra-zoom/body :which-key "zoom text"))

  :config
  (defhydra hydra-reading ()
    "Text reading/navigation"
    ("t" (evil-scroll-down 0) "down")
    ("n" (evil-scroll-up 0) "up")
    ("T" (scroll-up) "next page")
    ("N" (scroll-down) "prev page")
    ("q" nil "quit" :color blue))

  (defhydra hydra-zoom ()
    "zoom"
    ("+" text-scale-increase "in")
    ("-" text-scale-decrease "out")
    ("0" (text-scale-adjust 0) "reset")
    ("q" nil "quit" :color blue))

  (defhydra hydra-git-gutter ()
    "Browse/stage/revert git hunks"
    ("n" (progn (git-gutter:previous-hunk 1)
                (evil-scroll-line-to-center (line-number-at-pos))) "previous hunk")
    ("t" (progn (git-gutter:next-hunk 1)
                (evil-scroll-line-to-center (line-number-at-pos))) "next hunk")
    ("s" git-gutter:stage-hunk "stage hunk")
    ("r" git-gutter:revert-hunk "revert hunk")
    ("q" nil "quit" :color blue))

  (defhydra hydra-org (:color red :columns 3)
    "Org Mode Movements"
    ("t" outline-next-visible-heading "next heading")
    ("n" outline-previous-visible-heading "prev heading")
    ("T" org-forward-heading-same-level "next heading at same level")
    ("N" org-backward-heading-same-level "prev heading at same level")
    ("H" outline-up-heading "up heading")
    ("<tab>" org-cycle "cycle")
    ("g" org-goto "goto" :exit t)
    ("q" nil "quit" :color blue)))

(use-package ivy-hydra
  :config
  (defhydra hydra-ivy (:hint nil
                       :color pink)
    "
      ^ ^ ^ ^ ^ ^ | ^Call^  | ^Cancel^ | ^Options^ | Action _r_/_c_/_a_: %-14s(ivy-action-name)
      ^-^-^-^-^-^-+----^-^--+-^-^------+-^-^-------+-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---------------------------
      ^ ^ _n_ ^ ^ | occ_u_r | _i_nsert | _C_: calling %-5s(if ivy-calling \"on\" \"off\") Case-_F_old: %-10`ivy-case-fold-search
      _h_ ^+^ _s_ | _d_one  | ^ ^      | _m_: matcher %-5s(ivy--matcher-desc)^^^^^^^^^^^^ _T_runcate: %-11`truncate-lines
      ^ ^ _t_ ^ ^ | _g_o    | ^ ^      | _<_/_>_: shrink/grow^^^^^^^^^^^^^^^^^^^^^^^^^^^^ _D_efinition of this menu
      "
    ;; arrows
    ("h" ivy-beginning-of-buffer)
    ("t" ivy-next-line)
    ("n" ivy-previous-line)
    ("s" ivy-end-of-buffer)
    ;; actions
    ("<ESC>" keyboard-escape-quit :exit t)
    ("C-g" keyboard-escape-quit :exit t)
    ("q" keyboard-escape-quit :exit t)
    ("i" nil)
    ("C-o" nil)
    ;; ("f" ivy-alt-done :exit nil)
    ("C-j" ivy-alt-done :exit nil)
    ("d" ivy-done :exit t)
    ("g" ivy-call)
    ("S" (ivy-exit-with-action
          (lambda (f) (evil-window-vsplit 80 f)
            (balance-windows)))
     :exit t)
    ("C-m" ivy-done :exit t)
    ("C" ivy-toggle-calling)
    ("m" ivy-toggle-fuzzy)
    (">" ivy-minibuffer-grow)
    ("<" ivy-minibuffer-shrink)
    ("r" ivy-prev-action)
    ("c" ivy-next-action)
    ("a" ivy-read-action)
    ("T" (setq truncate-lines (not truncate-lines)))
    ("F" ivy-toggle-case-fold)
    ("u" ivy-occur :exit t)
    ("D" (ivy-exit-with-action
          (lambda (_) (find-function 'hydra-ivy/body)))
     :exit t)))

(defhydra hydra-windows (:hint nil)
  "
     Go: _h_ _t_ _n_ _s_
   Move: _H_ _T_ _N_ _S_

   Only: _o_
  Close: _c_

   Exit: _q_
  "
  ("h" evil-window-left)
  ("n" evil-window-up)
  ("t" evil-window-down)
  ("s" evil-window-right)

  ("H" evil-window-move-far-left)
  ("T" evil-window-move-very-bottom)
  ("N" evil-window-move-very-top)
  ("S" evil-window-move-far-right)

  ("o" delete-other-windows)
  ("c" evil-window-delete)

  ("q" nil))

;; from https://github.com/abo-abo/hydra/wiki/straight.el
(defhydra hydra-straight-helper (:hint nil)
  "
  _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
  _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
  ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
  _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
  _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
  ("c" straight-check-all)
  ("C" straight-check-package)
  ("r" straight-rebuild-all)
  ("R" straight-rebuild-package)
  ("f" straight-fetch-all)
  ("F" straight-fetch-package)
  ("p" straight-pull-all)
  ("P" straight-pull-package)
  ("m" straight-merge-all)
  ("M" straight-merge-package)
  ("n" straight-normalize-all)
  ("N" straight-normalize-package)
  ("u" straight-push-all)
  ("U" straight-push-package)
  ("v" straight-freeze-versions)
  ("V" straight-thaw-versions)
  ("w" straight-watcher-start)
  ("W" straight-watcher-quit)
  ("g" straight-get-recipe)
  ("e" straight-prune-build)
  ("q" nil))
#+end_src

* Reading and Note-taking

First, set up =pdf-tools= for nice PDF handling.

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :hook (pdf-view-mode . (lambda () (blink-cursor-mode -1)))
  :init
  (setq-default pdf-view-display-size 'fit-page))
#+end_src

Add =nov.el= for =epub=s.

#+begin_src emacs-lisp 
(use-package nov
  :mode (("\\.epub\\'" . nov-mode)))
#+end_src

Try out =org-noter=.

#+begin_src emacs-lisp
(use-package org-noter
  :commands (org-noter)
  :config
  (org-noter-set-auto-save-last-location t))
#+end_src

* Misc packages

#+begin_src emacs-lisp
(use-package restart-emacs
  :commands (restart-emacs))

(use-package golden-ratio
  :commands golden-ratio-mode
  :config
  (setq golden-ratio-auto-scale t))

;; The auto-decrypt-encrypt hook complains about the password-file var not being set, even though
;; the manual encrypt/decrypt functions work just fine.
(use-package ansible
  :commands (ansible ansible::auto-decrypt-encrypt)
  :hook ((yaml-mode . ansible)
         (ansible . ansible::auto-decrypt-encrypt))
  :init
  (setq ansible::vault-password-file "~/freshgrade/vaultpass"))

(use-package rainbow-delimiters
  :general
  (neh/leader-keys
    "vd" '(rainbow-delimiters-mode :which-key "delimiters"))

  :config
  (set-face-attribute 'rainbow-delimiters-unmatched-face nil :height 1.0 :inherit 'error)
  (set-face-attribute 'rainbow-delimiters-depth-1-face nil :height 1.0)
  (set-face-attribute 'rainbow-delimiters-depth-2-face nil :height 1.1)
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil :height 1.2)
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil :height 1.3)
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil :height 1.4)
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil :height 1.5)
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil :height 1.6)
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil :height 1.7)
  (set-face-attribute 'rainbow-delimiters-depth-9-face nil :height 1.8))

(use-package wgrep
  :commands ivy-wgrep-change-to-wgrep-mode)

(use-package elec-pair
  :ensure nil
  :hook (prog-mode . electric-pair-mode))

(use-package executable
  :ensure nil
  :hook (after-save . executable-make-buffer-file-executable-if-script-p))

(use-package quick-peek
  :commands (quick-peek-show
             quick-peek-hide
             quick-peek-overlay-contents
             quick-peek-overlay-ensure-at))

(use-package flycheck
  :hook (prog-mode . flycheck-mode))

(use-package flycheck-inline
  :hook (flycheck-mode . turn-on-flycheck-inline)
  :init
  ;; (setq flycheck-inline-display-function
  ;;       (lambda (msg pos)
  ;;         (let* ((ov (quick-peek-overlay-ensure-at pos))
  ;;                (contents (quick-peek-overlay-contents ov)))
  ;;           (setf (quick-peek-overlay-contents ov)
  ;;                 (concat contents (when contents "\n") msg))
  ;;           (quick-peek-update ov)))
  ;;       flycheck-inline-clear-function #'quick-peek-hide))
  )

(use-package flycheck-posframe
  :disabled
  :hook (flycheck-mode . flycheck-posframe-mode)
  :config
  (set-face-attribute 'flycheck-posframe-warning-face nil
                      :height 1.1 :foreground "#111111" :background "#ffd700" :inherit 'warning)
  (set-face-attribute 'flycheck-posframe-error-face nil
                      :height 1.1 :foreground "#eeeeee" :background "#b22222" :inherit 'error))

(use-package typo
  :hook (text-mode . typo-mode))

(use-package rainbow-mode
  :general
  (neh/leader-keys
    "vc" '(rainbow-mode :which-key "colours")))

(use-package hl-line+
  :disabled
  :config
  (setq hl-line-inhibit-highlighting-for-modes '(org-mode))
  (toggle-hl-line-when-idle -1))

(use-package symbol-overlay
  :general
  (neh/leader-keys
    "hs" '(symbol-overlay-put :which-key "highlight symbol")
    "hp" '(symbol-overlay-switch-backward :which-key "previous highlighted symbol")
    "hn" '(symbol-overlay-switch-forward :which-key "next highlighted symbol")
    "hC" '(symbol-overlay-remove-all :which-key "clear highlighted symbols")
    "hM" '(symbol-overlay-mode :which-key "symbol overlay mode")))

(use-package aggressive-indent
  :hook (emacs-lisp-mode . aggressive-indent-mode))

(use-package direnv
  :hook (after-init . direnv-mode)
  :config
  (setq direnv-always-show-summary nil))

(defun my-evil-indent-setup ()
  "Set evil-shift-width to the relevant language indent level (but yaml only, so far)."
  (setq evil-shift-width yaml-indent-offset))

(use-package yaml-mode
  :gfhook #'my-evil-indent-setup
  :commands yaml-mode
  :mode (("\\(host\\|group\\)_vars.*" . yaml-mode)
         ("\\.yml|yaml\\'" . yaml-mode))
  :hook ((yaml-mode . (lambda () (typo-mode -1)))
         (yaml-mode . git-gutter-mode)))

(use-package json-mode
  :mode (("\\.json\\'" . json-mode)))

(use-package expand-region
  :general
  (general-define-key
   :states 'visual
   "v" 'er/expand-region
   "V" 'er/contract-region))

(use-package markdown-mode
  :commands (markdown-mode)
  :mode ("\\.md'" . markdown-mode))

(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode))

(defun neh/python-mode-hook ()
  "My python mode settings."
  (add-to-list 'company-backends 'company-jedi))
(use-package elpy
  :commands elpy-enable
  :init
  (with-eval-after-load 'python (elpy-enable)))

(use-package company-jedi
  :after company
  :hook (python-mode . neh/python-mode-hook))

(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))

(use-package hcl-mode
  :commands hcl-mode)

(use-package terraform-mode
  :mode ("\\.tf|tfvars\\'" . terraform-mode)
  :hook (terraform-mode . terraform-format-on-save-mode))

(use-package groovy-mode
  :mode ("Jenkinsfile\\'" . groovy-mode))

(use-package dockerfile-mode
  :mode ("Dockerfile\\'" . dockerfile-mode))

(use-package go-mode
  :mode "\\.go\\'")

(use-package go-eldoc
  :commands go-eldoc-setup
  :hook (go-mode . go-eldoc-setup))

(use-package csv-mode
  :mode "\\.csv\\'")

(use-package elf-mode
  :commands elf-mode
  :magic ("ELF" . elf-mode))
#+end_src

* Misc functions

Ending up at the bottom of the window and not being able see enough context when jumping around is annoying, so I have this to help deal with that by recentering after jumps.

#+begin_src emacs-lisp
(defun neh/after-jump (&optional arg)
  "Position text sanely after jumping. ARG is unused but apparently necessary."
  (evil-scroll-line-to-center (line-number-at-pos)))
#+end_src

Attaching this next one to =org-src-mode= will disable the annoying flycheck warnings that are really only relevant to complete files.

#+begin_src emacs-lisp
(defun disable-flycheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src

#+begin_src emacs-lisp
(defun narrow-to-region-indirect (start end)
  "Restrict editing in this buffer to the current region (from START to END), indirectly."
  (interactive "r")
  (deactivate-mark)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-region start end))
    (switch-to-buffer buf)))

(defun shorten-directory (dir max-length)
  "Show up to MAX-LENGTH characters of a directory name DIR."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
        (output ""))
    (when (and path (equal "" (car path)))
      (setq path (cdr path)))
    (while (and path (< (length output) (- max-length 4)))
      (setq output (concat (car path) "/" output))
      (setq path (cdr path)))
    (when path
      (setq output (concat "…/" output)))
    output))

(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
        (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))

;; https://github.com/noctuid/general.el#use-package-keyword
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
(defun Fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.

  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:

  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);

  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;

  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.

  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))

(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'Fuco1/lisp-indent-function)))


;; from https://stackoverflow.com/questions/47327066/how-to-open-an-indirect-buffer-in-a-new-frame-in-a-single-call-in-emacs
(defun clone-indirect-buffer-other-frame (newname display-flag &optional norecord)
  "Like `clone-indirect-buffer' but display in another frame."
  (interactive
   (progn
     (if (get major-mode 'no-clone-indirect)
         (error "Cannot indirectly clone a buffer in %s mode" mode-name))
     (list (if current-prefix-arg
               (read-buffer "Name of indirect buffer: " (current-buffer)))
           t)))
  ;; (let ((pop-up-windows t))
  (let ((pop-up-frames t)) ; <==========
    (clone-indirect-buffer newname display-flag norecord)))

(defun org-tree-to-indirect-buffer-other-frame ()
  (interactive
   (let ((org-indirect-buffer-display 'new-frame))
     (org-tree-to-indirect-buffer))))
#+end_src

* Epilogue

Load any host-specific configuration.

#+begin_src emacs-lisp
(setq neh/local-conf-file (expand-file-name
                           (concat system-name ".el")
                           user-emacs-directory))
(when (file-readable-p neh/local-conf-file)
  (load-file neh/local-conf-file))
#+end_src

Here we close the =let= expression from [[*Performance optimization][the preface]].

#+begin_src emacs-lisp
)
#+end_src

We also reset the value of =gc-cons-threshold=, not to its original value, we still leave it larger than default so that GCs don't happen so often.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src
